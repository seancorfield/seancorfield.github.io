<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Boot | An Architect's View]]></title>
  <link href="http://seancorfield.github.io/blog/categories/boot/atom.xml" rel="self"/>
  <link href="http://seancorfield.github.io/"/>
  <updated>2018-08-30T17:29:58-07:00</updated>
  <id>http://seancorfield.github.io/</id>
  <author>
    <name><![CDATA[Sean Corfield]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[All the Paths]]></title>
    <link href="http://seancorfield.github.io/blog/2018/04/18/all-the-paths/"/>
    <updated>2018-04-18T03:40:00-07:00</updated>
    <id>http://seancorfield.github.io/blog/2018/04/18/all-the-paths</id>
    <content type="html"><![CDATA[<p>With the recent arrival of <a href="https://clojure.org/guides/deps_and_cli"><code>clj</code> and <code>tools.deps.alpha</code></a> as a &ldquo;standard&rdquo; lightweight way to run Clojure programs and the seed for tooling based on <code>deps.edn</code> dependency files, it&rsquo;s time to take a look at the terminology used across Clojure&rsquo;s various tools.<!-- more --></p>

<h2>Running Java/JVM Programs</h2>

<p>Before we dive into Clojure&rsquo;s tools, let&rsquo;s first consider the basics. When you run a compiled Java (or any JVM-based) program, you need two things: a classpath and a <code>main</code> function or, rather, a &ldquo;main class&rdquo;. Everything boils down to <code>java -cp ... MyClass</code> where the <code>...</code> is the &ldquo;classpath&rdquo;: a colon-delimited (or semicolon-delimited on Windows) list of directories or JAR files to search for <code>MyClass</code> and all the classes it needs. A quick look at the many introductory tutorials for Java online shows that the classpath is mostly just glossed over, despite being one of the most important (and, for beginnners, often one of the most perplexing) aspects of running programs on the JVM.</p>

<p>When you are creating deployable versions of programs, you typically use some sort of &ldquo;build&rdquo; tool to gather up all your (compiled) class files and JAR files (dependencies) and put them all together in a single &ldquo;uber&rdquo; JAR file, so that it can be run with just <code>java -jar MyApplication.jar</code>. This is shorthand for specifying <code>MyApplication.jar</code> as the entire classpath and assuming some &ldquo;magic&rdquo; inside the JAR file that specifies how to find the main class (via something called a &ldquo;manifest&rdquo;). The build tools know how to create the manifest (based on some information you provide) as well as managing the assembly of all the component pieces that will make up your complete application.</p>

<p>It&rsquo;s no wonder this can be a minefield for beginners!</p>

<h2>Leiningen</h2>

<p>In the very early days of Clojure, folks relied on the JVM ecosystem for build tools and dealt with all the sharp edges directly. Then along came <a href="https://leiningen.org/">Leiningen</a> with the goal of &ldquo;automating Clojure projects without setting your hair on fire&rdquo; by hiding all the sharp edges of Maven and <code>pom.xml</code> files and manifests and so on. It was so successful that it soon became the de facto standard in the Clojure world and most of the Clojure books out there can safely assume you have Leiningen installed. You can even just type <code>lein new app myapp</code> and you have a nicely structured skeleton of a Clojure project to get you up and running! Leiningen dispensed with all the XML and arcane invocations of the Java world and used a simple <code>project.clj</code> file to declare everything about your program. Your dependencies, your main namespace (class), various different ways of running your program (profiles), and all the tools you needed for development and testing (plugins).</p>

<p>The main aspect of Leiningen that is relevant to this blog post is the concept of &ldquo;paths&rdquo;. As noted above, as far as the JVM is concerned, there&rsquo;s really only the classpath: that&rsquo;s how you run your code. The various build tools need to know what else should be packaged up for deployment (e.g., configuration files, HTML/CSS/JS assets), as well as what you need to run tests or other development-related tasks that do not need to be in the deployment artifact.</p>

<p>Leiningen chose the following terminology for these various things:</p>

<ul>
<li><code>source-paths</code> &ndash; your Clojure code that should be part of every runtime, as well as being packaged up for deployment.</li>
<li><code>java-source-paths</code> &ndash; any Java code in your project that should be compiled, and whose <code>.class</code> files should be packaged up for deployment.</li>
<li><code>test-paths</code> &ndash; your Clojure code needed for development/testing of your application, which should <em>not</em> be part of the deployment artifact.</li>
<li><code>resource-paths</code> &ndash; your non-code files that should be made available at runtime (i.e., on the classpath), as well as being packaged up for deployment.</li>
<li><code>dependencies</code> &ndash; the list of project artifacts (and versions) that your program needs at runtime, and therefore should be packaged up for deployment &ndash; or at least declared in the deployment artifact as being needed for runtime.</li>
</ul>


<p>There&rsquo;s a subtlety here that Leiningen glosses over: there are really two types of files that are not code, that both need to be in the deployment artifact &ndash; those that need to be on the classpath during Leiningen&rsquo;s runtime (configuration files etc) and those that do not (HTML/CSS/JS etc). In Leiningen&rsquo;s world they are all &ldquo;resources&rdquo; and end up on the classpath anyway. This is a harmless convenience, but it&rsquo;s still an important distinction (note: once packaged up, everything in the JAR will be available on that program&rsquo;s runtime and, in general, during development/testing you will usually want your &ldquo;web root&rdquo; to be on your classpath, so that <code>io/resource</code> can find those files).</p>

<h2>Boot</h2>

<p><a href="http://boot-clj.com/">Boot</a> came along later in Clojure&rsquo;s evolution and approached build tools from a different direction. While most build tools (across most languages) are &ldquo;declarative&rdquo;, i.e., they have some sort of Domain-Specific Language (DSL) and a file that describes the various properties of your development/testing/packaging strategies, Boot decided to provide a library and a set of abstractions that would let you write pure Clojure to implement your needs. As Boot&rsquo;s website says &ldquo;It&rsquo;s not a build tool - it&rsquo;s build tooling.&rdquo;</p>

<p>I&rsquo;ve <a href="http://corfield.org/blog/categories/boot/">written about Boot</a> quite a bit since we made our decision at <a href="http://worldsinglesnetworks.com/">World Singles llc</a> to switch our stack from Leiningen to Boot, back in late 2015. Boot feels more like Clojure: it&rsquo;s composable and &ldquo;it&rsquo;s just code&rdquo;. Boot can do everything that Leiningen can do, and quite a bit more. And of course it chose its own terminology for the various JVM-related paths:</p>

<ul>
<li><code>resource-paths</code> &ndash; any files that need to both be on the classpath and packaged up for deployment.</li>
<li><code>source-paths</code> &ndash; any files that need to be on the classpath, but not part of the deployment artifact.</li>
<li><code>asset-paths</code> &ndash; any files that do not need to be on the classpath, but should be packaged up for deployment.</li>
<li><code>dependencies</code> &ndash; the list of project artifacts (and versions) that your program needs at runtime (etc).</li>
</ul>


<p>We see that Boot distinguishes between the two types of files that are not code, that both need to be in the deployment artifact, but blurs the lines between code and non-code files that need to be on the classpath. That means that when we move back and forth between Boot and Leiningen, we need to remember that they call certain core concepts by different names. Boot&rsquo;s <code>source-paths</code> are pretty much equivalent to Leiningen&rsquo;s <code>test-paths</code>. Boot&rsquo;s <code>asset-paths</code> are mapped into Leiningen&rsquo;s <code>resource-paths</code> (despite not needing to be on the classpath during the tool&rsquo;s runtime) and Leiningen&rsquo;s <code>source-paths</code> are mapped into Boot&rsquo;s <code>resource-paths</code> (despite being specifically <em>source</em> code). It definitely has potential to be confusing but it&rsquo;s born out of different approaches to how the fileset is managed across the lifecycle of both tools. In particular, Boot has a fileset abstraction that is key to how tasks are written and how various types of files are manipulated during Boot&rsquo;s execution &ndash; see <a href="https://github.com/boot-clj/boot/wiki/Boot-Environment">https://github.com/boot-clj/boot/wiki/Boot-Environment</a> for more detail about this.</p>

<h2>clj - Bringing It Back Home</h2>

<p>As Clojure 1.9 was being developed, it became important to be able to treat &ldquo;Clojure core&rdquo; as a single artifact, even tho' it consisted of &ldquo;core&rdquo; plus &ldquo;spec.alpha&rdquo; plus &ldquo;core.specs.alpha&rdquo;. Out of that came the <code>deps.edn</code> file for specifying dependencies, the <code>tools.deps.alpha</code> library for manipulating the <code>deps.edn</code> files and the dependencies they declare, and the <code>clj</code> and <code>clojure</code> command-line scripts that provide a standardized way to run Clojure programs based on dependencies specified in <code>deps.edn</code> files.</p>

<p>Just like the underlying Java (JVM) ecosystem, Clojure&rsquo;s new Command-Line Interface (CLI) is primarily about the classpath. It provides a mechanism to specify a set of paths and a set of dependencies, across (typically) three files (the &ldquo;install&rdquo; <code>deps.edn</code>, your &ldquo;home&rdquo; <code>deps.edn</code>, and your &ldquo;project&rdquo; <code>deps.edn</code>). It supports &ldquo;aliases&rdquo; for merging in alternative paths and dependencies. It also supports JVM options, and the options already available in <code>clojure.main</code>: initial and main options, to specify files to load, code to run, and a main namespace.</p>

<p>By getting back to basics, <code>clj</code> mirrors the underlying JVM ecosystem that really only cares about the classpath, constructed in appropriate ways for developing, testing, and running your program. It leaves decisions about packaging up to other tools, by design, and through the <code>tools.deps.alpha</code> library it offers a straightforward API for tool authors to build upon.</p>

<p>Late last year (November 2017), I started work on <a href="https://github.com/seancorfield/boot-tools-deps">boot-tools-deps</a> which was intended as a bridge to add Boot-based tooling on top of an existing <code>deps.edn</code> project. There is also <a href="https://github.com/RickMoynihan/lein-tools-deps">lein-tools-deps</a> which takes a slightly different approach but is intended to integrate <code>deps.edn</code> files into a Leiningen project.</p>

<p>We&rsquo;ve also seen the first two &ldquo;build tools&rdquo; based on <code>deps.edn</code> appear: <a href="https://github.com/healthfinch/depstar">depstar</a> and <a href="https://github.com/juxt/pack.alpha">juxt.pack</a> which, like the Boot and Leiningen tools above, take different approaches but are both intended to build (uber) JAR files from projects based on <code>deps.edn</code>.</p>

<p>This means that we need to look closely at the decisions each of these tools make about paths. The recommended approach with <code>clj</code> and <code>deps.edn</code> is to use aliases (liberally) to delineate the different classpaths (and JVM options and main options and so on) that all your various tasks require. The end result in each case is a specific classpath and options to run your code. For build tools, &ldquo;run your code&rdquo; means take the files on the classpath and package them up into a JAR file &ndash; so the entire file selection process is driven by aliases. This is rather different to the Leiningen and Boot build tools outlined above, since they provide explicit categories in which to declare files and folders for consideration in the classpath, non-classpath, packaging, and non-packaging categories.</p>

<p><code>lein-tools-deps</code> is intended primarily to replace your <code>:dependencies</code> vector by dependencies drawn from various <code>deps.edn</code> files. It doesn&rsquo;t (currently) worry about aliases, and it relies on the existing Leiningen infrastructure for all development/testing/packaging decisions. It&rsquo;s a nice, straightforward metaphor: <code>:mvn/version</code> dependencies in <code>deps.edn</code> are mapped into Leiningen&rsquo;s <code>:dependencies</code> and nothing else changes. The project maintainer, Rick Moynihan, intends to expand its functionality over time.</p>

<p>Both <code>juxt.pack</code> and <code>depstar</code> assume that you know what you&rsquo;re doing with aliases and they take whatever you&rsquo;ve decided is your classpath and they turn it into a JAR file. <code>depstar</code> takes the simpler approach, producing just a JAR file with no assumptions built-in &ndash; you need to tell it what main namespace to run and so on. <code>juxt.pack</code> is closer to a standard build tool and targets both AWS Lambda and traditional uber-JAR approaches.</p>

<p><code>boot-tools-deps</code> is intended to be a hybrid that envelops the underlying <code>deps.edn</code> and <code>tools.deps.alpha</code> machinery, exposing most of the same options, and then allows you to either run Boot tasks using the same, underlying classpath, or merge the <code>clj</code> environment back into the Boot environment to support different tooling. Specifically, it assumes that what comes out of <code>deps.edn</code> in the <code>:paths</code> key should be the <code>:resource-paths</code> &ndash; source and non-source, that is intended to be on the classpath and intended to be packaged for deployment. This includes <code>:git/url</code> and <code>:local/root</code> dependencies (since those are source code paths/folders). It also assumes that what comes out of <code>deps.edn</code> in the <code>:extra-paths</code> key should be the <code>:source-paths</code> &ndash; source code that is intended to be on the classpath but not packaged for deployment. While this is a fairly arbitrary interpretation of an artificial divide between entities on the classpath, I believe this is &ldquo;likely&rdquo; in the real world. In any case, this can be modified by Boot&rsquo;s <code>sift</code> task. Finally, it assumes that what comes out of <code>deps.edn</code> as a map of actual libraries and versions should be the <code>:dependencies</code> for Boot itself. This ought to be a straightforward assumption but it can cause problems if the dependencies use <code>:scope</code> extensively since that is not propagated by the Maven/Resolver library behind <code>tools.deps.alpha</code> and is of dubious value in the first place. In particular, transitive dependencies will not have the same scope as the parent that introduced them! Using aliases to assemble your dependencies is a much safer bet.</p>

<h2>Looking Forward</h2>

<p><code>clj</code> and <code>deps.edn</code> and <code>tools.deps.alpha</code> provide a core, standardized way of dealing with dependencies and various options that are required to run Clojure programs. Over time, this should become the standard baseline for &ldquo;installing&rdquo; and running Clojure code on Linux, Mac, and Windows. Both Leiningen and Boot have a strongly entrenched user base and both provide substantially enhanced behavior above and beyond <code>clj</code> and its components &ndash; that&rsquo;s by design. It is reasonable to assume that tooling based on <code>clj</code>, <code>deps.edn</code>, and <code>tools.deps.alpha</code> will become much more commonplace and there will come a day, possibly soon, where developers who pick up Clojure no longer need to consider installing Boot or Leiningen for their day-to-day work.</p>

<h2>p.s. Building New Projects</h2>

<p>Another common function that both Leiningen and Boot provide is to generate new projects based on a template. Check out <a href="https://github.com/seancorfield/clj-new">clj-new</a> for <code>clj</code>-based tooling that generates new <code>deps.edn</code>-based projects, as well as leveraging existing <code>lein-template</code> and <code>boot-template</code> projects.</p>

<h2>Credits</h2>

<p>Thank you to Alan Dipert, Alex Miller, Richiardi Andrea, and Rick Moynihan for reviewing a draft of this post and providing feedback and suggestions!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boot Localrepo?]]></title>
    <link href="http://seancorfield.github.io/blog/2017/11/17/boot-localrepo/"/>
    <updated>2017-11-17T04:50:00-08:00</updated>
    <id>http://seancorfield.github.io/blog/2017/11/17/boot-localrepo</id>
    <content type="html"><![CDATA[<p>Sometimes you just can&rsquo;t help having a &ldquo;random 3rd part JAR file&rdquo; in your project. The best practice is, of course, to upload it to your preferred Maven-compatible repository via whatever service or software you use for all your in-house shared artifacts. But sometimes you just want to play with that JAR file locally, or you haven&rsquo;t gotten around to running your own shared repository.</p>

<p>If you&rsquo;re using Leiningen, you&rsquo;ll probably reach for the excellent <a href="https://github.com/kumarshantanu/lein-localrepo"><code>lein-localrepo</code></a> which lets you &ldquo;install&rdquo; your random JAR file into your local Maven cache (in <code>~/.m2/repository</code>).</p>

<p>What do you do if you&rsquo;re using Boot instead?<!-- more --></p>

<p>Well, you <em>could</em> just keep <code>lein</code> installed and use it for this (with the <code>lein-localrepo</code> plugin dependency in your <code>~/.lein/profiles.clj</code>, for example):</p>

<pre><code class="bash">lein localrepo install foobar.jar foo/bar 1.0.1
</code></pre>

<p>Or you could run some command line Boot to make that happen:</p>

<pre><code class="bash">boot pom -p foo/bar -v 1.0.1 target \
    install -f foobar.jar -p target/META-INF/maven/foo/bar/pom.xml
# Don't forget to clean up!
rm -rf target
</code></pre>

<p>What the what? Yeah, that&rsquo;s really kind of ugly. Unfortunately, the <code>install</code> task seems to expect a physical <code>pom.xml</code> file when you specify a physical JAR file. That means we need to drop a <code>target</code> task into the pipeline into order for the generated <code>pom.xml</code> to be written to disk. It would be nice if it would look in the fileset first, because then at least this should work:</p>

<pre><code class="bash"># This does NOT work!
boot pom -p foo/bar -v 1.0.1 install -f foobar.jar -p foo/bar
</code></pre>

<p>So what other options do we have with Boot?</p>

<p>Well, it turns out that you can run some Leiningen plugins directly from Boot, from the command line! Boot lets you specify dependencies on the command line, and it lets you &ldquo;call&rdquo; Clojure code from the command line too. Let&rsquo;s start a REPL with <code>lein-localrepo</code> as a dependency:</p>

<pre><code class="bash">boot -d leiningen -d lein-localrepo repl
</code></pre>

<p>We need Leiningen as well since plugins rely on it as a dependency. Now, in the REPL we can require the main namespace from the plugin, and get information about the entry point:</p>

<pre><code class="clojure">boot.user=&gt; (require '[leiningen.localrepo :as lr])
nil
boot.user=&gt; (doc lr/localrepo)
-------------------------
leiningen.localrepo/localrepo
([_] [_ command &amp; args])
  Work with local Maven repository

Usage: lein localrepo &lt;command&gt; (commands are listed below)
...
</code></pre>

<p>For any given plugin, <code>lein-foo</code>, the entry point is <code>leiningen.foo/foo</code>. Note that it is called with an unused argument and then the actual command line arguments. So we can ask for help on the <code>install</code> command:</p>

<pre><code class="clojure">boot.user=&gt; (lr/localrepo nil "help" "install")
Install artifact to local repository
  Arguments:
    [options] &lt;filename&gt; &lt;artifact-id&gt; &lt;version&gt;
  Options:
...
</code></pre>

<p>So we can call that function to perform the JAR install we want:</p>

<pre><code class="clojure">boot.user=&gt; (lr/localrepo nil "install" "foobar.jar" "foo/bar" "1.0.1")

&gt;
</code></pre>

<p>Oh, that&rsquo;s a bit disappointing &ndash; we exited the REPL and got our command prompt back. I guess that calls <code>(System/exit)</code> which is a bit unfriendly (but, perhaps, not unexpected given the use case for this plugin). But we can verify that the JAR file was installed:</p>

<pre><code class="bash">&gt; ls -R ~/.m2/repository/foo
bar

/Users/sean/.m2/repository/foo/bar:
1.0.1               maven-metadata-local.xml

/Users/sean/.m2/repository/foo/bar/1.0.1:
_remote.repositories    bar-1.0.1.jar       bar-1.0.1.pom
</code></pre>

<p>Now, remember that I said you can &ldquo;call&rdquo; code from the command line with Boot? Since we know the code we need to execute (the <code>require</code> and the call to <code>lr/localrepo</code>), we&rsquo;ll just supply those as command line arguments to the <code>call</code> task:</p>

<pre><code class="bash">boot -d leiningen -d lein-localrepo \
  call -e "(require '[leiningen.localrepo :as lr])" \
       -e '(lr/localrepo nil "install" "foobar.jar" "foo/bar" "1.0.1")'
</code></pre>

<p>Voila!</p>

<p><em>Updated November 22nd, 2017: I published a boot-localrepo task!</em></p>

<p>And if you don&rsquo;t want to type all that, you can now do:</p>

<pre><code class="bash">boot -d seancorfield/boot-localrepo install-artifact -f foobar.jar -P foo/bar -v 1.0.1
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Seancorfield/boot-new Has Moved to Boot/new]]></title>
    <link href="http://seancorfield.github.io/blog/2017/01/19/boot-new-moved/"/>
    <updated>2017-01-19T12:40:00-08:00</updated>
    <id>http://seancorfield.github.io/blog/2017/01/19/boot-new-moved</id>
    <content type="html"><![CDATA[<p>I&rsquo;m pleased to announce that the &ldquo;Boot new&rdquo; task formerly known as <code>seancorfield/boot-new</code> has moved to the Boot organization, as <a href="https://github.com/boot-clj/boot-new"><code>boot-clj/boot-new</code></a> and that the group/artifact ID is now <code>boot/new</code>.</p>

<p>You can use this to easily create a new Boot-based project:</p>

<pre><code>boot -d boot/new new -t app -n my-new-boot-app
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More Boot]]></title>
    <link href="http://seancorfield.github.io/blog/2016/06/17/more-boot/"/>
    <updated>2016-06-17T13:00:00-07:00</updated>
    <id>http://seancorfield.github.io/blog/2016/06/17/more-boot</id>
    <content type="html"><![CDATA[<p>Back in February I talked about <a href="http://corfield.org/blog/2016/02/02/boot-new/">boot-new</a> and talked about a &ldquo;future 1.0.0 release&rdquo;. We&rsquo;re not there yet, but <a href="https://github.com/seancorfield/boot-new#boot-generators">generators</a> got added in release 0.4.0 and, in the four minor releases since, the focus has been on refactoring to match the core <a href="http://boot-clj.com/">Boot</a> task structure and improving compatibility with Leiningen templates. At World Singles, we&rsquo;ve continued to extend our usage of Boot until we have only a couple of Ant tasks left and we expect those to be within Boot&rsquo;s reach soon. In this post, I want to cover some of the things we&rsquo;ve been doing with Boot recently.<!-- more --></p>

<p>I feel I should start with an apology for the &ldquo;radio silence&rdquo; since February &ndash; it&rsquo;s a combination of work being extremely engaging (and busy!) and some aspects of my personal life going somewhat to hell in a handbasket&hellip; But things have improved lately (thankfully!) and I hope to be more regular in my blogging (I certainly have a decent queue of article ideas in my head!).</p>

<p>At work, we depend on a lot of libraries, both Java and Clojure, and we&rsquo;ve tended to be a bit cavalier about conflicts in transitive dependencies. Sure, we check that the desired version of any given library ends up being selected (via <code>boot ... show -p</code>) but we&rsquo;ve tended to only add <code>:exclusions</code> where absolutely necessary to avoid specific cases of the wrong version being selected. That had served us fairly well until we started to experiment with <a href="https://clojure.org/about/spec"><code>clojure.spec</code></a>, introduced in the Clojure 1.9.0 Alpha builds. Along with the new namespace, a number of new predicates have been introduced, in <code>clojure.core</code>, across several of those Alpha builds with names that are common enough that they conflict with user-defined predicates in a number of libraries. Normally, that wouldn&rsquo;t matter much: you&rsquo;d get:</p>

<pre><code>WARNING: ... already refers to: #'clojure.core/... in namespace: ..., being replaced by: #'...
</code></pre>

<p>and your program would continue to function normally. At some point, the library maintainer would add the new symbol to the <code>:exclude</code> list in their <code>:refer-clojure</code> clause, you&rsquo;d update, and life would be good.</p>

<p>Something strange was happening for us, however. Instead of the warnings, the user-defined function would just silently vanish and the program would fail trying to call an unbound <code>Var</code>. Weird. I found a workaround for one case (where a <code>defn</code> was inside a <code>do</code> in a <code>.cljx</code> file) but I couldn&rsquo;t reproduce the problem as a test case (and nor could Kevin Downey, who was skeptical enough of my line of reasoning to spend time trying to help me find the real reason &ndash; thank you sir!). I ran into a couple more similar bugs. It became clear Kevin was right (I feel like saying &ldquo;of course!&rdquo; here) and I needed to approach the problem differently. A few conversations happening around the same time &ndash; including one between Rich Hickey and Micha Niskin in the <a href="https://clojurians.slack.com/messages/boot/">#boot channel on Slack</a> &ndash; led me to focus on version conflicts in our transitive dependencies&hellip; Fortunately, Boot provides an easy way to detect if there are any conflicts (even if they resolve &ldquo;correctly&rdquo;) and Micha shared some code that I turned into the following Boot task:</p>

<pre><code>(deftask check-conflicts
  "Verify there are no dependency conflicts."
  []
  (with-pass-thru fs
    (require '[boot.pedantic :as pedant])
    (let [dep-conflicts (resolve 'pedant/dep-conflicts)]
      (if-let [conflicts (not-empty (dep-conflicts pod/env))]
        (throw (ex-info (str "Unresolved dependency conflicts. "
                             "Use :exclusions to resolve them!")
                        conflicts))
        (println "\nVerified there are no dependency conflicts.")))))
</code></pre>

<p>I added this to our build pipeline and <code>Unresolved dependency conflicts.</code> became a very familiar sight until I&rsquo;d added enough <code>:exclusions</code> to our dependencies to finally see <code>Verified there are no dependency conflicts.</code>. Was I glad to see <em>that</em> at the end of the day!</p>

<p>One of the things I noticed was the huge number of libraries that pull in some old version of Clojure itself as a transitive dependency, so I ended up adding a global exclusion to our <code>build.boot</code> file:</p>

<pre><code>(set-env! :exclusions ['org.clojure/clojure])
</code></pre>

<p>A few discussions ensued on Slack about whether projects should declare <code>org.clojure/clojure</code> as a <code>"provided"</code> dependency but there was no consensus, unfortunately. FWIW, I&rsquo;m in the <code>"provided"</code> camp.</p>

<p>The other big shift we&rsquo;ve made at work is to adopt <a href="https://github.com/stuartsierra/component">Stuart Sierra&rsquo;s Component</a>. This might seem like a no brainer for many people but most of our Clojure code operates inside a large non-Clojure web application and started life as a small set of libraries. Component is a great fit for &ldquo;whole program&rdquo; code but it was <a href="https://github.com/stuartsierra/component#disadvantages-of-the-component-model">hard see how to fit it into our model</a>, especially since (unfortunately) we&rsquo;d gradually sprouted quite a bit of global state (go on, boo all you like!). Having talked to a number of people who introduced Component into &ldquo;legacy&rdquo; Clojure applications, I began to suspect that as long as the <code>start</code> and <code>stop</code> lifecycle methods managed that global state, it wouldn&rsquo;t be too painful to introduce it piecemeal into our code base.</p>

<p>We still have global state (go on, boo again!) but we&rsquo;re slowly moving away from it now and we have some processes that have &ldquo;inverted&rdquo; and are now entirely managed by Component. One of the side effects of moving to Component is that you need to <code>start</code> your system after you fire up your REPL. It&rsquo;s great being able to <code>start</code> and <code>stop</code> your application inside the REPL (we&rsquo;re not quite at the Nirvana of refreshing all our namespaces due to that pesky global state, but we&rsquo;re on track). On the other hand, after years of just firing up a REPL and going to work, it takes some getting used to and seeing the message that our database connections have not been started became fairly familiar for the first few days. OK, weeks.</p>

<p>One of the nice things about Boot is that if you want functions available in the REPL, in your <code>boot.user</code> namespace, you simply define them in your <code>build.boot</code> file. This allows us to follow <a href="http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded">Stuart&rsquo;s &ldquo;Clojure Reloaded&rdquo; workflow</a> with minimal effort. Having the machinery in <code>build.boot</code> to work with Component also lends itself to using that lifecycle in your tasks. That&rsquo;s good hygiene and encourages you to think about packaging functionality into Components which fail into a natural <code>start</code> / <code>stop</code> rhythm around the Boot task pipeline architecture which also has a natural start (followed by other tasks in the pipeline) and then a natural stop. In some ways, Boot and Component are &ldquo;made for each other&rdquo;:</p>

<pre><code>(deftask my-component-task
  "A Component-based task."
  [...]
  (let [my-task (make-task-component ...)]
    (fn [next-handler]
      (fn [fileset]
        (let [app (component/start my-task)]
          ... ; work is done with app here
          (let [fileset' (... fileset)
                fileset' (commit! fileset')
                result   (next-handler fileset')]
            ... ; side effects are performed with app here
            (component/stop app)
            result)))))))
</code></pre>

<p>The final piece of Boot-ness I want to mention in this post is how we&rsquo;ve shifted some of our general shell commands from Ant to Boot. Here&rsquo;s an example of how we invoke Grunt from Boot &ndash; a similar pattern is followed for other shell commands:</p>

<pre><code>(defn ws-root []
  (System/getProperty "user.dir"))

(deftask grunt
  "Run Grunt (in www)."
  []
  (require '[clojure.java.shell :as sh])
  (let [sh (resolve 'sh/sh)]
    (with-pass-thru fs
      (let [{:keys [exit out err]} (sh "grunt" :dir (str (ws-root) "/www"))]
        (println out)
        (when-not (zero? exit)
          (println err)
          (throw (ex-info "Grunt failed." {:exit exit})))))))
</code></pre>

<p>I&rsquo;ll probably post about Boot again when we&rsquo;ve finally laid Ant to rest, and talk about any interesting things we run into during that last sprint.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boot-new]]></title>
    <link href="http://seancorfield.github.io/blog/2016/02/02/boot-new/"/>
    <updated>2016-02-02T09:00:00-08:00</updated>
    <id>http://seancorfield.github.io/blog/2016/02/02/boot-new</id>
    <content type="html"><![CDATA[<p>In my previous three blog posts about <a href="http://boot-clj.com/">Boot</a> &ndash; <a href="http://corfield.org/blog/2016/01/29/rebooting-clojure/">Rebooting Clojure</a>, <a href="http://corfield.org/blog/2016/01/30/building-on-boot/">Building On Boot</a>, and <a href="http://corfield.org/blog/2016/01/31/testing-with-boot/">Testing With Boot</a> &ndash; I looked at why World Singles decided to switch from Leiningen to Boot, as well discussing one of the missing pieces for us (testing). Once I had <a href="https://github.com/seancorfield/boot-expectations">boot-expectations</a> written, I was casting around for other missing pieces in the ecosystem and one glaring one was the lack of something to generate new projects from templates.<!-- more --></p>

<p>Leiningen has long-supported the generation of new projects from templates and it&rsquo;s pretty slick. Want to get a new <a href="https://github.com/framework-one/fw1-clj">Framework One</a> application up and running?</p>

<pre><code>lein new fw1 myapp
cd myapp
PORT=8123 lein run
</code></pre>

<p>That&rsquo;s all it takes. No directories and files to create, no editing. Just tell Leiningen to create a new <code>fw1</code> project called <code>myapp</code>, drop into that newly created directory and run the generated skeleton application.</p>

<p>Behind the scenes, Leiningen looks for the most recent release of the <code>fw1/lein-template</code> artifact on Clojars (or Maven Central), downloads it and adds it to the classpath, then it <code>require</code>s the <code>leiningen.new.fw1</code> namespace (assumed to be in that artifact) and calls the <code>fw1</code> function within that namespace. That <code>fw1</code> template project in turn relies on the <code>leiningen.new.templates</code> namespace to provide a number of functions to <code>render</code> new project files from mustache-style templates, using the <a href="https://github.com/davidsantiago/stencil">Stencil library</a>. Leiningen templates may also depend on Leiningen&rsquo;s core code, as well as a few libraries that Leiningen always makes available (such as <a href="https://github.com/scgilardi/slingshot">Slingshot</a>).</p>

<p>I figured that in order to kickstart any <code>boot new</code> functionality, it would make sense for it to be able to render existing Leiningen templates, as well as Boot-specific templates. Since Boot deliberately includes source code directly from other projects so as to minimize the number of dependencies it brings in, and it already had several pieces of Leiningen copied into it, I reached out to <a href="https://github.com/hyPiRion">Leiningen&rsquo;s current maintainer, Jean Niklas L'orange</a> and asked permission to include parts of Leiningen&rsquo;s new/template support. He graciously said yes &ndash; thank you! &ndash; so I created a raw first cut of a <code>new</code> task for Boot, based directly on Leiningen&rsquo;s code, which in turn depended on Bultitude and <code>leiningen-core</code> (and a few other bits and pieces). Because Boot tasks are &ldquo;just Clojure&rdquo;, it was fairly straightforward to get to a <a href="https://github.com/seancorfield/boot-new/blob/v0.1.0/src/boot/new.clj">working 0.1.0 version</a> that had basic parity with <code>lein new</code>.</p>

<p>Since Boot already provided ways to manage dependencies and the classpath, my next goal was <a href="https://github.com/seancorfield/boot-new/blob/v0.2.0/src/boot/new.clj">an 0.2.0 version that didn&rsquo;t rely on Leiningen&rsquo;s core</a>. This version provided the same functionality (well, almost, it had compatibility bugs that took another version to iron out) but no longer needed to bring in <code>leiningen-core</code> as a dependency (unless you were generating a Leiningen template which might itself rely on that).</p>

<p>At this point, I was able to implement built-in templates to match Leiningen&rsquo;s <code>app</code>, <code>default</code> (library), <code>plugin</code>, and <code>template</code>, which would produce Boot-specific versions. The <a href="https://github.com/seancorfield/boot-new/tree/v0.2.1/src/boot/new">0.2.1 version included built-in templates</a> for <code>app</code>, <code>default</code>, <code>task</code> (the Boot equivalent of a plugin), and <code>template</code>.</p>

<p>Boot <code>new</code> had both <code>leiningen.new.templates</code> (adapted to run inside Boot) and <code>boot.new.templates</code> to support Boot templates. A Boot template is just like a Leiningen template, with a couple of important exceptions: the artifact name is of the form <code>foo/boot-template</code> (instead of <code>foo/lein-template</code>) and the template&rsquo;s main namespace is <code>boot.new.foo</code> (instead of <code>leiningen.new.foo</code>). In addition, a Boot template is expected to rely on Boot&rsquo;s internals or explicitly specify its own dependencies &ndash; instead of depending on Leiningen&rsquo;s core library. As a final piece of clean up for this &ldquo;initial&rdquo; version of Boot <code>new</code>, I removed the dependency on Bultitude (which actually hadn&rsquo;t been needed for a while) and deferred the addition of the <code>leiningen-core</code> and <code>slingshot</code> dependencies so they wouldn&rsquo;t be pulled in if you were generating a project from a Boot template.</p>

<p>At this point, I felt Boot <code>new</code> was ready to announce to the world! I could do:</p>

<pre><code>boot -d seancorfield/boot-new new -t fw1 -n myapp
</code></pre>

<p>and get a freshly generated Framework One app, even if that still used Leiningen to actually run the new app. I could do:</p>

<pre><code>boot -d seancorfield/boot-new new -t app -n myapp
</code></pre>

<p>to get a skeleton for an application that was &ldquo;powered by Boot&rdquo;: the generated <code>build.boot</code> file provides tasks for <code>build</code>ing the application uber-JAR and <code>run</code>ing the application itself.</p>

<p><a href="https://github.com/alandipert">Alan Dipert</a> and <a href="https://github.com/pesterhazy">Paulus Esterhazy</a> were the first two people to uncover compatibility bugs with existing Leiningen templates (for Hoplon and Chestnut, respectively). Thank you! And that brought me to Release 0.3.1 of <a href="https://github.com/seancorfield/boot-new">boot-new</a>.</p>

<p>The next thing on my roadmap is to add some sort of &ldquo;generator&rdquo; function (not unlike <a href="https://github.com/weavejester/lein-generate">James Reeves' lein-generate</a>) which will allow you to add new pieces to your existing projects, much Rails/Grails have built-in commands to let you add new models, controllers, and so on. That will be part of 0.4.0 and probably go through a couple of revisions. At some point, I&rsquo;ll feel comfortable declaring a 1.0.0 release and then we&rsquo;ll see about getting Boot <code>new</code> merged into the core of Boot itself.</p>

<p>Boot originally started life as a part of Hoplon and for a long time, you needed Leiningen in order to generate a new Hoplon project, even tho' Hoplon itself was powered-by-Boot. It&rsquo;s nice to see <a href="https://github.com/hoplon/hoplon/wiki/Get-Started#start-from-a-template">Hoplon&rsquo;s Getting Started</a> using <code>boot-new</code> as the recommended way to generate a new Hoplon project (it&rsquo;s still a Leiningen template!).</p>
]]></content>
  </entry>
  
</feed>
