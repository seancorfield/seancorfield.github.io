<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Boot | An Architect's View]]></title>
  <link href="http://seancorfield.github.io/blog/categories/boot/atom.xml" rel="self"/>
  <link href="http://seancorfield.github.io/"/>
  <updated>2018-03-30T10:07:30-07:00</updated>
  <id>http://seancorfield.github.io/</id>
  <author>
    <name><![CDATA[Sean Corfield]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Boot Localrepo?]]></title>
    <link href="http://seancorfield.github.io/blog/2017/11/17/boot-localrepo/"/>
    <updated>2017-11-17T04:50:00-08:00</updated>
    <id>http://seancorfield.github.io/blog/2017/11/17/boot-localrepo</id>
    <content type="html"><![CDATA[<p>Sometimes you just can&rsquo;t help having a &ldquo;random 3rd part JAR file&rdquo; in your project. The best practice is, of course, to upload it to your preferred Maven-compatible repository via whatever service or software you use for all your in-house shared artifacts. But sometimes you just want to play with that JAR file locally, or you haven&rsquo;t gotten around to running your own shared repository.</p>

<p>If you&rsquo;re using Leiningen, you&rsquo;ll probably reach for the excellent <a href="https://github.com/kumarshantanu/lein-localrepo"><code>lein-localrepo</code></a> which lets you &ldquo;install&rdquo; your random JAR file into your local Maven cache (in <code>~/.m2/repository</code>).</p>

<p>What do you do if you&rsquo;re using Boot instead?<!-- more --></p>

<p>Well, you <em>could</em> just keep <code>lein</code> installed and use it for this (with the <code>lein-localrepo</code> plugin dependency in your <code>~/.lein/profiles.clj</code>, for example):</p>

<pre><code class="bash">lein localrepo install foobar.jar foo/bar 1.0.1
</code></pre>

<p>Or you could run some command line Boot to make that happen:</p>

<pre><code class="bash">boot pom -p foo/bar -v 1.0.1 target \
    install -f foobar.jar -p target/META-INF/maven/foo/bar/pom.xml
# Don't forget to clean up!
rm -rf target
</code></pre>

<p>What the what? Yeah, that&rsquo;s really kind of ugly. Unfortunately, the <code>install</code> task seems to expect a physical <code>pom.xml</code> file when you specify a physical JAR file. That means we need to drop a <code>target</code> task into the pipeline into order for the generated <code>pom.xml</code> to be written to disk. It would be nice if it would look in the fileset first, because then at least this should work:</p>

<pre><code class="bash"># This does NOT work!
boot pom -p foo/bar -v 1.0.1 install -f foobar.jar -p foo/bar
</code></pre>

<p>So what other options do we have with Boot?</p>

<p>Well, it turns out that you can run some Leiningen plugins directly from Boot, from the command line! Boot lets you specify dependencies on the command line, and it lets you &ldquo;call&rdquo; Clojure code from the command line too. Let&rsquo;s start a REPL with <code>lein-localrepo</code> as a dependency:</p>

<pre><code class="bash">boot -d leiningen -d lein-localrepo repl
</code></pre>

<p>We need Leiningen as well since plugins rely on it as a dependency. Now, in the REPL we can require the main namespace from the plugin, and get information about the entry point:</p>

<pre><code class="clojure">boot.user=&gt; (require '[leiningen.localrepo :as lr])
nil
boot.user=&gt; (doc lr/localrepo)
-------------------------
leiningen.localrepo/localrepo
([_] [_ command &amp; args])
  Work with local Maven repository

Usage: lein localrepo &lt;command&gt; (commands are listed below)
...
</code></pre>

<p>For any given plugin, <code>lein-foo</code>, the entry point is <code>leiningen.foo/foo</code>. Note that it is called with an unused argument and then the actual command line arguments. So we can ask for help on the <code>install</code> command:</p>

<pre><code class="clojure">boot.user=&gt; (lr/localrepo nil "help" "install")
Install artifact to local repository
  Arguments:
    [options] &lt;filename&gt; &lt;artifact-id&gt; &lt;version&gt;
  Options:
...
</code></pre>

<p>So we can call that function to perform the JAR install we want:</p>

<pre><code class="clojure">boot.user=&gt; (lr/localrepo nil "install" "foobar.jar" "foo/bar" "1.0.1")

&gt;
</code></pre>

<p>Oh, that&rsquo;s a bit disappointing &ndash; we exited the REPL and got our command prompt back. I guess that calls <code>(System/exit)</code> which is a bit unfriendly (but, perhaps, not unexpected given the use case for this plugin). But we can verify that the JAR file was installed:</p>

<pre><code class="bash">&gt; ls -R ~/.m2/repository/foo
bar

/Users/sean/.m2/repository/foo/bar:
1.0.1               maven-metadata-local.xml

/Users/sean/.m2/repository/foo/bar/1.0.1:
_remote.repositories    bar-1.0.1.jar       bar-1.0.1.pom
</code></pre>

<p>Now, remember that I said you can &ldquo;call&rdquo; code from the command line with Boot? Since we know the code we need to execute (the <code>require</code> and the call to <code>lr/localrepo</code>), we&rsquo;ll just supply those as command line arguments to the <code>call</code> task:</p>

<pre><code class="bash">boot -d leiningen -d lein-localrepo \
  call -e "(require '[leiningen.localrepo :as lr])" \
       -e '(lr/localrepo nil "install" "foobar.jar" "foo/bar" "1.0.1")'
</code></pre>

<p>Voila!</p>

<p><em>Updated November 22nd, 2017: I published a boot-localrepo task!</em></p>

<p>And if you don&rsquo;t want to type all that, you can now do:</p>

<pre><code class="bash">boot -d seancorfield/boot-localrepo install-artifact -f foobar.jar -P foo/bar -v 1.0.1
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Seancorfield/boot-new Has Moved to Boot/new]]></title>
    <link href="http://seancorfield.github.io/blog/2017/01/19/boot-new-moved/"/>
    <updated>2017-01-19T12:40:00-08:00</updated>
    <id>http://seancorfield.github.io/blog/2017/01/19/boot-new-moved</id>
    <content type="html"><![CDATA[<p>I&rsquo;m pleased to announce that the &ldquo;Boot new&rdquo; task formerly known as <code>seancorfield/boot-new</code> has moved to the Boot organization, as <a href="https://github.com/boot-clj/boot-new"><code>boot-clj/boot-new</code></a> and that the group/artifact ID is now <code>boot/new</code>.</p>

<p>You can use this to easily create a new Boot-based project:</p>

<pre><code>boot -d boot/new new -t app -n my-new-boot-app
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More Boot]]></title>
    <link href="http://seancorfield.github.io/blog/2016/06/17/more-boot/"/>
    <updated>2016-06-17T13:00:00-07:00</updated>
    <id>http://seancorfield.github.io/blog/2016/06/17/more-boot</id>
    <content type="html"><![CDATA[<p>Back in February I talked about <a href="http://seancorfield.github.io/blog/2016/02/02/boot-new/">boot-new</a> and talked about a &ldquo;future 1.0.0 release&rdquo;. We&rsquo;re not there yet, but <a href="https://github.com/seancorfield/boot-new#boot-generators">generators</a> got added in release 0.4.0 and, in the four minor releases since, the focus has been on refactoring to match the core <a href="http://boot-clj.com/">Boot</a> task structure and improving compatibility with Leiningen templates. At World Singles, we&rsquo;ve continued to extend our usage of Boot until we have only a couple of Ant tasks left and we expect those to be within Boot&rsquo;s reach soon. In this post, I want to cover some of the things we&rsquo;ve been doing with Boot recently.<!-- more --></p>

<p>I feel I should start with an apology for the &ldquo;radio silence&rdquo; since February &ndash; it&rsquo;s a combination of work being extremely engaging (and busy!) and some aspects of my personal life going somewhat to hell in a handbasket&hellip; But things have improved lately (thankfully!) and I hope to be more regular in my blogging (I certainly have a decent queue of article ideas in my head!).</p>

<p>At work, we depend on a lot of libraries, both Java and Clojure, and we&rsquo;ve tended to be a bit cavalier about conflicts in transitive dependencies. Sure, we check that the desired version of any given library ends up being selected (via <code>boot ... show -p</code>) but we&rsquo;ve tended to only add <code>:exclusions</code> where absolutely necessary to avoid specific cases of the wrong version being selected. That had served us fairly well until we started to experiment with <a href="https://clojure.org/about/spec"><code>clojure.spec</code></a>, introduced in the Clojure 1.9.0 Alpha builds. Along with the new namespace, a number of new predicates have been introduced, in <code>clojure.core</code>, across several of those Alpha builds with names that are common enough that they conflict with user-defined predicates in a number of libraries. Normally, that wouldn&rsquo;t matter much: you&rsquo;d get:</p>

<pre><code>WARNING: ... already refers to: #'clojure.core/... in namespace: ..., being replaced by: #'...
</code></pre>

<p>and your program would continue to function normally. At some point, the library maintainer would add the new symbol to the <code>:exclude</code> list in their <code>:refer-clojure</code> clause, you&rsquo;d update, and life would be good.</p>

<p>Something strange was happening for us, however. Instead of the warnings, the user-defined function would just silently vanish and the program would fail trying to call an unbound <code>Var</code>. Weird. I found a workaround for one case (where a <code>defn</code> was inside a <code>do</code> in a <code>.cljx</code> file) but I couldn&rsquo;t reproduce the problem as a test case (and nor could Kevin Downey, who was skeptical enough of my line of reasoning to spend time trying to help me find the real reason &ndash; thank you sir!). I ran into a couple more similar bugs. It became clear Kevin was right (I feel like saying &ldquo;of course!&rdquo; here) and I needed to approach the problem differently. A few conversations happening around the same time &ndash; including one between Rich Hickey and Micha Niskin in the <a href="https://clojurians.slack.com/messages/boot/">#boot channel on Slack</a> &ndash; led me to focus on version conflicts in our transitive dependencies&hellip; Fortunately, Boot provides an easy way to detect if there are any conflicts (even if they resolve &ldquo;correctly&rdquo;) and Micha shared some code that I turned into the following Boot task:</p>

<pre><code>(deftask check-conflicts
  "Verify there are no dependency conflicts."
  []
  (with-pass-thru fs
    (require '[boot.pedantic :as pedant])
    (let [dep-conflicts (resolve 'pedant/dep-conflicts)]
      (if-let [conflicts (not-empty (dep-conflicts pod/env))]
        (throw (ex-info (str "Unresolved dependency conflicts. "
                             "Use :exclusions to resolve them!")
                        conflicts))
        (println "\nVerified there are no dependency conflicts.")))))
</code></pre>

<p>I added this to our build pipeline and <code>Unresolved dependency conflicts.</code> became a very familiar sight until I&rsquo;d added enough <code>:exclusions</code> to our dependencies to finally see <code>Verified there are no dependency conflicts.</code>. Was I glad to see <em>that</em> at the end of the day!</p>

<p>One of the things I noticed was the huge number of libraries that pull in some old version of Clojure itself as a transitive dependency, so I ended up adding a global exclusion to our <code>build.boot</code> file:</p>

<pre><code>(set-env! :exclusions ['org.clojure/clojure])
</code></pre>

<p>A few discussions ensued on Slack about whether projects should declare <code>org.clojure/clojure</code> as a <code>"provided"</code> dependency but there was no consensus, unfortunately. FWIW, I&rsquo;m in the <code>"provided"</code> camp.</p>

<p>The other big shift we&rsquo;ve made at work is to adopt <a href="https://github.com/stuartsierra/component">Stuart Sierra&rsquo;s Component</a>. This might seem like a no brainer for many people but most of our Clojure code operates inside a large non-Clojure web application and started life as a small set of libraries. Component is a great fit for &ldquo;whole program&rdquo; code but it was <a href="https://github.com/stuartsierra/component#disadvantages-of-the-component-model">hard see how to fit it into our model</a>, especially since (unfortunately) we&rsquo;d gradually sprouted quite a bit of global state (go on, boo all you like!). Having talked to a number of people who introduced Component into &ldquo;legacy&rdquo; Clojure applications, I began to suspect that as long as the <code>start</code> and <code>stop</code> lifecycle methods managed that global state, it wouldn&rsquo;t be too painful to introduce it piecemeal into our code base.</p>

<p>We still have global state (go on, boo again!) but we&rsquo;re slowly moving away from it now and we have some processes that have &ldquo;inverted&rdquo; and are now entirely managed by Component. One of the side effects of moving to Component is that you need to <code>start</code> your system after you fire up your REPL. It&rsquo;s great being able to <code>start</code> and <code>stop</code> your application inside the REPL (we&rsquo;re not quite at the Nirvana of refreshing all our namespaces due to that pesky global state, but we&rsquo;re on track). On the other hand, after years of just firing up a REPL and going to work, it takes some getting used to and seeing the message that our database connections have not been started became fairly familiar for the first few days. OK, weeks.</p>

<p>One of the nice things about Boot is that if you want functions available in the REPL, in your <code>boot.user</code> namespace, you simply define them in your <code>build.boot</code> file. This allows us to follow <a href="http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded">Stuart&rsquo;s &ldquo;Clojure Reloaded&rdquo; workflow</a> with minimal effort. Having the machinery in <code>build.boot</code> to work with Component also lends itself to using that lifecycle in your tasks. That&rsquo;s good hygiene and encourages you to think about packaging functionality into Components which fail into a natural <code>start</code> / <code>stop</code> rhythm around the Boot task pipeline architecture which also has a natural start (followed by other tasks in the pipeline) and then a natural stop. In some ways, Boot and Component are &ldquo;made for each other&rdquo;:</p>

<pre><code>(deftask my-component-task
  "A Component-based task."
  [...]
  (let [my-task (make-task-component ...)]
    (fn [next-handler]
      (fn [fileset]
        (let [app (component/start my-task)]
          ... ; work is done with app here
          (let [fileset' (... fileset)
                fileset' (commit! fileset')
                result   (next-handler fileset')]
            ... ; side effects are performed with app here
            (component/stop app)
            result)))))))
</code></pre>

<p>The final piece of Boot-ness I want to mention in this post is how we&rsquo;ve shifted some of our general shell commands from Ant to Boot. Here&rsquo;s an example of how we invoke Grunt from Boot &ndash; a similar pattern is followed for other shell commands:</p>

<pre><code>(defn ws-root []
  (System/getProperty "user.dir"))

(deftask grunt
  "Run Grunt (in www)."
  []
  (require '[clojure.java.shell :as sh])
  (let [sh (resolve 'sh/sh)]
    (with-pass-thru fs
      (let [{:keys [exit out err]} (sh "grunt" :dir (str (ws-root) "/www"))]
        (println out)
        (when-not (zero? exit)
          (println err)
          (throw (ex-info "Grunt failed." {:exit exit})))))))
</code></pre>

<p>I&rsquo;ll probably post about Boot again when we&rsquo;ve finally laid Ant to rest, and talk about any interesting things we run into during that last sprint.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boot-new]]></title>
    <link href="http://seancorfield.github.io/blog/2016/02/02/boot-new/"/>
    <updated>2016-02-02T09:00:00-08:00</updated>
    <id>http://seancorfield.github.io/blog/2016/02/02/boot-new</id>
    <content type="html"><![CDATA[<p>In my previous three blog posts about <a href="http://boot-clj.com/">Boot</a> &ndash; <a href="http://seancorfield.github.io/blog/2016/01/29/rebooting-clojure/">Rebooting Clojure</a>, <a href="http://seancorfield.github.io/blog/2016/01/30/building-on-boot/">Building On Boot</a>, and <a href="http://seancorfield.github.io/blog/2016/01/31/testing-with-boot/">Testing With Boot</a> &ndash; I looked at why World Singles decided to switch from Leiningen to Boot, as well discussing one of the missing pieces for us (testing). Once I had <a href="https://github.com/seancorfield/boot-expectations">boot-expectations</a> written, I was casting around for other missing pieces in the ecosystem and one glaring one was the lack of something to generate new projects from templates.<!-- more --></p>

<p>Leiningen has long-supported the generation of new projects from templates and it&rsquo;s pretty slick. Want to get a new <a href="https://github.com/framework-one/fw1-clj">Framework One</a> application up and running?</p>

<pre><code>lein new fw1 myapp
cd myapp
PORT=8123 lein run
</code></pre>

<p>That&rsquo;s all it takes. No directories and files to create, no editing. Just tell Leiningen to create a new <code>fw1</code> project called <code>myapp</code>, drop into that newly created directory and run the generated skeleton application.</p>

<p>Behind the scenes, Leiningen looks for the most recent release of the <code>fw1/lein-template</code> artifact on Clojars (or Maven Central), downloads it and adds it to the classpath, then it <code>require</code>s the <code>leiningen.new.fw1</code> namespace (assumed to be in that artifact) and calls the <code>fw1</code> function within that namespace. That <code>fw1</code> template project in turn relies on the <code>leiningen.new.templates</code> namespace to provide a number of functions to <code>render</code> new project files from mustache-style templates, using the <a href="https://github.com/davidsantiago/stencil">Stencil library</a>. Leiningen templates may also depend on Leiningen&rsquo;s core code, as well as a few libraries that Leiningen always makes available (such as <a href="https://github.com/scgilardi/slingshot">Slingshot</a>).</p>

<p>I figured that in order to kickstart any <code>boot new</code> functionality, it would make sense for it to be able to render existing Leiningen templates, as well as Boot-specific templates. Since Boot deliberately includes source code directly from other projects so as to minimize the number of dependencies it brings in, and it already had several pieces of Leiningen copied into it, I reached out to <a href="https://github.com/hyPiRion">Leiningen&rsquo;s current maintainer, Jean Niklas L'orange</a> and asked permission to include parts of Leiningen&rsquo;s new/template support. He graciously said yes &ndash; thank you! &ndash; so I created a raw first cut of a <code>new</code> task for Boot, based directly on Leiningen&rsquo;s code, which in turn depended on Bultitude and <code>leiningen-core</code> (and a few other bits and pieces). Because Boot tasks are &ldquo;just Clojure&rdquo;, it was fairly straightforward to get to a <a href="https://github.com/seancorfield/boot-new/blob/v0.1.0/src/boot/new.clj">working 0.1.0 version</a> that had basic parity with <code>lein new</code>.</p>

<p>Since Boot already provided ways to manage dependencies and the classpath, my next goal was <a href="https://github.com/seancorfield/boot-new/blob/v0.2.0/src/boot/new.clj">an 0.2.0 version that didn&rsquo;t rely on Leiningen&rsquo;s core</a>. This version provided the same functionality (well, almost, it had compatibility bugs that took another version to iron out) but no longer needed to bring in <code>leiningen-core</code> as a dependency (unless you were generating a Leiningen template which might itself rely on that).</p>

<p>At this point, I was able to implement built-in templates to match Leiningen&rsquo;s <code>app</code>, <code>default</code> (library), <code>plugin</code>, and <code>template</code>, which would produce Boot-specific versions. The <a href="https://github.com/seancorfield/boot-new/tree/v0.2.1/src/boot/new">0.2.1 version included built-in templates</a> for <code>app</code>, <code>default</code>, <code>task</code> (the Boot equivalent of a plugin), and <code>template</code>.</p>

<p>Boot <code>new</code> had both <code>leiningen.new.templates</code> (adapted to run inside Boot) and <code>boot.new.templates</code> to support Boot templates. A Boot template is just like a Leiningen template, with a couple of important exceptions: the artifact name is of the form <code>foo/boot-template</code> (instead of <code>foo/lein-template</code>) and the template&rsquo;s main namespace is <code>boot.new.foo</code> (instead of <code>leiningen.new.foo</code>). In addition, a Boot template is expected to rely on Boot&rsquo;s internals or explicitly specify its own dependencies &ndash; instead of depending on Leiningen&rsquo;s core library. As a final piece of clean up for this &ldquo;initial&rdquo; version of Boot <code>new</code>, I removed the dependency on Bultitude (which actually hadn&rsquo;t been needed for a while) and deferred the addition of the <code>leiningen-core</code> and <code>slingshot</code> dependencies so they wouldn&rsquo;t be pulled in if you were generating a project from a Boot template.</p>

<p>At this point, I felt Boot <code>new</code> was ready to announce to the world! I could do:</p>

<pre><code>boot -d seancorfield/boot-new new -t fw1 -n myapp
</code></pre>

<p>and get a freshly generated Framework One app, even if that still used Leiningen to actually run the new app. I could do:</p>

<pre><code>boot -d seancorfield/boot-new new -t app -n myapp
</code></pre>

<p>to get a skeleton for an application that was &ldquo;powered by Boot&rdquo;: the generated <code>build.boot</code> file provides tasks for <code>build</code>ing the application uber-JAR and <code>run</code>ing the application itself.</p>

<p><a href="https://github.com/alandipert">Alan Dipert</a> and <a href="https://github.com/pesterhazy">Paulus Esterhazy</a> were the first two people to uncover compatibility bugs with existing Leiningen templates (for Hoplon and Chestnut, respectively). Thank you! And that brought me to Release 0.3.1 of <a href="https://github.com/seancorfield/boot-new">boot-new</a>.</p>

<p>The next thing on my roadmap is to add some sort of &ldquo;generator&rdquo; function (not unlike <a href="https://github.com/weavejester/lein-generate">James Reeves' lein-generate</a>) which will allow you to add new pieces to your existing projects, much Rails/Grails have built-in commands to let you add new models, controllers, and so on. That will be part of 0.4.0 and probably go through a couple of revisions. At some point, I&rsquo;ll feel comfortable declaring a 1.0.0 release and then we&rsquo;ll see about getting Boot <code>new</code> merged into the core of Boot itself.</p>

<p>Boot originally started life as a part of Hoplon and for a long time, you needed Leiningen in order to generate a new Hoplon project, even tho' Hoplon itself was powered-by-Boot. It&rsquo;s nice to see <a href="https://github.com/hoplon/hoplon/wiki/Get-Started#start-from-a-template">Hoplon&rsquo;s Getting Started</a> using <code>boot-new</code> as the recommended way to generate a new Hoplon project (it&rsquo;s still a Leiningen template!).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing With Boot]]></title>
    <link href="http://seancorfield.github.io/blog/2016/01/31/testing-with-boot/"/>
    <updated>2016-01-31T07:30:00-08:00</updated>
    <id>http://seancorfield.github.io/blog/2016/01/31/testing-with-boot</id>
    <content type="html"><![CDATA[<p>In <a href="http://seancorfield.github.io/blog/2016/01/30/building-on-boot/">Building On Boot</a>, I gave some high level benefits we&rsquo;d found with Boot, compared to Leiningen, and how it had helped up streamline our build process. That article closed with a note about Boot not having the equivalent of common Leiningen plugins, and that&rsquo;s what I&rsquo;m going to cover here, since that was the first real obstacle we encountered.<!-- more --></p>

<p>We use <a href="http://jayfields.com/expectations/">Jay Fields' Expectations</a> library very heavily for most of our testing needs. We use <code>clojure.test</code> only for our <a href="https://github.com/semperos/clj-webdriver">Clojure-powered WebDriver testing</a>. Leiningen has a <code>test</code> task built-in and we had been using <a href="https://github.com/gar3thjon3s/lein-expectations">lein-expectations</a> for years. It was quite a shock to find out that Boot has no testing tasks built-in!</p>

<p>Boot&rsquo;s standard for driving <code>clojure.test</code> is <a href="https://github.com/adzerk-oss/boot-test">Adzerk&rsquo;s boot-test</a>. Using it in your <code>build.boot</code> file is as simple as adding a dependency on <code>[adzerk/boot-test "1.0.7" :scope "test"]</code> and then referring in the <code>test</code> task:</p>

<pre><code>(merge-env! :dependencies '[[adzerk/boot-test "1.0.7" :scope "test"]])
(require '[adzerk.boot-test :refer [test]])
</code></pre>

<p>Now you can do <code>boot test</code> and run any tests in any of the namespaces in your source paths. Unfortunately there was no equivalent for Expectations so this was my first chance to roll up my sleeves and write a Boot task as a standalone project. The result is <a href="https://github.com/seancorfield/boot-expectations">boot-expectations</a>. Add a dependency on <code>[seancorfield/boot-expectations "1.0.5" :scope "test"]</code> and then refer in the <code>expectations</code> task:</p>

<pre><code>(merge-env! :dependencies '[[seancorfield/boot-expectations "1.0.5" :scope "test"]])
(require '[seancorfield.boot-expectations :refer [expectation]])
</code></pre>

<p>Now you can do <code>boot expectations</code> to run any Expectations tests in any of the namespaces in your source paths. Do <code>boot expectations -h</code> to see all the options the task provides.</p>

<p>I relied very heavily on two sources for this project: Adzerk&rsquo;s <code>boot-test</code> for the shape of the code and the <a href="https://clojurians.slack.com/messages/boot/">#boot channel</a> on the <a href="http://clojurians.net">Clojurians Slack</a> where Boot&rsquo;s maintainers hang out and are <em>extremely attentive and helpful</em>! In particular, <a href="https://github.com/micha">Micha Niskin</a> was invaluable, answering all my newbie questions and making suggestions. Boot&rsquo;s &ldquo;pods&rdquo; made it easy to specify the version of Clojure to use when running the tests, without affecting the version of Clojure used for anything else in the build process (we have always run our tests against the released version we are actually using as well as the latest snapshot of Clojure&rsquo;s master branch so we don&rsquo;t get surprised by any changes being introduced in the next release). The &ldquo;pod&rdquo; machinery also made it straightforward to have namespaces required into the testing environment, and shutdown functions run after the tests, again without affecting the main build process. And all in a single JVM process that runs for the duration of the build.</p>

<p>As you can see on Boot&rsquo;s wiki, the ecosystem of <a href="https://github.com/boot-clj/boot/wiki/Community-Tasks">community-maintained Boot tasks</a> is already pretty strong and growing all the time.</p>

<p>Back to our build process and one of the key drivers for looking at Boot in the first place: we&rsquo;d hit around 30K lines of production Clojure and 10K lines of test Clojure code, and we had it in three fair-sized projects with Leiningen. We wanted to reorganize the code and break it up into many more projects in order to have more flexibility in how we deploy code as well as being able to develop and test smaller chunks of code in isolation. We also wanted to be able to &ldquo;pin&rdquo; versions of certain libraries that we depended on across multiple &ldquo;projects&rdquo;. With Leiningen we&rsquo;d had multiple <code>project.clj</code> files and were already finding that we were pushing the declarative envelope of Leiningen by having to escape executable code into our <code>defproject</code> form. It felt like we were starting to fight the build tool. The declarative nature of <code>project.clj</code> didn&rsquo;t feel natural for the more fluid approach we wanted to take with our code base. What appealed about Boot was the possibility of a single <code>build.boot</code> file that could mix'n'match source and test code from various locations to allow the more modular develop / test approach we were aiming for, while still being able to easily build, push, and depend on artifacts from sub-projects. With Leiningen, we had a project for our WebDriver tests and it depended on a JAR built from the main source code project, so we would build and install (locally) a JAR of our main project, as part of the build. With Boot and a single <code>build.boot</code> file it was much easier to set up execution and test &ldquo;contexts&rdquo; as tasks that built the list of dependencies and source paths needed for each testing task. We now have all our Clojure code as &ldquo;sub-projects&rdquo; but can treat it as a single project too where that is more convenient.</p>

<p>In the next post, I&rsquo;ll take a diversion from World Singles' use of Boot and look at the <a href="https://github.com/seancorfield/boot-new">Boot new</a> project I&rsquo;ve been working on for a month &ndash; another &ldquo;missing piece of the ecosystem&rdquo; that I wanted to help fill!</p>
]]></content>
  </entry>
  
</feed>
