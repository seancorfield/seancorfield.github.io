<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Jdbc | An Architect's View]]></title>
  <link href="http://corfield.org/blog/categories/jdbc/atom.xml" rel="self"/>
  <link href="http://corfield.org/"/>
  <updated>2019-07-04T10:46:54-07:00</updated>
  <id>http://corfield.org/</id>
  <author>
    <name><![CDATA[Sean Corfield]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Next.JDBC to 1.0.0 and Beyond!]]></title>
    <link href="http://corfield.org/blog/2019/07/04/next-jdbc/"/>
    <updated>2019-07-04T03:00:00-07:00</updated>
    <id>http://corfield.org/blog/2019/07/04/next-jdbc</id>
    <content type="html"><![CDATA[<h1>next.jdbc 1.0.0 and 1.0.1</h1>

<p>First off, <a href="https://github.com/seancorfield/next-jdbc/releases/tag/v1.0.0">seancorfield/next.jdbc 1.0.0</a> was released on June 13th, 2019 (and I <a href="https://clojureverse.org/t/next-jdbc-1-0-0-the-gold-release/4379">announced it on ClojureVerse</a> but did not blog about it), and yesterday I released <a href="https://github.com/seancorfield/next-jdbc/releases/tag/v1.0.1">seancorfield/next.jdbc 1.0.1</a> which is mostly documentation improvements.</p>

<p>Someone recently commented that this blog had the <a href="https://corfield.org/blog/2019/06/04/next-jdbc/">Release Candidate announcement</a> on June 4th and was surprised I didn&rsquo;t &ldquo;make a big deal&rdquo; about the &ldquo;gold&rdquo; release. The 1.0.0 release is a <strong>big deal</strong> and this blog post is about that &ndash; what it&rsquo;s taken to get here and what&rsquo;s to come.<!-- more --></p>

<h2>clojure.contrib.sql</h2>

<p>I learned Clojure back in 2010 and started using it at work in early 2011. For us to use it in production, we needed JDBC support but <code>clojure.contrib.sql</code> was not being actively maintained at that point and the Clojure 1.3 release was in its Alpha phase. Part of the 1.3 release cycle involved <a href="https://clojure.org/community/contrib_history">breaking up the &ldquo;Monolithic Contrib&rdquo; from the 1.2 release and finding new maintainers</a> in order for its parts to move forward. That&rsquo;s how I became the maintainer of <a href="https://github.com/clojure/java.jdbc"><code>clojure.java.jdbc</code></a> &ndash; <code>clojure.contrib.sql</code>&rsquo;s new name and home. <code>clojure.java.jdbc</code> started life with an 0.0.1 release.</p>

<h2>clojure.java.jdbc</h2>

<p>The 0.0.x releases mostly focused on compatibility with more databases and ease of use enhancements.</p>

<p>0.1.0 rewrote the result set handling to use regular Clojure hash maps instead of the deprecated <code>struct-map</code> machinery, hence the bump in version numbers. The 0.1.x releases continued to expand database support, expand the API, and fix bugs.</p>

<p>0.2.0 merged the internal namespace into the main <code>clojure.java.jdbc</code> namespace and adjusted the visibility (and naming) of several symbols, hence the bump in version numbers. The 0.2.x releases continued the path of improving database support, improving usability, fixing bugs, and some performance improvements.</p>

<p>0.3.0 was a fairly massive overhaul of the API &ndash; these were definitely breaking changes, as most of the existing API was deprecated (based on the dynamic <code>*db*</code> variable), and a new API introduced (which accepted the db spec everywhere as an argument, including the first versions of <code>insert!</code>, <code>query</code>, <code>update!</code>, <code>delete!</code>, and <code>execute!</code>). 0.3.0 also introduced <code>IResultSetReadColumn</code> and <code>ISQLValue</code> as extension points. Prerelease builds of 0.3.0 introduced a mini-DSL for building SQL but that was removed before the gold release &ndash; the DDL support stayed, however. The 0.3.x releases mostly focused on bug releases after the big upheaval in the API, and adding support for more and more options. The modern &ldquo;db-spec&rdquo; with <code>:dbtype</code> and <code>:dbname</code> was introduced during this time.</p>

<p>0.4.0 dropped support for Clojure 1.2 and the 0.4.x releases fixed bugs, broadened database support, and added yet more options.</p>

<p>0.5.0 dropped support for Clojure 1.3 and 0.5.5 started the shift from &ldquo;named&rdquo; arguments (unrolled keyword arguments) to passing options in a single hash map, which makes it much easier to compose function calls. The 0.5.x releases continued deprecation of the unrolled keyword arguments.</p>

<p>0.6.0 removed all deprecated APIs and signatures. This was a pretty volatile time to be using <code>clojure.java.jdbc</code>. There was a 0.6.1 release but the upcoming 0.6.2 release became a series of 0.7.0 prerelease builds as I replumbed the functions to correctly pass options through the entire chain, and dropped support for Clojure 1.4, 1.5, and finally 1.6&hellip; This also saw the introduction of <code>reducible-query</code> (which laid the groundwork for <code>next.jdbc</code>).</p>

<p>By the time 0.7.0 was released, I was beginning to think more seriously about a 1.0.0 release. The 0.7.x releases continued to expand database support, to add more and more options, and also started to look at performance improvements.</p>

<h2>Contrib Evolving</h2>

<p>I&rsquo;d solicited feedback from the Clojure/core folks about what it would mean for a 1.0.0 release at various points, starting as far back as the 0.3x series of releases, and I&rsquo;d been folding that feedback into the various changes over time. Also, over time, it became clear that Clojure/core were less worried about placing restrictions on how maintainers ran their projects. Some Contrib libraries had their 1.0.0 releases and continued on, some were still in the 0.0.x phase, others run the gamut from 0.1.x to 0.10.x.</p>

<p>It&rsquo;s good to read <a href="https://clojure.org/news/2012/02/17/clojure-governance">Stuart Sierra&rsquo;s post from 2012</a> about how Clojure (and Contrib&rsquo;s) governance evolved over the years, as well as the <a href="https://clojure.org/community/contrib_libs">current state of Contrib libraries</a>. In addition to the recent clarifications about Contrib&rsquo;s purpose and governance, we&rsquo;ve seen <code>clojure.tools.nrepl</code> fork back out of Contrib as <a href="https://github.com/nrepl/nrepl">nrepl/nrepl</a> and a lot of adjustment in tooling to adapt to the new group, artifact, and namespace names.</p>

<p>It was in this environment that I continued to think about what a 1.0.0 release of <code>clojure.java.jdbc</code> should be. At Clojure/conj (2018), I was excited about <a href="https://github.com/cognitect-labs/REBL-distro">REBL</a> and <code>datafy</code>/<code>nav</code>, and I introduced <a href="https://corfield.org/blog/2018/12/03/datafy-nav/">experimental support for all that in <code>clojure.java.jdbc</code></a>. I was also thinking about <code>clojure.spec</code> and the shift to qualified keywords and the increased use of transducers and the focus on simplicity and consistency&hellip;</p>

<h2>The Birth of next.jdbc</h2>

<p>It was around that point that I realized that I wouldn&rsquo;t really be comfortable declaring a 1.0.0 release on <code>clojure.java.jdbc</code>: there was no natural &ldquo;end state&rdquo; and it had become large and complex (and slow in places) &ndash; and I couldn&rsquo;t realistically change that without making a whole &lsquo;nother round of breaking changes. But this time I heeded <a href="https://www.youtube.com/watch?v=oyLBGkS5ICk">Rich&rsquo;s advice about accretion and fixation</a> and started to design the &ldquo;next&rdquo; version of <code>clojure.java.jdbc</code> not as a series of (breaking) changes to what already existed but as a completely new set of functions built on a completely new set of implementations, based on what I&rsquo;d learned from nearly eight years of maintaining <code>clojure.java.jdbc</code>.</p>

<p>I talk about my <a href="https://github.com/seancorfield/next-jdbc#motivation">motivation for this new JDBC wrapper</a> in the project README but I&rsquo;ll provide a bullet point recap here as well:</p>

<ul>
<li>Improve performance,</li>
<li>Provide a &ldquo;modern&rdquo; Clojure approach/API,</li>
<li>Provide a simpler library/API.</li>
</ul>


<p>I spent a month or so sketching out what this new version of the library would look like and how it would behave using a local git repository (stored on OneDrive). I first mentioned that I was working on it in early January (in <a href="https://clojureverse.org/t/what-http-server-library-to-use/3423/29?u=seancorfield">a thread about HTTP servers on ClojureVerse</a>, of all places) and moved it into a private GitHub repository, once I had usable code. Over the next three months, I continued to develop it until the first public release on April 21st: 1.0.0-alpha8. Over the next month, I gathered feedback from anyone who was willing to use it, making a few small adjustments in the API, until the first stable release on May 25th: 1.0.0-beta1.</p>

<p>One of the key decisions I had to make was whether this would become new namespaces inside <code>clojure.java.jdbc</code> in Contrib or live standalone somewhere &ndash; because I viewed it very much as the &ldquo;next version&rdquo; of that Contrib library. I was surprised that no one seemed to care if a library was published under someone&rsquo;s name as a group ID, nor even if the namespaces themselves contained someone&rsquo;s name. I&rsquo;d viewed Contrib&rsquo;s well-maintained Continuous Integration system and automated documentation generator as pros, along with my perception that Contrib libraries were easy to find and had some stamp of &ldquo;authority&rdquo; by virtue of being in the <code>clojure</code> GitHub organization &ndash; but I seemed to be very much in the minority in that perception. Once I had CI set up for <a href="https://circleci.com/gh/seancorfield/next-jdbc"><code>next.jdbc</code> on CircleCI</a> and auto-generated <a href="https://cljdoc.org/d/seancorfield/next.jdbc">documentation for <code>next.jdbc</code> on cljdoc.org</a>, I decided that <code>seancorfield/next.jdbc</code> was going to live on, outside Contrib.</p>

<h2>Beta 1 and Stability</h2>

<p>I mentioned above that I considered Beta 1 to be the first stable release. Having gone through so many breaking changes with <code>clojure.java.jdbc</code> and having listened to Rich (and others in the Clojure community) talk about the need for backward compatibility and the futility of semantic versioning, it was important to me that I could draw a line in the sand at some point and say &ldquo;no more breaking changes&rdquo;. I decided that the move from Alpha to Beta should be that line for <code>next.jdbc</code> and the last breaking change was renaming <code>reducible!</code> to <code>plan</code> as part of the beta release &ndash; indeed, that was the gating factor for exiting the alpha phase of development.</p>

<p>My goal is to never break backward compatibility across future versions of <code>next.jdbc</code> &ndash; only adding new functionality (and fixing things that are clearly broken). I expect future versions to appear slowly and contain very few additional features, perhaps focusing mostly on improving the documentation in response to questions from users of the library.</p>

<h2>Wrapping Up</h2>

<p>I couldn&rsquo;t have made <code>next.jdbc</code> without a lot of lessons learned from eight years of maintaining <code>clojure.java.jdbc</code> and all the feedback from the community &ndash; both on <code>clojure.java.jdbc</code> itself and during the alpha phase of <code>next.jdbc</code>&rsquo;s development. It&rsquo;s faster, more modern, and simpler than <code>clojure.java.jdbc</code>. It embraces the host platform by being based on JDBC types directly, but offers value beyond being &ldquo;just&rdquo; a wrapper for those types and their methods. It looks to the future by yielding qualified keywords by default, supporting <code>datafy</code>, <code>nav</code>, and focusing on reducing/transducing as a core part of the main API (via <code>plan</code>).</p>

<p>I consider <code>next.jdbc</code> to be the 1.0.0 release that <code>clojure.java.jdbc</code> was never going to achieve.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Next.JDBC Release Candidate 1]]></title>
    <link href="http://corfield.org/blog/2019/06/04/next-jdbc/"/>
    <updated>2019-06-04T11:30:00-07:00</updated>
    <id>http://corfield.org/blog/2019/06/04/next-jdbc</id>
    <content type="html"><![CDATA[<h1>seancorfield/next.jdbc 1.0.0-rc1</h1>

<p><code>next.jdbc</code> &ndash; the &ldquo;next generation&rdquo; of <code>clojure.java.jdbc</code> &ndash; is a modern Clojure wrapper for JDBC. The first Release Candidate is now available to test &ndash; containing only accretive and fixative changes from Beta 1. The API should be considered stable enough for production usage.</p>

<p><a href="https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-rc1/doc/readme">https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-rc1/doc/readme</a></p>

<p>The focus of this release is providing more flexibility in result set builders, so that it is easier to implement your own naming strategies, via new builders that accept <code>:label-fn</code> and <code>:qualifier-fn</code> options. These mirror the <code>:column-fn</code> and <code>:table-fn</code> options used in <code>next.jdbc.sql</code> &ndash; which are updated versions of <code>clojure.java.jdbc</code>&rsquo;s <code>:entities</code> option. These new builder options are updated versions of <code>clojure.java.jdbc</code>&rsquo;s <code>:identifiers</code> option.</p>

<h2>Changes since Beta 1</h2>

<ul>
<li>Fix #24 by adding return type hints to <code>next.jdbc</code> functions.</li>
<li>Fix #22 by adding <code>next.jdbc.optional</code> with six map builders that omit <code>NULL</code> columns from the row hash maps.</li>
<li>Documentation improvements (#27, #28, and #29), including changing &ldquo;connectable&rdquo; to &ldquo;transactable&rdquo; for the <code>transact</code> function and the <code>with-transaction</code> macro (for consistency with the name of the underlying protocol).</li>
<li>Fix #30 by adding <code>modified</code> variants of column name functions and builders. The <code>lower</code> variants have been rewritten in terms of these new <code>modified</code> variants. This adds <code>:label-fn</code> and <code>:qualifier-fn</code> options that mirror <code>:column-fn</code> and <code>:table-fn</code> for row builders.</li>
</ul>


<p>Please take it for a test drive and let me know if you run into any problems via <a href="https://github.com/seancorfield/next-jdbc/issues">GitHub issues</a> or in the <a href="https://clojurians.slack.com/messages/C1Q164V29/details/"><code>#sql</code> channel on the Clojurians Slack</a> or the <a href="https://clojurians.zulipchat.com/#narrow/stream/152063-sql"><code>#sql</code> stream on the Clojurians Zulip</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Next.JDBC Beta 1]]></title>
    <link href="http://corfield.org/blog/2019/05/25/next-jdbc/"/>
    <updated>2019-05-25T08:00:00-07:00</updated>
    <id>http://corfield.org/blog/2019/05/25/next-jdbc</id>
    <content type="html"><![CDATA[<h1>seancorfield/next.jdbc 1.0.0-beta1</h1>

<p><code>next.jdbc</code> &ndash; the &ldquo;next generation&rdquo; of <code>clojure.java.jdbc</code> &ndash; is a modern Clojure wrapper for JDBC. Beta 1 is now available to test &ndash; only accretive and fixative changes will be made from this point on, so the API should be considered stable enough for production usage.</p>

<p><a href="https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-beta1/doc/readme">https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-beta1/doc/readme</a></p>

<p>The group and artifact ID will remain <code>seancorfield/next.jdbc</code>, the namespace structure will remain <code>next.jdbc.*</code>. With auto-generated documentation hosted on cljdoc.org and Continuous Integration testing hosted on circleci.com, I have decided to continue work on <code>next.jdbc</code> outside Clojure Contrib, rather than merge it into <code>clojure.java.jdbc</code> as new namespaces there. I have updated the <a href="https://github.com/seancorfield/next-jdbc/blob/master/CONTRIBUTING.md">Contributing page on GitHub</a> to reflect that Pull Requests can now be submitted.</p>

<h2>Changes since Alpha 13</h2>

<ul>
<li>Set up CircleCI testing (just local DBs for now).</li>
<li>Address <a href="https://github.com/seancorfield/next-jdbc/issues/21">#21</a> by adding <code>next.jdbc.specs</code> and documenting basic usage.</li>
<li>Fix <a href="https://github.com/seancorfield/next-jdbc/issues/19">#19</a> by caching loaded database driver classes.</li>
<li>Address <a href="https://github.com/seancorfield/next-jdbc/issues/16">#16</a> by renaming <code>reducible!</code> to <code>plan</code> (this is a <strong>BREAKING CHANGE!</strong> from Alpha 13 &ndash; the naming of this function was the blocker for moving from Alpha to Beta).</li>
<li>Address <a href="https://github.com/seancorfield/next-jdbc/issues/3">#3</a> by deciding to maintain this library outside Clojure Contrib.</li>
</ul>


<p>Please take it for a test drive and let me know if you run into any problems via <a href="https://github.com/seancorfield/next-jdbc/issues">GitHub issues</a> or in the <a href="https://clojurians.slack.com/messages/C1Q164V29/details/"><code>#sql</code> channel on the Clojurians Slack</a> or the <a href="https://clojurians.zulipchat.com/#narrow/stream/152063-sql"><code>#sql</code> stream on the Clojurians Zulip</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Next.JDBC]]></title>
    <link href="http://corfield.org/blog/2019/04/21/next-jdbc/"/>
    <updated>2019-04-21T16:00:00-07:00</updated>
    <id>http://corfield.org/blog/2019/04/21/next-jdbc</id>
    <content type="html"><![CDATA[<h1>seancorfield/next.jdbc 1.0.0-alpha8</h1>

<p>I&rsquo;ve talked about this in a few groups &ndash; it&rsquo;s been a long time coming. This is the &ldquo;next generation&rdquo; of <code>clojure.java.jdbc</code> &ndash; a modern wrapper for JDBC, that focuses on <code>reduce</code>/transducers, qualified-keywords, and <code>datafy</code>/<code>nav</code> support (so, yes, it requires Clojure 1.10).</p>

<p><a href="https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-alpha8/doc/readme">https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-alpha8/doc/readme</a></p>

<p><em>The next generation of <code>clojure.java.jdbc</code>: a new low-level Clojure wrapper for JDBC-based access to databases.</em>  It&rsquo;s intended to be both faster and simpler than <code>clojure.java.jdbc</code> and it&rsquo;s where I intend to focus my future energy, although I have not yet decided whether it will ultimately be a new set of namespaces in the Contrib lib or a separate, standalone OSS library!</p>

<p>At this point, I&rsquo;m looking for feedback on the API and the approach (as well as bugs, performance issues, etc). Please take it for a spin and let me know what you think via <a href="https://github.com/seancorfield/next-jdbc/issues">GitHub issues</a> or in the <a href="https://clojurians.slack.com/messages/C1Q164V29/details/"><code>#sql</code> channel on the Clojurians Slack</a> or the <a href="https://clojurians.zulipchat.com/#narrow/stream/152063-sql"><code>#sql</code> stream on the Clojurians Zulip</a>.</p>

<p><em>The group/artifact ID will change at some point:</em> and the actual namespaces will too, but I will try to make that as painless as possible when I take this out of the alpha phase.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL NULL, S/nilable, and Optionality]]></title>
    <link href="http://corfield.org/blog/2018/12/06/null-nilable-optionality/"/>
    <updated>2018-12-06T03:30:00-08:00</updated>
    <id>http://corfield.org/blog/2018/12/06/null-nilable-optionality</id>
    <content type="html"><![CDATA[<p>Rich Hickey gave a very thought-provoking talk at Clojure/conj 2018
called <a href="https://www.youtube.com/watch?v=YR5WdGrpoug&amp;list=PLZdCLR02grLpMkEBXT22FTaJYxB92i3V3&amp;index=2">Maybe Not</a>, where he mused
on optionality and how we represent the absence of a value.<!-- more --></p>

<p>His talk covered many things, including how <code>clojure.spec/keys</code> currently
complects both structure and optionality (and his thoughts on fixing that
in a future version of <code>clojure.spec</code>), but his mention of <code>s/nilable</code> was what
triggered an &ldquo;ah-ha!&rdquo; moment for me.</p>

<p>At <a href="https://worldsinglesnetworks.com">World Singles Networks</a>, we deal with a lot
of data in SQL (specifically in Percona&rsquo;s fork of MySQL) and, in SQL, you represent
the absence of a value with <code>NULL</code> in a column. Columns that represent optional
data must be declared as nullable and when you read data from them with
<a href="https://github.com/clojure/java.jdbc">clojure.java.jdbc</a> you get hash map
entries in the rows that have <code>nil</code> values. If you&rsquo;re using <code>clojure.spec</code> to
describe your tables, rows, and columns, then you are going to have lots of
<code>s/nilable</code> specs &ndash; and now your &ldquo;optionality&rdquo; has been reified into <code>nil</code>
values, cast in the stone of your specs&hellip; which is clearly not an ideal situation!</p>

<p>This made me realize that <code>java.jdbc</code> probably should just omit keys whose
values represent SQL <code>NULL</code>. They are, after all, <em>optional</em> values rather than
truly <em>nilable</em> values.</p>

<p>That would be a potentially breaking change in behavior for <code>java.jdbc</code> users.
Sure, in most cases, if you have a hash map representing a row in a database
table, you&rsquo;re not really going to care whether <code>(:col row)</code> gives you <code>nil</code>
because <code>:col</code> maps to <code>nil</code> or because <code>row</code> doesn&rsquo;t contain <code>:col</code>. There are
use cases where it matters: <code>contains?</code>, row/column specs, tabular printing.</p>

<p>Along with changing the behavior of <code>NULL</code> columns and
<a href="http://corfield.org/blog/2018/12/03/datafy-nav/">supporting <code>datafy</code> and <code>nav</code></a>,
I have a lot of other changes that I&rsquo;d like to apply to <code>java.jdbc</code>, such as
automatically qualifying column keys with the table from which they came,
improving overall performance (by no longer converting <code>ResultSet</code> objects to
sequences of hash maps), dramatically simplifying and streamlining the options
that are available (since many of them are very rarely used), and focusing on a
reducible-first API. All of which would be breaking changes.</p>

<p>I&rsquo;ve learned a lot &ndash; about Clojure, idioms, and databases &ndash; over the seven
years that I&rsquo;ve been maintaining <code>org.clojure/java.jdbc</code>, and it is time for a
new namespace or perhaps even a completely new project, that offers a better
way to deal with SQL databases from Clojure! I&rsquo;ll be writing a series of blog
posts about the differences I envisage between the current de facto standard
JDBC wrapper and where I&rsquo;d like to go with this, so that I can get community
feedback on what should stay, what should change, and what should go. Stay tuned!</p>
]]></content>
  </entry>
  
</feed>
