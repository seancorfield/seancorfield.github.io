<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Clojure | An Architect's View]]></title>
  <link href="http://seancorfield.github.io/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://seancorfield.github.io/"/>
  <updated>2016-06-17T19:16:41-07:00</updated>
  <id>http://seancorfield.github.io/</id>
  <author>
    <name><![CDATA[Sean Corfield]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Boot-new]]></title>
    <link href="http://seancorfield.github.io/blog/2016/02/02/boot-new/"/>
    <updated>2016-02-02T09:00:00-08:00</updated>
    <id>http://seancorfield.github.io/blog/2016/02/02/boot-new</id>
    <content type="html"><![CDATA[<p>In my previous three blog posts about <a href="http://boot-clj.com/">Boot</a> &ndash; <a href="http://seancorfield.github.io/blog/2016/01/29/rebooting-clojure/">Rebooting Clojure</a>, <a href="http://seancorfield.github.io/blog/2016/01/30/building-on-boot/">Building On Boot</a>, and <a href="http://seancorfield.github.io/blog/2016/01/31/testing-with-boot/">Testing With Boot</a> &ndash; I looked at why World Singles decided to switch from Leiningen to Boot, as well discussing one of the missing pieces for us (testing). Once I had <a href="https://github.com/seancorfield/boot-expectations">boot-expectations</a> written, I was casting around for other missing pieces in the ecosystem and one glaring one was the lack of something to generate new projects from templates.<!-- more --></p>

<p>Leiningen has long-supported the generation of new projects from templates and it&rsquo;s pretty slick. Want to get a new <a href="https://github.com/framework/fw1-clj">Framework One</a> application up and running?</p>

<pre><code>lein new fw1 myapp
cd myapp
PORT=8123 lein run
</code></pre>

<p>That&rsquo;s all it takes. No directories and files to create, no editing. Just tell Leiningen to create a new <code>fw1</code> project called <code>myapp</code>, drop into that newly created directory and run the generated skeleton application.</p>

<p>Behind the scenes, Leiningen looks for the most recent release of the <code>fw1/lein-template</code> artifact on Clojars (or Maven Central), downloads it and adds it to the classpath, then it <code>require</code>s the <code>leiningen.new.fw1</code> namespace (assumed to be in that artifact) and calls the <code>fw1</code> function within that namespace. That <code>fw1</code> template project in turn relies on the <code>leiningen.new.templates</code> namespace to provide a number of functions to <code>render</code> new project files from mustache-style templates, using the <a href="https://github.com/davidsantiago/stencil">Stencil library</a>. Leiningen templates may also depend on Leiningen&rsquo;s core code, as well as a few libraries that Leiningen always makes available (such as <a href="https://github.com/scgilardi/slingshot">Slingshot</a>).</p>

<p>I figured that in order to kickstart any <code>boot new</code> functionality, it would make sense for it to be able to render existing Leiningen templates, as well as Boot-specific templates. Since Boot deliberately includes source code directly from other projects so as to minimize the number of dependencies it brings in, and it already had several pieces of Leiningen copied into it, I reached out to <a href="https://github.com/hyPiRion">Leiningen&rsquo;s current maintainer, Jean Niklas L'orange</a> and asked permission to include parts of Leiningen&rsquo;s new/template support. He graciously said yes &ndash; thank you! &ndash; so I created a raw first cut of a <code>new</code> task for Boot, based directly on Leiningen&rsquo;s code, which in turn depended on Bultitude and <code>leiningen-core</code> (and a few other bits and pieces). Because Boot tasks are &ldquo;just Clojure&rdquo;, it was fairly straightforward to get to a [working 0.1.0 version]<a href="https://github.com/seancorfield/boot-new/blob/v0.1.0/src/boot/new.clj">https://github.com/seancorfield/boot-new/blob/v0.1.0/src/boot/new.clj</a>) that had basic parity with <code>lein new</code>.</p>

<p>Since Boot already provided ways to manage dependencies and the classpath, my next goal was <a href="https://github.com/seancorfield/boot-new/blob/v0.2.0/src/boot/new.clj">an 0.2.0 version that didn&rsquo;t rely on Leiningen&rsquo;s core</a>. This version provided the same functionality (well, almost, it had compatibility bugs that took another version to iron out) but no longer needed to bring in <code>leiningen-core</code> as a dependency (unless you were generating a Leiningen template which might itself rely on that).</p>

<p>At this point, I was able to implement built-in templates to match Leiningen&rsquo;s <code>app</code>, <code>default</code> (library), <code>plugin</code>, and <code>template</code>, which would produce Boot-specific versions. The <a href="https://github.com/seancorfield/boot-new/tree/v0.2.1/src/boot/new">0.2.1 version included built-in templates</a> for <code>app</code>, <code>default</code>, <code>task</code> (the Boot equivalent of a plugin), and <code>template</code>.</p>

<p>Boot <code>new</code> had both <code>leiningen.new.templates</code> (adapted to run inside Boot) and <code>boot.new.templates</code> to support Boot templates. A Boot template is just like a Leiningen template, with a couple of important exceptions: the artifact name is of the form <code>foo/boot-template</code> (instead of <code>foo/lein-template</code>) and the template&rsquo;s main namespace is <code>boot.new.foo</code> (instead of <code>leiningen.new.foo</code>). In addition, a Boot template is expected to rely on Boot&rsquo;s internals or explicitly specify its own dependencies &ndash; instead of depending on Leiningen&rsquo;s core library. As a final piece of clean up for this &ldquo;initial&rdquo; version of Boot <code>new</code>, I removed the dependency on Bultitude (which actually hadn&rsquo;t been needed for a while) and deferred the addition of the <code>leiningen-core</code> and <code>slingshot</code> dependencies so they wouldn&rsquo;t be pulled in if you were generating a project from a Boot template.</p>

<p>At this point, I felt Boot <code>new</code> was ready to announce to the world! I could do:</p>

<pre><code>boot -d seancorfield/boot-new -t fw1 -n myapp
</code></pre>

<p>and get a freshly generated Framework One app, even if that still used Leiningen to actually run the new app. I could do:</p>

<pre><code>boot -d seancorfield/boot-new -t app -n myapp
</code></pre>

<p>to get a skeleton for an application that was &ldquo;powered by Boot&rdquo;: the generated <code>build.boot</code> file provides tasks for <code>build</code>ing the application uber-JAR and <code>run</code>ing the application itself.</p>

<p><a href="https://github.com/alandipert">Alan Dipert</a> and <a href="https://github.com/pesterhazy">Paulus Esterhazy</a> were the first two people to uncover compatibility bugs with existing Leiningen templates (for Hoplon and Chestnut, respectively). Thank you! And that brought me to Release 0.3.1 of <a href="https://github.com/seancorfield/boot-new">boot-new</a>.</p>

<p>The next thing on my roadmap is to add some sort of &ldquo;generator&rdquo; function (not unlike <a href="https://github.com/weavejester/lein-generate">James Reeves' lein-generate</a>) which will allow you to add new pieces to your existing projects, much Rails/Grails have built-in commands to let you add new models, controllers, and so on. That will be part of 0.4.0 and probably go through a couple of revisions. At some point, I&rsquo;ll feel comfortable declaring a 1.0.0 release and then we&rsquo;ll see about getting Boot <code>new</code> merged into the core of Boot itself.</p>

<p>Boot originally started life as a part of Hoplon and for a long time, you needed Leiningen in order to generate a new Hoplon project, even tho' Hoplon itself was powered-by-Boot. It&rsquo;s nice to see <a href="https://github.com/hoplon/hoplon/wiki/Get-Started#start-from-a-template">Hoplon&rsquo;s Getting Started</a> using <code>boot-new</code> as the recommended way to generate a new Hoplon project (it&rsquo;s still a Leiningen template!).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing With Boot]]></title>
    <link href="http://seancorfield.github.io/blog/2016/01/31/testing-with-boot/"/>
    <updated>2016-01-31T07:30:00-08:00</updated>
    <id>http://seancorfield.github.io/blog/2016/01/31/testing-with-boot</id>
    <content type="html"><![CDATA[<p>In <a href="http://seancorfield.github.io/blog/2016/01/30/building-on-boot/">Building On Boot</a>, I gave some high level benefits we&rsquo;d found with Boot, compared to Leiningen, and how it had helped up streamline our build process. That article closed with a note about Boot not having the equivalent of common Leiningen plugins, and that&rsquo;s what I&rsquo;m going to cover here, since that was the first real obstacle we encountered.<!-- more --></p>

<p>We use <a href="http://jayfields.com/expectations/">Jay Fields' Expectations</a> library very heavily for most of our testing needs. We use <code>clojure.test</code> only for our <a href="https://github.com/semperos/clj-webdriver">Clojure-powered WebDriver testing</a>. Leiningen has a <code>test</code> task built-in and we had been using <a href="https://github.com/gar3thjon3s/lein-expectations">lein-expectations</a> for years. It was quite a shock to find out that Boot has no testing tasks built-in!</p>

<p>Boot&rsquo;s standard for driving <code>clojure.test</code> is <a href="https://github.com/adzerk-oss/boot-test">Adzerk&rsquo;s boot-test</a>. Using it in your <code>build.boot</code> file is as simple as adding a dependency on <code>[adzerk/boot-test "1.0.7" :scope "test"]</code> and then referring in the <code>test</code> task:</p>

<pre><code>(merge-env! :dependencies '[[adzerk/boot-test "1.0.7" :scope "test"]])
(require '[adzerk.boot-test :refer [test]])
</code></pre>

<p>Now you can do <code>boot test</code> and run any tests in any of the namespaces in your source paths. Unfortunately there was no equivalent for Expectations so this was my first chance to roll up my sleeves and write a Boot task as a standalone project. The result is <a href="https://github.com/seancorfield/boot-expectations">boot-expectations</a>. Add a dependency on <code>[seancorfield/boot-expectations "1.0.5" :scope "test"]</code> and then refer in the <code>expectations</code> task:</p>

<pre><code>(merge-env! :dependencies '[[seancorfield/boot-expectations "1.0.5" :scope "test"]])
(require '[seancorfield.boot-expectations :refer [expectation]])
</code></pre>

<p>Now you can do <code>boot expectations</code> to run any Expectations tests in any of the namespaces in your source paths. Do <code>boot expectations -h</code> to see all the options the task provides.</p>

<p>I relied very heavily on two sources for this project: Adzerk&rsquo;s <code>boot-test</code> for the shape of the code and the <a href="https://clojurians.slack.com/messages/boot/">#boot channel</a> on the <a href="http://clojurians.net">Clojurians Slack</a> where Boot&rsquo;s maintainers hang out and are <em>extremely attentive and helpful</em>! In particular, <a href="https://github.com/micha">Micha Niskin</a> was invaluable, answering all my newbie questions and making suggestions. Boot&rsquo;s &ldquo;pods&rdquo; made it easy to specify the version of Clojure to use when running the tests, without affecting the version of Clojure used for anything else in the build process (we have always run our tests against the released version we are actually using as well as the latest snapshot of Clojure&rsquo;s master branch so we don&rsquo;t get surprised by any changes being introduced in the next release). The &ldquo;pod&rdquo; machinery also made it straightforward to have namespaces required into the testing environment, and shutdown functions run after the tests, again without affecting the main build process. And all in a single JVM process that runs for the duration of the build.</p>

<p>As you can see on Boot&rsquo;s wiki, the ecosystem of <a href="https://github.com/boot-clj/boot/wiki/Community-Tasks">community-maintained Boot tasks</a> is already pretty strong and growing all the time.</p>

<p>Back to our build process and one of the key drivers for looking at Boot in the first place: we&rsquo;d hit around 30K lines of production Clojure and 10K lines of test Clojure code, and we had it in three fair-sized projects with Leiningen. We wanted to reorganize the code and break it up into many more projects in order to have more flexibility in how we deploy code as well as being able to develop and test smaller chunks of code in isolation. We also wanted to be able to &ldquo;pin&rdquo; versions of certain libraries that we depended on across multiple &ldquo;projects&rdquo;. With Leiningen we&rsquo;d had multiple <code>project.clj</code> files and were already finding that we were pushing the declarative envelope of Leiningen by having to escape executable code into our <code>defproject</code> form. It felt like we were starting to fight the build tool. The declarative nature of <code>project.clj</code> didn&rsquo;t feel natural for the more fluid approach we wanted to take with our code base. What appealed about Boot was the possibility of a single <code>build.boot</code> file that could mix'n'match source and test code from various locations to allow the more modular develop / test approach we were aiming for, while still being able to easily build, push, and depend on artifacts from sub-projects. With Leiningen, we had a project for our WebDriver tests and it depended on a JAR built from the main source code project, so we would build and install (locally) a JAR of our main project, as part of the build. With Boot and a single <code>build.boot</code> file it was much easier to set up execution and test &ldquo;contexts&rdquo; as tasks that built the list of dependencies and source paths needed for each testing task. We now have all our Clojure code as &ldquo;sub-projects&rdquo; but can treat it as a single project too where that is more convenient.</p>

<p>In the next post, I&rsquo;ll take a diversion from World Singles' use of Boot and look at the <a href="https://github.com/seancorfield/boot-new">Boot new</a> project I&rsquo;ve been working on for a month &ndash; another &ldquo;missing piece of the ecosystem&rdquo; that I wanted to help fill!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building on Boot]]></title>
    <link href="http://seancorfield.github.io/blog/2016/01/30/building-on-boot/"/>
    <updated>2016-01-30T12:30:00-08:00</updated>
    <id>http://seancorfield.github.io/blog/2016/01/30/building-on-boot</id>
    <content type="html"><![CDATA[<p>In yesterday&rsquo;s blog post, <a href="http://seancorfield.github.io/blog/2016/01/29/rebooting-clojure/">Rebooting Clojure</a>, I talked about our switch from Leiningen to Boot but, as Sven Richter observed in the comments, I only gave general reasons why we preferred Boot, without a list of pros and cons.</p>

<p>Over the coming weeks, I&rsquo;ll write a series of posts about some of the specifics that worked better for us, as well as some of the obstacles we had to overcome in the transition.</p>

<p>In this post, I&rsquo;m going to cover some of the pros at a high level as it improved our build / test process.<!-- more --></p>

<p>I mentioned that we&rsquo;d evolved a fair size Ant script over time that does most of the heavy lifting of our build / test / deploy process. We&rsquo;d gradually been replacing parts of that process with Clojure code but it was easier to stick a <code>-main</code> function in certain namespaces to call into our code than to turn chunks of our code into Leiningen plugins. A case in point was our database and data migration tasks. We have developed a persistence layer in Clojure, built on top of <a href="https://github.com/clojure/java.jdbc">clojure.java.jdbc</a>, that encapsulates our connection pooling strategies and environment settings. Our migration code was built on top of that. Our Ant script invoked Leiningen to run these <code>-main</code> functions at various points. With each of these, we had repeated code to deal with command line arguments, process and environment set up, and then calls to what were, in effect, a series of &ldquo;tasks&rdquo;.</p>

<p>With Boot, we were able to eliminate a lot of that boilerplate. Boot tasks have command line argument parsing built-in. There&rsquo;s no need to create a <code>-main</code> function &ndash; the Boot tasks can call directly into our code. At this point we could easily compose tasks in a pipeline to satisfy any combination of database and data migration scenarios we needed, and we could simplify our Ant script to run a pipeline of Boot tasks as needed: which also meant we only fired up one JVM for that whole part of our build, instead of multiple invocations of Leiningen, each invoking a <code>-main</code> function.</p>

<p>We also have some CFML applications in the mix. Because history. We had several tasks accessible via HTTP requests into those CFML applications and those were also invoked by the Ant script because it was easy to do. Over time, we&rsquo;re committed to moving more and more of the CFML functionality down into Clojure (for what I hope are obvious reasons). Some of the tasks we were invoking via HTTP in Ant were already just thin CFML veneers over Clojure functionality, fortunately, so we were easily able to create a Boot task to call that functionality instead of going through CFML via HTTP.</p>

<p>Could we have done all this with Leiningen and plugins? Perhaps. Our experience with writing Leiningen plugins at this point had discouraged us from large scale plugin development. We were able to achieve more in a couple of weeks with Boot than we&rsquo;d able or willing to attempt with Leiningen in a long time.</p>

<p>There were cons too, of course, and the biggest was that several of Leiningen&rsquo;s built-in tasks and popular plugins, on which we relied heavily, were either absent or extremely different with Boot. I&rsquo;ll cover some of those in my next post.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rebooting Clojure]]></title>
    <link href="http://seancorfield.github.io/blog/2016/01/29/rebooting-clojure/"/>
    <updated>2016-01-29T14:30:00-08:00</updated>
    <id>http://seancorfield.github.io/blog/2016/01/29/rebooting-clojure</id>
    <content type="html"><![CDATA[<p>We switched from <a href="http://leiningen.org/">Leiningen</a> to <a href="http://boot-clj.com/">Boot</a>. What is Boot and why did we switch?<!-- more --></p>

<h2>Leiningen</h2>

<p>Before we talk about Boot, let&rsquo;s first talk about Leiningen. Leiningen describes itself as being &ldquo;for automating Clojure projects without setting your hair on fire&rdquo; and claims to be &ldquo;the easiest way to use Clojure&rdquo;. Rightly so. Leiningen hides all of the messy Maven-y dependency stuff, makes it drop-dead simple to package your applications and libraries as JAR files, makes it easy to run Clojure and provides a nice REPL experience, as well as integrating well with all the editors that Clojurians enjoy.</p>

<p>For a long time, Leiningen was the only game in town, and when we started using Clojure at World Singles, it was the fundamental basis of everything we did with parentheses. We started with a 1.x version of Leiningen, we upgraded to 2.x and we constructed a fair bit of our build / deploy / execute chain around it.</p>

<p>We wrote a couple of Leiningen plugins to deal with some &ldquo;interesting&rdquo; use cases in our environment: one to copy just dependencies to a specific target folder, one to set up a browser environment to run multiple <a href="https://github.com/semperos/clj-webdriver">clj-webdriver</a> tests in a single browser session.</p>

<p>Over time we evolved a fairly large Ant script and a bunch of shell scripts but we really wanted to do more of that automation with Leiningen &ndash; since it&rsquo;s all about &ldquo;automating Clojure projects&rdquo; &ndash; but the reality of writing Leiningen plugins for general automation doesn&rsquo;t quite live up to the promise. Between the declarative nature of <code>project.clj</code> and overall framework in which plugins must execute, there&rsquo;s a lot more than just &ldquo;writing Clojure&rdquo; and there are evaluation restrictions around the processes. Bottom line, we just didn&rsquo;t get as far as we&rsquo;d have liked with Leiningen.</p>

<h2>Early Boot</h2>

<p>Going back to the second ever <a href="http://www.clojurebridge.org/">ClojureBridge</a> workshop. I was organizing this and at teacher training we were going over the curriculum that had been built for the first workshop and it used an early version of Boot. Unfortunately, it was a very rough experience and virtually unusable on Windows. As my first exposure to Boot, it was less than ideal and it put me off exploring it any further.</p>

<p>Looking back, I&rsquo;m sure Boot was well-designed from the start and the design choices made were all solid &ndash; Boot was created by some very smart people &ndash; but I was less than charitable about Boot and unnecessarily vocal. I didn&rsquo;t take Boot very seriously.</p>

<h2>Boot 2.5.0</h2>

<p>Coming back to the present, Boot 2.5.0 was released in mid-December 2015. I owed it a serious second look. I was impressed. For starters, the installation process had become hella slick and the documentation looked really good. My early exploration was to try Boot on Windows 10, Mac OS X, and Linux for both the REPL experience and the basic project build process. One of the most striking differences from Leiningen was that &ldquo;it&rsquo;s just Clojure&rdquo;: the build script is straightforward executable Clojure, and tasks are just functions, and everything is based on an abstraction of a fileset. Another striking difference is that composability is baked right into the core of Boot: tasks are like Ring middleware and can wrap each other in a pipeline that allows tasks to take control both before and after other tasks in the pipeline.</p>

<p>After a promising &ldquo;first look&rdquo;, I decided to convert a couple of our core processes to run under Boot so that I could see what a real <code>build.boot</code> would look like in our environment. The only fly in the ointment for us was that Boot uses a single JVM and we were used to being able to compute our JVM options in <code>project.clj</code> (inside the first Leiningen JVM) for use by the application JVM (Leiningen&rsquo;s second JVM). By contrast, Boot uses environment variables to set up a single JVM environment and is a minimal intrusion itself. Boot further mitigates its own intrusion by allowing you execute code in a &ldquo;pod&rdquo; with its own isolated dependencies.</p>

<p>We opted for a wrapper shell script to deal with our JVM environment computation. Once we had that in place, having just a single JVM up and running was a win all round: every process started up faster, our task and automation code was simpler.</p>

<p>We decided on a two week spike to replace Leiningen with Boot across our entire project, and lift all of our executable processes up as Boot tasks. As of January 21st, we have Boot as an integral part of our production infrastructure. We&rsquo;re happy.</p>

<p>In the next blog post, I&rsquo;ll talk about some of the specifics in our Boot infrastructure and the tasks we&rsquo;re writing. As a teaser, you can look at <a href="https://github.com/seancorfield/boot-expectations">boot-expectations</a> and <a href="https://github.com/seancorfield/boot-new">boot-new</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Where Did 2015 Go?]]></title>
    <link href="http://seancorfield.github.io/blog/2016/01/03/where-did-2015-go/"/>
    <updated>2016-01-03T08:00:00-08:00</updated>
    <id>http://seancorfield.github.io/blog/2016/01/03/where-did-2015-go</id>
    <content type="html"><![CDATA[<p>I did not intend to stop blogging in 2015 but that&rsquo;s certainly what it looks like here!</p>

<p>So what kept me so busy that I didn&rsquo;t get around to blogging anything?<!-- more --></p>

<p>Almost a year ago, I <a href="http://seancorfield.github.io/blog/2015/02/13/frege-and-clojure/">talked about my Leiningen plugin for Frege</a>. Back then it was version 3.22.367. That plugin is now version 3.23.450 and there&rsquo;s a Leiningen template to go with it, tracking prerelease builds of Frege which I&rsquo;ve been publishing to Sonatype&rsquo;s OSS Snapshots repository.</p>

<pre><code>lein new frege myapp
</code></pre>

<p>That will generate a new, pure Frege project for you to build on. If you want a mixed Frege and Clojure project, like the original concept:</p>

<pre><code>lein new frege myapp -- :with-clojure
</code></pre>

<p>I haven&rsquo;t gotten to work with Frege as much as I&rsquo;d hoped but I managed to contribute ports of two very small Haskell 2010 libraries (<code>System.Environment</code> and <code>System.Exit</code>) as well as exposing a few more pieces of Java&rsquo;s <code>Runtime</code> class in Frege&rsquo;s <code>java.lang.System</code> data type. I hope 2016 will bring a lot more Frege to my life!</p>

<p>In that blog post, I also talked about learning a new language every year. I mentioned <a href="http://elm-lang.org/">Elm</a>: I&rsquo;d experimented with it quite a bit in its early days and I&rsquo;d hoped to continue experimenting, but work and life distracted me from front end concerns and I lost touch with Elm&rsquo;s evolution. All I can say is that Elm continues to go from strength to strength, and it is gaining more press inches and more visibility at conferences, which is all good. It&rsquo;s truly innovative and I want to see it succeed! I did however spend quite a bit of time learning a little <a href="https://www.rust-lang.org">Rust</a> and it makes me wish I did a lot more close-to-the-metal programming: it&rsquo;s a <em>really</em> nice language and the &ldquo;borrowing&rdquo; system is very impressive (even if you find yourself fighting with it a lot at first!).</p>

<p>In the past, I&rsquo;ve also blogged about almost every conference I&rsquo;ve attended so you would be forgiven for thinking I didn&rsquo;t attend any events in 2015. I was able to attend The Strange Loop and Clojure/conj this past year. I would have loved to have attended Clojure/West as <a href="http://clojurewest.org/speakers#fhanreich">my colleague Fumiko gave a talk about HoneySQL</a>. That link will evaporate when this year&rsquo;s conference comes around but you can <a href="https://www.youtube.com/watch?v=alkcjyhesjI">watch Fumiko&rsquo;s talk about HoneySQL</a> on ClojureTV. It was her first ever conference talk and she did a great job &ndash; I&rsquo;m very proud of her! Oh, she also likes Elm.</p>

<p>Fumiko and I worked on a project with ClojureScript, <a href="http://reagent-project.github.io/">Reagent</a> &ndash; a ClojureScript wrapper for <a href="http://facebook.github.io/react/">React.js</a>, and <a href="https://github.com/ptaoussanis/sente">Sente</a> &ndash; core.async over WebSockets. It was a lot of fun and very interesting. It was a proof of concept but, in the end, our company decided to go with JavaScript as being more mainstream (but still with React.js so, win!).</p>

<p><a href="http://www.thestrangeloop.com/">The Strange Loop</a> was its usual amazing self. Alex Miller and his team manage to excel themselves, year-on-year. The keynote talks were <em>phenomenal</em> this year with Idalin Bob&eacute;&rsquo;s inspiring talk about activism and Morgan Marquis-Boire&rsquo;s terrifying security and espionage talk as the highlights of the whole conference. The &ldquo;theme&rdquo; this year was distributed systems. I think this image sums it up well:</p>

<p><img class="center" src="/images/distributed.jpg" width="600" height="450" title="&lsquo;image&rsquo; &lsquo;images&rsquo;" ></p>

<p>The other highlight for me was a social event: the <a href="http://lgbtq.technology/">LGBTQ in Technology Slack</a> dinner, generously sponsored by <a href="https://codeclimate.com/">Code Climate</a>. The Strange Loop team work hard to ensure the conference is a diverse, welcoming, safe space for everyone and I was excited to be able to organize this dinner with the support of the conference organizers.</p>

<p>That social theme continued at <a href="http://clojure-conj.org/">Clojure/conj</a> in Philadelphia where I was able to spend time with more folks from the LGBTQ in Technology Slack community (and had a lovely dinner at <a href="http://www.thetwistedtail.com/">The Twisted Tail</a> with my friend <a href="https://twitter.com/quephird">Danielle</a>. If you&rsquo;re ever in Philly, <em>go to that restaurant</em>!!).</p>

<p>As usual, Clojure/conj was an incredible mix of real world Clojure, academic research, and bleeding edge exploration in industry. One talk made the entire conference worth the cost for me: Bobby Calderwood&rsquo;s <a href="https://www.youtube.com/watch?v=qDNPQo9UmJA">From REST to CQRS</a> with Clojure, Kafka (and Samza), and Datomic. The &ldquo;hallway track&rdquo; that followed this talk caused me to miss the last two talks but it was oh so valuable! Fast forward two months and we&rsquo;re starting down the path of Kafka and distributed systems at work. Priceless, as they say. Other highlights were the father and son Engelbergs on Automata, Ram Krishnan&rsquo;s &ldquo;Clojure for Business Teams&rdquo;, Stuart Halloway&rsquo;s keynote &ldquo;Debugging with the Scientific Method&rdquo; (<em>everyone</em> should watch <a href="https://www.youtube.com/watch?v=FihU5JxmnBg">this talk</a>), Lee Spector&rsquo;s &ldquo;Genetic Programming&rdquo; talk, and Benjamin Pierce&rsquo;s keynote about formal specifications and generative testing.</p>

<p>And then there was work&hellip;</p>

<p>I love my job, I love my team, and we get to solve some fascinating problems at <a href="http://worldsinglesnetworks.com/">World Singles</a>. The company has a history of using <a href="http://www.adobe.com/products/coldfusion-family.html">ColdFusion</a>, although we switched to a Free Open Source Software alternative in 2009 and we&rsquo;ve been running on <a href="http://lucee.org/">Lucee</a> for most of 2015. We started using Clojure in production almost five years ago now (with Clojure 1.3 Alpha 7 or Alpha 8) and we declared it our &ldquo;primary language&rdquo; about a year ago. Since then we&rsquo;ve systematically rewritten code in Clojure as we&rsquo;ve needed to enhance functionality &ndash; definitely a situation where &ldquo;refactor&rdquo; really does mean &ldquo;rewrite&rdquo;. I created a bridge project that allows Cloure to be loaded and run easily inside CFML engines about five years ago and that&rsquo;s continued to evolve. The MVC framework I created in 2009 has continued to evolve as well, with 2015 seeing release 3.1 and 3.5 &ndash; the latter has integrated the Clojure bridge, to enable seamless mixed language projects. We rely heavily on this. Release 4.0 is almost ready for Alpha 1, and focuses on enhancing REST API capabilities.</p>

<p>In addition, we created an OAuth 2 server, mostly in Clojure, to support our REST API, and we&rsquo;ve worked hard to move all of our persistence from CFML&rsquo;s &ldquo;query&rdquo; functionality to a Clojure &ldquo;<a href="https://github.com/seancorfield/datamapper">data mapper</a>&rdquo; based on <a href="http://clojure-doc.org/articles/ecosystem/java_jdbc/home.html">clojure.java.jdbc</a>. We closed out 2015 with <em>all</em> of our persistence handled by Clojure, a big win for performance and maintainability!</p>

<p>Our other big change, coming at the tail end of year, was a switch from <a href="http://leiningen.org/">Leiningen</a> to <a href="http://boot-clj.com/">Boot</a> for our primary Clojure build tool. I&rsquo;ll be blogging about this more in due course, but for now I&rsquo;ll just mention the <a href="https://github.com/seancorfield/boot-expectations">Boot task for running Expectations tests</a> and that Leiningen-style templates will be coming to Boot soon&hellip;</p>

<p>Happy 2016!</p>
]]></content>
  </entry>
  
</feed>
