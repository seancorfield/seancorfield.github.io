<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Clojure | An Architect's View]]></title>
  <link href="http://seancorfield.github.io/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://seancorfield.github.io/"/>
  <updated>2017-07-17T12:49:50-07:00</updated>
  <id>http://seancorfield.github.io/</id>
  <author>
    <name><![CDATA[Sean Corfield]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Release 0.7.0 of clojure.java.jdbc]]></title>
    <link href="http://seancorfield.github.io/blog/2017/07/17/clojure-java-jdbc-0-7-0/"/>
    <updated>2017-07-17T03:40:00-07:00</updated>
    <id>http://seancorfield.github.io/blog/2017/07/17/clojure-java-jdbc-0-7-0</id>
    <content type="html"><![CDATA[<p>The stable 0.7.0 release of <code>java.jdbc</code> &ndash; the <a href="https://github.com/clojure/java.jdbc">Clojure Contrib JDBC library</a> &ndash; has been baking for over a year, across of a trail of alpha and beta releases, and is now, finally, available!</p>

<p>While you <em>could</em> read the <a href="https://github.com/clojure/java.jdbc/blob/master/CHANGES.md"><code>java.jdbc</code> Change Log</a> to figure out what is new in this release, I thought it would be easier to consolidate all the changes into a blog post, with changes organized by category, and provide justification for the various changes.<!-- more --></p>

<p>I recently ran a <a href="https://www.surveymonkey.com/results/SM-CJY2YMHP/">survey about versions</a> of both Clojure and <code>java.jdbc</code> in use and had nearly 100 responses (thank you to everyone who completed the survey!). Only one respondent is still on Clojure 1.7.0, with about two thirds on 1.8.0, and a full third of respondents on a 1.9.0 alpha build. No one responded that they&rsquo;re on an earlier version of Clojure. That&rsquo;s great news for Clojure library maintainers, as it means we can take advantage of modern features in the language (such as transducers), and it also means that it is worthwhile to offer optional namespaces providing specs. <strong>Accordingly, <code>java.jdbc</code> now requires Clojure 1.7.0 or later.</strong></p>

<p>Also very encouraging was to see that almost a third of <code>java.jdbc</code> users are on alpha builds of what has become 0.7.0, with only a handful of users still on &ldquo;legacy&rdquo; versions (prior to 0.6.1).</p>

<p>Let&rsquo;s look at the major changes in 0.7.0, compared to 0.6.1!</p>

<h2>Reducible Queries</h2>

<p>Now that Clojure 1.7.0 is the minimum supported version, <code>java.jdbc</code> can offer query result collections that work with transducers. Two new functions &ndash; <code>reducible-query</code> and <code>reducible-result-set</code> &ndash; produce collections that implement <code>IReduce</code> and will perform resource management when <code>reduce</code>d. A reducible query will run the specified query only when the result is reduced &ndash; and it will run it each time it is reduced. A reducible result set can be constructed from any <code>ResultSet</code> object and will provide a one-off, managed forward read of the underlying data. Both of these support <code>reduced</code> results, which short-circuit the processing of the result set. They also support both the <code>init</code>-arity <code>reduce</code> and the no-<code>init</code>-arity <code>reduce</code>. Consult the docstring for <code>reduce</code> to see the full implications of this: the function passed into the no-<code>init</code>-arity <code>reduce</code> will be called with no arguments if the result set is empty!</p>

<p><code>reducible-query</code> works by invoking <code>db-query-with-resultset</code> only when it is <code>reduce</code>d, passing in a function that calls <code>reducible-result-set</code> and then <code>reduce</code>s the result. <code>reducible-result-set</code> works by computing metadata and key names only when it is <code>reduce</code>d, and then walking through the rows of the result, calling the supplied function (as specified by <code>reduce</code>), stopping if that function returns a <code>reduced?</code> value.</p>

<h2>Improved Database Vendor Support</h2>

<p>The <code>:dbtype</code> key in a <code>db-spec</code> is the preferred way to specify a database vendor, so you don&rsquo;t have to worry about &ldquo;subprotocols&rdquo; and &ldquo;subnames&rdquo; and so on. Just provide <code>:dbtype</code>, <code>:dbname</code>, <code>:host</code>, <code>:port</code>, <code>:user</code>, and <code>:password</code>, and <code>java.jdbc</code> should be able to connect you to most databases. The full list of supported <code>:dbtype</code> values is:</p>

<ul>
<li><code>derby</code> &ndash; Apache Derby</li>
<li><code>h2</code></li>
<li><code>hsql</code> or <code>hsqldb</code></li>
<li><code>jtds</code> or <code>jtds:sqlserver</code> &ndash; the jTDS JDBC driver for Microsoft SQL Server</li>
<li><code>mssql</code> &ndash; an alias for <code>sqlserver</code> below</li>
<li><code>mysql</code></li>
<li><code>oracle</code> or <code>oracle:thin</code>, <code>oracle:oci</code> &ndash; for the two main Oracle JDBC drivers (which use <code>@</code> in front of the <code>host</code> name, instead of <code>//</code>)</li>
<li><code>pgsql</code> &ndash; the Impossibl PostgresSQL JDBC driver</li>
<li><code>postgres</code> or <code>postgresl</code> &ndash; the standard PostgresSQL JDBC driver</li>
<li><code>redshift</code> &ndash; Amazon&rsquo;s Red Shift JDBC driver</li>
<li><code>sqlite</code></li>
<li><code>sqlserver</code> &ndash; Microsoft&rsquo;s default JDBC driver for SQL Server (they have finally released a version on Maven Central!)</li>
</ul>


<p>If your preferred database is not listed, head on over to <a href="https://dev.clojure.org/jira/browse/JDBC"><code>java.jdbc</code>s JIRA site</a> and create an enhancement issue, with details of the JDBC driver and I&rsquo;ll take a look! Note that you can can specify <code>:classname</code>, along with <code>:dbtype</code> if you want to override just the JDBC driver class name that <code>java.jdbc</code> would deduce from <code>:dbtype</code>.</p>

<h2>Option Handling</h2>

<p>An overall goal of 0.7.0 has been to make the API more consistent, especially in the way options are handled and passed around. The intention is that you can provide a hash map of options, as the last argument to any function, and <code>java.jdbc</code> will pass all of those options through the whole call chain, allowing you to control a lot more of the behavior of lower-level functions that are invoked by the higher-level functions. In addition, defaults for all options can be provided in your <code>db-spec</code>, and those will apply to all API functions. This is especially useful for specifying the <code>:entities</code> and <code>:identifiers</code> functions that control how SQL entity names and Clojure identifiers are constructed, everywhere in <code>java.jdbc</code>.</p>

<p>Here are all the new options available:</p>

<ul>
<li><code>:auto-commit?</code> &ndash; Can be passed into any API function that might cause a new database connection to be created. This allows you to turn auto-commit off for <em>new connections</em> in databases that use this setting to control whether a query can stream its results. The behavior is inherently vendor-specific, so you may need additional options to fully enable streaming results (setting <code>:fetch-size</code> to a non-zero value is common).</li>
<li><code>:conditional?</code> &ndash; For the two DDL-generating functions to add an existence check on the table to be created or dropped. May be a simple boolean value, a string (to be inserted between <code>DROP TABLE</code>/<code>CREATE TABLE</code> and the table name), or a function. In the latter case, the DDL string is generated as usual and then that function is called on it. This allows for databases that don&rsquo;t support <code>DROP TABLE IF EXISTS</code> / <code>CREATE TABLE IF NOT EXISTS</code> but instead require the <code>DROP</code> or <code>CREATE</code> statement to be wrapped in a specific existence checking query.</li>
<li><code>:explain?</code> and <code>:explain-fn</code> &ndash; So you can get the database to explain how it will run your query. Supported by <code>query</code>, <code>find-by-keys</code>, and <code>get-by-id</code>, these options will run the generated SQL with an &ldquo;explain&rdquo; option first, and then for real. <code>:explain?</code> can be <code>true</code> which simply prefixes the SQL with <code>"EXPLAIN "</code> or it can be a string if your database needs a different syntax (such as HSQLDB needing <code>"EXPLAIN PLAN FOR "</code>). The explanation output is processed by the <code>:explain-fn</code>, which defaults to <code>println</code>, but can be used to send explanations to a logging system etc.</li>
<li><code>:qualifier</code> &ndash; Lets you easily produce namespace-qualified column names from your queries.</li>
<li><code>:read-columns</code> &ndash; To specify how columns of data are read from a <code>ResultSet</code> object. The default behavior is to call <code>result-set-read-column</code> which implements the <code>IResultSetReadColumn</code> protocol. This allows finer-grained control when you are working with multiple databases in a single application.</li>
<li><code>:read-only?</code> &ndash; Like <code>:auto-commit?</code> this can be passed into any API function that might cause a new database connection to be created. This allows you to specify that <em>new connections</em> be treated as readonly, which may allow the database driver to perform optimizations on how the connection and its queries behave.</li>
</ul>


<h2>clojure.spec</h2>

<p><code>java.jdbc</code> provides an optional <code>clojure.java.jdbc.spec</code> namespace that is compatible with Clojure 1.9.0 Alpha 17 (it uses <code>clojure.spec.alpha</code>). This namespace provides <code>fdef</code> specs for all of the public functions in <code>clojure.java.jdbc</code> so you can <code>instrument</code> your code and get validation on all your interaction with <code>java.jdbc</code>. Note that you cannot do generative testing against <code>java.jdbc</code> because it uses a lot of Java types and a lot of side effects. <em>I have an experimental branch where I&rsquo;ve been investigating what generators would look like for <code>java.jdbc</code> but don&rsquo;t hold your breath for that becoming part of the <strong>master</strong> branch!</em></p>

<h2>New and Changed API Functions</h2>

<ul>
<li><code>as-sql-name</code> dropped its single arity (curried) version.</li>
<li><code>get-isolation-level</code> will return the current isolation level inside a transaction, if any.</li>
<li><code>quoted</code> dropped its 2-arity version, and now supports certain keywords for common entity-quoting strategies: <code>:ansi</code> (wraps entities in double quotes), <code>:mysql</code> (wraps entities in backticks), <code>:oracle</code> (wraps entities in double quotes), and <code>:sqlserver</code> (wraps entities in square brackets). These match the options in HoneySQL.</li>
<li><code>reducible-query</code> and <code>reducible-result-set</code> &ndash; see <strong>Reducible Queries</strong> above.</li>
</ul>


<h2>Documentation</h2>

<p>At present, the auto-generated API documentation (on <a href="https://clojure.github.io">https://clojure.github.io</a>) is stale due to some bugs in the toolchain used by the Clojure Build Server, so I recommend reading the <a href="http://clojure-doc.org/articles/ecosystem/java_jdbc/home.html">community-maintained <code>java.jdbc</code> documentation</a> on clojure-doc.org, in addition to using <code>clojure.repl/doc</code> to review the docstrings for API functions. That community-maintained documentation is currently going through a major overhaul to expand, clarify, and update the information presented &ndash; I encourage users of <code>java.jdbc</code> to get involved by submitting Pull Requests to help improve the documentation for everyone!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Seancorfield/boot-new Has Moved to Boot/new]]></title>
    <link href="http://seancorfield.github.io/blog/2017/01/19/boot-new-moved/"/>
    <updated>2017-01-19T12:40:00-08:00</updated>
    <id>http://seancorfield.github.io/blog/2017/01/19/boot-new-moved</id>
    <content type="html"><![CDATA[<p>I&rsquo;m pleased to announce that the &ldquo;Boot new&rdquo; task formerly known as <code>seancorfield/boot-new</code> has moved to the Boot organization, as <a href="https://github.com/boot-clj/boot-new"><code>boot-clj/boot-new</code></a> and that the group/artifact ID is now <code>boot/new</code>.</p>

<p>You can use this to easily create a new Boot-based project:</p>

<pre><code>boot -d boot/new new -t app -n my-new-boot-app
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure, New Relic, and Slow Application Startup]]></title>
    <link href="http://seancorfield.github.io/blog/2016/07/29/clojure-new-relic-slow-startup/"/>
    <updated>2016-07-29T13:20:00-07:00</updated>
    <id>http://seancorfield.github.io/blog/2016/07/29/clojure-new-relic-slow-startup</id>
    <content type="html"><![CDATA[<p>A couple of years ago, I blogged about <a href="http://seancorfield.github.io/blog/2013/05/01/instrumenting-clojure-for-new-relic-monitoring/">instrumenting Clojure for New Relic monitoring</a> and we&rsquo;ve generally been pretty happy with New Relic as a service overall. A while back, we had tried to update our New Relic Agent (used with our Tomcat-based web applications) from 3.21.0 to 3.25.0 and we ran into exceedingly long application start times, so we rolled back and continued on with 3.21.0. Recently, we decided to update the Agent to 3.30.1 to take advantage of advertised performance improvements and security enhancements. Once again we ran into exceedingly long application start times.</p>

<p>An application that took just over four minutes to start up fully with 3.21.0 was taking around forty minutes to start up with 3.30.1 &ndash; an order of magnitude slower!<!-- more --></p>

<p>Since we really wanted this update, we contacted New Relic Technical Support. Somewhat cryptically, they asked us to try version 3.24.1 &ndash; and that did not exhibit the slow startup &ndash; at which point they acknowledged that they&rsquo;d had reports that, with some applications, some customers had experienced slow startups since the 3.25.0 release. They asked us to set the logging level to &ldquo;finest&rdquo;, start the application up on a test machine, and then send them the log file. It was over 230MB(!) and full of Weave violations that the &ldquo;original bytecode&rdquo; could not be found. They very quickly traced this to how their instrumentation code tries to decide which classes to trace and which to ignore &ndash; and noted that Clojure creates a lot of <code>clojure.lang.DynamicClassLoader</code> instances (about 176,000 warnings in the log files originated from this class!) and, since the instrumentation never finds anything useful to instrument, loaded via those classloaders, they suggested that we tell the Agent to skip them.</p>

<p>As far as I can tell, this is not a documented configuration item (although there is a similar <code>classloader_excludes</code> list):
<code>
  class_transformer:
    classloader_blacklist: clojure.lang.DynamicClassLoader
</code>
This stops the Agent from examining this classloader and/or the code loaded by it and it dramatically cut the application start times. After adding this to <code>newrelic.yml</code>, our applications started up slightly faster than they had with 3.21.0.</p>

<p>So, thank you to Jesse @ New Relic for the swift troubleshooting on this issue! I&rsquo;m posting this because I couldn&rsquo;t find a solution to the problem via Google &ndash; although I could find people complaining about the problem. Hopefully this will help others using New Relic with Clojure (or other languages that hit the same issue).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Start Your Engine]]></title>
    <link href="http://seancorfield.github.io/blog/2016/07/18/start-your-engine/"/>
    <updated>2016-07-18T04:00:00-07:00</updated>
    <id>http://seancorfield.github.io/blog/2016/07/18/start-your-engine</id>
    <content type="html"><![CDATA[<p>Today I&rsquo;m inspired by the <a href="http://us4.campaign-archive1.com/?u=a33b5228d1b5bf2e0c68a83f4&amp;id=56d35f53c5">latest issue of Eric Normand&rsquo;s Clojure Gazette</a> which talks about why his &ldquo;Joy of Programming&rdquo; comes from learning and exploration.</p>

<p>I got into programming as a child because I was curious about solving puzzles and problems: given the (relatively) limited vocabulary of a programming language and its input and output features, and some interesting problem that came to mind, can I solve it in a usable (and hopefully elegant) way?</p>

<p>Over the years, I&rsquo;ve written a <strong>lot</strong> of fun little programs to solve all sorts of interesting puzzles and problems that I&rsquo;ve either run across or invented just to amuse myself. I learn different programming languages to learn new vocabularies for solving problems, and new ways of looking at problems.</p>

<p>Some of those programs become libraries that I&rsquo;ve ended up using at work in one form or another, some become open source projects where I&rsquo;m pretty much the only user, a very small number become widely used projects.<!-- more --></p>

<p>Back in 2009, when my work was primarily CFML-based (and I wrote side projects in other languages for fun), I sketched out, figuratively on a <a href="http://framework-one.github.io/blog/2010/02/06/fw1-the-napkin-spec/">napkin, my ideas for a minimal MVC framework, based on conventions</a>. It was intended as an exercise to &ldquo;scratch an itch&rdquo;. It went on to become one of the most popular MVC frameworks in the CFML community (and I still maintain it to this day, even tho' my work is almost entirely Clojure now).</p>

<p>Again, as an exercise to &ldquo;scratch an itch&rdquo;, while I was still relatively new to Clojure, I decided to <a href="http://framework-one.github.io/blog/2011/11/07/fw1-comes-to-clojure/">port the core of that framework to Clojure</a>. It started as a bundle of <a href="https://github.com/ring-clojure/ring">Ring</a>, <a href="https://github.com/cgrand/enlive">Enlive</a>, and a convention-based routes-to-namespace-and-function mapping. Along the way, I replaced Enlive with <a href="https://github.com/yogthos/Selmer">Selmer</a>, and this &ldquo;fun little program&rdquo; now falls into the category of an open source project where I&rsquo;m pretty much the only user (we&rsquo;re starting to use it at work).</p>

<p>About a year ago, I had another puzzle in mind: could I create a usable library that allowed for a separation of queryable data sources, pure business logic, and committable changes (inserts, updates, and deletes). I created <a href="https://github.com/seancorfield/engine">Engine</a> purely to scratch that itch over a few days at the end of May 2015 and, apart from converting it to use Boot at the end of 2015, it&rsquo;s languished on GitHub ever since. Until a few weeks ago, when it looked like a solution to a problem at work.</p>

<p>We wanted a clearly delineated idiom where we could refactor our business logic out into pure functions, that depended on a set of queryable resources (some readonly JDBC and MongoDB data sources, a Component-based &ldquo;system&rdquo;, etc), and produce a set of changes that could be applied to a database or sent over a message queue to be processed or to update a search engine etc. We wanted something that &ldquo;forced&rdquo; this on our code (or at least &ldquo;strongly encouraged&rdquo; this separation of concerns).</p>

<p>Using Engine in the real world has caused it to grow and evolve to make it more fluent in production code (hence the flurry of changes and new releases over the last few weeks) but it&rsquo;s also allowed us to take a long, hard look at what shape our code needs to be, in order to support our legacy production platform, our new production platform, and our future production platform.</p>

<p>Although it would be nice to get extra eyes on both Engine and FW/1 for Clojure and, yes, additional users of both projects, I&rsquo;m posting this mostly as encouragement to &ldquo;scratch your itch&rdquo; and to write code as a way of learning, and exploring new ideas. It doesn&rsquo;t matter if that code is ultimately useful to anyone other than to you, as a medium for expressing your thoughts: write it down, play with it, use it to investigate a new concept or to rethink an existing one. Above all, <strong>enjoy</strong> programming!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More Boot]]></title>
    <link href="http://seancorfield.github.io/blog/2016/06/17/more-boot/"/>
    <updated>2016-06-17T13:00:00-07:00</updated>
    <id>http://seancorfield.github.io/blog/2016/06/17/more-boot</id>
    <content type="html"><![CDATA[<p>Back in February I talked about <a href="http://seancorfield.github.io/blog/2016/02/02/boot-new/">boot-new</a> and talked about a &ldquo;future 1.0.0 release&rdquo;. We&rsquo;re not there yet, but <a href="https://github.com/seancorfield/boot-new#boot-generators">generators</a> got added in release 0.4.0 and, in the four minor releases since, the focus has been on refactoring to match the core <a href="http://boot-clj.com/">Boot</a> task structure and improving compatibility with Leiningen templates. At World Singles, we&rsquo;ve continued to extend our usage of Boot until we have only a couple of Ant tasks left and we expect those to be within Boot&rsquo;s reach soon. In this post, I want to cover some of the things we&rsquo;ve been doing with Boot recently.<!-- more --></p>

<p>I feel I should start with an apology for the &ldquo;radio silence&rdquo; since February &ndash; it&rsquo;s a combination of work being extremely engaging (and busy!) and some aspects of my personal life going somewhat to hell in a handbasket&hellip; But things have improved lately (thankfully!) and I hope to be more regular in my blogging (I certainly have a decent queue of article ideas in my head!).</p>

<p>At work, we depend on a lot of libraries, both Java and Clojure, and we&rsquo;ve tended to be a bit cavalier about conflicts in transitive dependencies. Sure, we check that the desired version of any given library ends up being selected (via <code>boot ... show -p</code>) but we&rsquo;ve tended to only add <code>:exclusions</code> where absolutely necessary to avoid specific cases of the wrong version being selected. That had served us fairly well until we started to experiment with <a href="https://clojure.org/about/spec"><code>clojure.spec</code></a>, introduced in the Clojure 1.9.0 Alpha builds. Along with the new namespace, a number of new predicates have been introduced, in <code>clojure.core</code>, across several of those Alpha builds with names that are common enough that they conflict with user-defined predicates in a number of libraries. Normally, that wouldn&rsquo;t matter much: you&rsquo;d get:</p>

<pre><code>WARNING: ... already refers to: #'clojure.core/... in namespace: ..., being replaced by: #'...
</code></pre>

<p>and your program would continue to function normally. At some point, the library maintainer would add the new symbol to the <code>:exclude</code> list in their <code>:refer-clojure</code> clause, you&rsquo;d update, and life would be good.</p>

<p>Something strange was happening for us, however. Instead of the warnings, the user-defined function would just silently vanish and the program would fail trying to call an unbound <code>Var</code>. Weird. I found a workaround for one case (where a <code>defn</code> was inside a <code>do</code> in a <code>.cljx</code> file) but I couldn&rsquo;t reproduce the problem as a test case (and nor could Kevin Downey, who was skeptical enough of my line of reasoning to spend time trying to help me find the real reason &ndash; thank you sir!). I ran into a couple more similar bugs. It became clear Kevin was right (I feel like saying &ldquo;of course!&rdquo; here) and I needed to approach the problem differently. A few conversations happening around the same time &ndash; including one between Rich Hickey and Micha Niskin in the <a href="https://clojurians.slack.com/messages/boot/">#boot channel on Slack</a> &ndash; led me to focus on version conflicts in our transitive dependencies&hellip; Fortunately, Boot provides an easy way to detect if there are any conflicts (even if they resolve &ldquo;correctly&rdquo;) and Micha shared some code that I turned into the following Boot task:</p>

<pre><code>(deftask check-conflicts
  "Verify there are no dependency conflicts."
  []
  (with-pass-thru fs
    (require '[boot.pedantic :as pedant])
    (let [dep-conflicts (resolve 'pedant/dep-conflicts)]
      (if-let [conflicts (not-empty (dep-conflicts pod/env))]
        (throw (ex-info (str "Unresolved dependency conflicts. "
                             "Use :exclusions to resolve them!")
                        conflicts))
        (println "\nVerified there are no dependency conflicts.")))))
</code></pre>

<p>I added this to our build pipeline and <code>Unresolved dependency conflicts.</code> became a very familiar sight until I&rsquo;d added enough <code>:exclusions</code> to our dependencies to finally see <code>Verified there are no dependency conflicts.</code>. Was I glad to see <em>that</em> at the end of the day!</p>

<p>One of the things I noticed was the huge number of libraries that pull in some old version of Clojure itself as a transitive dependency, so I ended up adding a global exclusion to our <code>build.boot</code> file:</p>

<pre><code>(set-env! :exclusions ['org.clojure/clojure])
</code></pre>

<p>A few discussions ensued on Slack about whether projects should declare <code>org.clojure/clojure</code> as a <code>"provided"</code> dependency but there was no consensus, unfortunately. FWIW, I&rsquo;m in the <code>"provided"</code> camp.</p>

<p>The other big shift we&rsquo;ve made at work is to adopt <a href="https://github.com/stuartsierra/component">Stuart Sierra&rsquo;s Component</a>. This might seem like a no brainer for many people but most of our Clojure code operates inside a large non-Clojure web application and started life as a small set of libraries. Component is a great fit for &ldquo;whole program&rdquo; code but it was <a href="https://github.com/stuartsierra/component#disadvantages-of-the-component-model">hard see how to fit it into our model</a>, especially since (unfortunately) we&rsquo;d gradually sprouted quite a bit of global state (go on, boo all you like!). Having talked to a number of people who introduced Component into &ldquo;legacy&rdquo; Clojure applications, I began to suspect that as long as the <code>start</code> and <code>stop</code> lifecycle methods managed that global state, it wouldn&rsquo;t be too painful to introduce it piecemeal into our code base.</p>

<p>We still have global state (go on, boo again!) but we&rsquo;re slowly moving away from it now and we have some processes that have &ldquo;inverted&rdquo; and are now entirely managed by Component. One of the side effects of moving to Component is that you need to <code>start</code> your system after you fire up your REPL. It&rsquo;s great being able to <code>start</code> and <code>stop</code> your application inside the REPL (we&rsquo;re not quite at the Nirvana of refreshing all our namespaces due to that pesky global state, but we&rsquo;re on track). On the other hand, after years of just firing up a REPL and going to work, it takes some getting used to and seeing the message that our database connections have not been started became fairly familiar for the first few days. OK, weeks.</p>

<p>One of the nice things about Boot is that if you want functions available in the REPL, in your <code>boot.user</code> namespace, you simply define them in your <code>build.boot</code> file. This allows us to follow <a href="http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded">Stuart&rsquo;s &ldquo;Clojure Reloaded&rdquo; workflow</a> with minimal effort. Having the machinery in <code>build.boot</code> to work with Component also lends itself to using that lifecycle in your tasks. That&rsquo;s good hygiene and encourages you to think about packaging functionality into Components which fail into a natural <code>start</code> / <code>stop</code> rhythm around the Boot task pipeline architecture which also has a natural start (followed by other tasks in the pipeline) and then a natural stop. In some ways, Boot and Component are &ldquo;made for each other&rdquo;:</p>

<pre><code>(deftask my-component-task
  "A Component-based task."
  [...]
  (let [my-task (make-task-component ...)]
    (fn [next-handler]
      (fn [fileset]
        (let [app (component/start my-task)]
          ... ; work is done with app here
          (let [fileset' (... fileset)
                fileset' (commit! fileset')
                result   (next-handler fileset')]
            ... ; side effects are performed with app here
            (component/stop app)
            result)))))))
</code></pre>

<p>The final piece of Boot-ness I want to mention in this post is how we&rsquo;ve shifted some of our general shell commands from Ant to Boot. Here&rsquo;s an example of how we invoke Grunt from Boot &ndash; a similar pattern is followed for other shell commands:</p>

<pre><code>(defn ws-root []
  (System/getProperty "user.dir"))

(deftask grunt
  "Run Grunt (in www)."
  []
  (require '[clojure.java.shell :as sh])
  (let [sh (resolve 'sh/sh)]
    (with-pass-thru fs
      (let [{:keys [exit out err]} (sh "grunt" :dir (str (ws-root) "/www"))]
        (println out)
        (when-not (zero? exit)
          (println err)
          (throw (ex-info "Grunt failed." {:exit exit})))))))
</code></pre>

<p>I&rsquo;ll probably post about Boot again when we&rsquo;ve finally laid Ant to rest, and talk about any interesting things we run into during that last sprint.</p>
]]></content>
  </entry>
  
</feed>
