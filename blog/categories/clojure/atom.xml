<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Clojure | An Architect's View]]></title>
  <link href="http://corfield.org/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://corfield.org/"/>
  <updated>2019-12-31T20:49:45-08:00</updated>
  <id>http://corfield.org/</id>
  <author>
    <name><![CDATA[Sean Corfield]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Happy New Releases!]]></title>
    <link href="http://corfield.org/blog/2019/12/31/releases/"/>
    <updated>2019-12-31T15:59:59-08:00</updated>
    <id>http://corfield.org/blog/2019/12/31/releases</id>
    <content type="html"><![CDATA[<h1>Wrapping Up 2019</h1>

<p>It&rsquo;s been a while since I blogged about the projects I maintain so I figured New Year&rsquo;s Eve 2019 was a good time to provide an update!</p>

<h2>jkk/honeysql 0.9.8</h2>

<p>Lots of bug fixes, some enhancements (<code>composite</code>, <code>truncate</code>), and some documentation enhancements.</p>

<p>See the <a href="https://github.com/jkk/honeysql/blob/master/CHANGES.md">change log</a> for more details.</p>

<h2>org.clojure/core.cache 0.8.2</h2>

<p>Add <code>clojure.core.cache.wrapped</code> to make using the library easier!</p>

<p>See the <a href="https://github.com/clojure/core.cache/blob/master/README.md#change-log">change log</a> for more details.</p>

<h2>org.clojure/core.memoize 0.8.2</h2>

<p>Bug fixes and a new <code>memoizer</code> function that makes it easier to define custom function caches.</p>

<p>See the <a href="https://github.com/clojure/core.memoize/blob/master/README.md#change-log">change log</a> for more details.</p>

<h2>org.clojure/java.data 0.1.5</h2>

<p>Yup, I took over maintenance of this in October!</p>

<p><code>set-properties</code> to set arbitrary properties post-construction, constructor argument support, numerous bug fixes and reflection warnings addressed.</p>

<p>See the <a href="https://github.com/clojure/java.data/blob/master/README.md#change-log">change log</a> for more details.</p>

<h2>org.clojure/java.jdbc 0.7.11</h2>

<p>This library is officially &ldquo;stable&rdquo; and no longer being actively maintained beyond critical bug fixes &ndash; please consider migrating to <code>seancorfield/next.jdbc</code> (see below).</p>

<p>That said, this got the same transaction rollback exception edge case fix and Turkish locale fix that <code>next.jdbc</code> already had.</p>

<p>See the <a href="https://github.com/clojure/java.jdbc/blob/master/README.md#change-log">change log</a> for more details.</p>

<h2>seancorfield/clj-new 0.8.2</h2>

<p>AOT compilation in <code>app</code> uberjar, <code>pom.xml</code> generation, <code>:uberjar</code> in <code>app</code> and <code>:jar</code> in <code>lib</code> and <code>template</code> projects, <code>-?</code> / <code>--query</code> option to explain what <code>clj-new</code> will attempt to do, <code>-e</code> / <code>--env</code> option to define &ldquo;environment&rdquo; variables that set substitution values in project templates, dependency updates, documentation improvements.</p>

<p>See the <a href="https://github.com/seancorfield/clj-new/blob/master/CHANGELOG.md">change log</a> for more details.</p>

<h2>seancorfield/depstar 0.4.2</h2>

<p>Support for Multi-Release JARs, AOT compilation for uberjars (with <code>pom.xml</code>), JDK 11 support, better handling of unknown file types.</p>

<p>See the <a href="https://github.com/seancorfield/depstar#changes">change log</a> for more details.</p>

<h2>seancorfield/next.jdbc 1.0.13</h2>

<p><code>next.jdbc.prepare/statement</code> and support for <code>java.sql.Statement</code>, arbitrary <code>Connection</code> and <code>Statement</code> property support, fix transaction rollback exception edge case (thank you Jepsen!), expose SQL builders, now tested against MS SQL Server and MySQL (formally), provide additional date/time/timestamp conversion support, CLOB support, <code>:jdbcUrl</code> support, HugSQL quick start guide, result set builder adapters, expanded Tips &amp; Tricks, lots of documentation enhancements!</p>

<p>See the <a href="https://github.com/seancorfield/next-jdbc/blob/master/CHANGELOG.md">change log</a> for more details.</p>

<h2>seancorfield/dot-clojure</h2>

<p>If you getting started with the <a href="https://clojure.org/guides/deps_and_cli">Clojure CLI and <code>deps.edn</code></a> then you might want to check out my <a href="https://github.com/seancorfield/dot-clojure">.clojure/deps.edn file</a> which contains a lot of useful aliases and hints &amp; tips to get you up and running with a powerful set of composable tools: create new projects, start various types of REPLs, run tests &ndash; against multiple versions of Clojure, build JARs and uberjars, benchmark your code, check for outdated dependencies, and more!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Do You Use clojure.spec]]></title>
    <link href="http://corfield.org/blog/2019/09/13/using-spec/"/>
    <updated>2019-09-13T04:00:00-07:00</updated>
    <id>http://corfield.org/blog/2019/09/13/using-spec</id>
    <content type="html"><![CDATA[<p>An interesting Clojure question came up on Quora recently and I decided that <a href="https://www.quora.com/If-you-use-Clojure-Spec-how-do-you-use-it-Do-you-tend-to-put-all-your-specs-in-one-place-or-distribute-them-through-the-modules-of-your-program/answer/Sean-Corfield?srid=upNN">my answer to &ldquo;how do you use clojure.spec&rdquo;</a> there should probably be a blog post so that folks without a Quora account can still read it. <em>[If you do have a Quora account, feel free to read it there instead and upvote it!]</em><!-- more --></p>

<p>The original question on Quora was:</p>

<blockquote><p>If you use Clojure Spec, how do you use it? Do you tend to put all your specs in one place or distribute them through the &ldquo;modules&rdquo; of your program?</p></blockquote>

<p>Here&rsquo;s what I wrote, back in August 2019:</p>

<p>We&rsquo;ve been using Spec very heavily at work since the first alpha builds appeared. We use Spec in a number of ways: we use it for data validation (production), we use it for test data generation for example tests and for generative testing of functions (as well as generative scenario testing &ndash; more below), we use it at dev time as a checker for function calls (instrumentation) as well as for deriving code from the specs of data structures.</p>

<p><strong>Data validation</strong></p>

<p>We write specs for our API inputs and these specs live in their own namespace, along with the predicates needed for the specs. We <code>s/conform</code> the inputs against the specs and test the result with <code>s/invalid?</code> If the inputs conformed, we process the conformed data, else we use <code>s/explain-data</code> and then a heuristic algorithm to turn the explained failure back into an error code and message for API consumers. Note that we actually do some coercion of string inputs into basic data types via some of these specs &ndash; this is not considered good practice by some people but we&rsquo;ve found it very convenient for this use case.</p>

<p>We make sure nearly all of these API input specs will generate so that we can use them to generate test data for example-based tests (next section) or generative testing of some APIs (this isn&rsquo;t practical for a lot of API endpoints but it can help in a few cases).</p>

<p><strong>Test data generation</strong></p>

<p>As noted above, we use the API input specs &ndash; and other specs &ndash; to generate some test data for example-based tests. We use this approach where we want a certain amount of random &ldquo;good&rdquo; data to throw at functions in general, when we only need to control a couple of the arguments or a couple of fields in those arguments &ndash; the randomly-generated data tends to be fairly &ldquo;edge case&rdquo; so it&rsquo;s a good test of robustness (e.g., strings that include Unicode characters, generated from a regex using Gary Fredericks' test.chuck library).</p>

<p><strong>Generative testing of functions</strong></p>

<p>For some &ldquo;key&rdquo; functions, we&rsquo;ll write specs that include <code>:ret</code> and/or <code>:fn</code> and we&rsquo;ll test these generatively. The specs live in the same namespace as the functions, usually immediately above the function they are for. Some of these generative checks are run as part of our main test suite (so they are run every time). Some are too slow for that and the <code>check</code> calls live in <code>(comment ,,,)</code> to be run manually when we&rsquo;ve been working on the function in question (we use Rich Comment Forms a lot for code that is convenient for our development workflow but does not really constitute test code).</p>

<p><strong>Generative scenario testing</strong></p>

<p>This might be an unusual use of specs but I think it&rsquo;s potentially an important one. If you have an interactive application, you will have a number of paths through it that your users can take to get to certain known states. If you think of the paths as collections of user-generated events then you can write a spec for those (valid) paths through the application and you can then rely on spec to generate events that you can use to drive your application and then verify the end state. These specs live in the tests where they are needed.</p>

<p><strong>Development time checking</strong></p>

<p>This is a pretty basic, standard use of spec. Write specs for data structures and some functions. The latter live with the functions (<code>s/fdef</code> immediately above <code>defn</code>). The former may live with the functions if they are tightly coupled to them or in their own namespace if they are more concerned with data structures used by various namespaces. Then you instrument those functions while you are working in the REPL, doing day-to-day development.</p>

<p>Another use of specs in development/testing is within the tests where we want to verify that results from functions are the expected &ldquo;shape&rdquo; in example-based tests. In this case we write specs for &ldquo;good&rdquo; results and &ldquo;bad&rdquo; results and we use <a href="https://github.com/clojure-expectations/clojure-test">clojure-expectations/clojure-test</a> as an add-on for <code>clojure.test</code> so that we can <code>(expect ::some-spec (a-function call here))</code> &ndash; a more expressive form of <code>clojure.test/is</code>.</p>

<p><strong>Deriving code from specs</strong></p>

<p>In this case we write specs for data structures, such as rows in database tables, and then we generate named CRUD operations and supporting functionality from the specs themselves &ndash; using macros that take specs as input with some control parameters and expand into a number of <code>defn</code> and other forms. The important aspect of this is that the spec is the &ldquo;system of record&rdquo; for the data structure: it can be used for validation, test data generation, and as the source for the keys and &ldquo;types&rdquo; that shape the functions needed to operate on them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Release! Release! Release!]]></title>
    <link href="http://corfield.org/blog/2019/08/07/releases/"/>
    <updated>2019-08-07T08:30:00-07:00</updated>
    <id>http://corfield.org/blog/2019/08/07/releases</id>
    <content type="html"><![CDATA[<h1>Lots of Releases</h1>

<p>Over the last week or so I&rsquo;ve released minor updates to several of the projects I maintain, so I thought it would be nice to have a summary blog post rather than a scattering of minor announcements.</p>

<h2>clj-time 0.15.2</h2>

<p>Add type hints, fix a bug in <code>overlaps?</code>, improve tests and documentation.</p>

<p>See the <a href="https://github.com/clj-time/clj-time/blob/master/ChangeLog.md">change log</a> for more details.</p>

<h2>jkk/honeysql 0.9.5</h2>

<p>Support JDK11 for dev/test, support Turkish language users, enhance <code>format-predicate</code> to match <code>format</code> (<code>parameterizer</code>).</p>

<p>See the <a href="https://github.com/jkk/honeysql/blob/master/CHANGES.md">change log</a> for more details.</p>

<h2>seancorfield/clj-new 0.7.7</h2>

<p>Pin Clojure (and <code>test.check</code>) version in generated projects instead of using <code>"RELEASE"</code>.</p>

<p>See the <a href="https://github.com/seancorfield/clj-new/blob/master/CHANGELOG.md">change log</a> for more details.</p>

<h2>seancorfield/depstar 0.3.1</h2>

<p>Add <code>-m</code> / <code>--main</code> option to override <code>Main-Class</code> in generated manifest.</p>

<p>See the <a href="https://github.com/seancorfield/depstar#changes">change log</a> for more details.</p>

<h2>seancorfield/next.jdbc 1.0.5</h2>

<p><code>plan</code>&rsquo;s &ldquo;mapified&rdquo; <code>ResultSet</code> is now a full <code>IPersistentMap</code> implementation which adds support for <code>cons</code>, <code>count</code>, <code>dissoc</code>, <code>empty</code>, etc. Continued improvements to documentation.</p>

<p>See the <a href="https://github.com/seancorfield/next-jdbc/blob/master/CHANGELOG.md">change log</a> for more details.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Next.JDBC to 1.0.0 and Beyond!]]></title>
    <link href="http://corfield.org/blog/2019/07/04/next-jdbc/"/>
    <updated>2019-07-04T03:00:00-07:00</updated>
    <id>http://corfield.org/blog/2019/07/04/next-jdbc</id>
    <content type="html"><![CDATA[<h1>next.jdbc 1.0.0 and 1.0.1</h1>

<p>First off, <a href="https://github.com/seancorfield/next-jdbc/releases/tag/v1.0.0">seancorfield/next.jdbc 1.0.0</a> was released on June 13th, 2019 (and I <a href="https://clojureverse.org/t/next-jdbc-1-0-0-the-gold-release/4379">announced it on ClojureVerse</a> but did not blog about it), and yesterday I released <a href="https://github.com/seancorfield/next-jdbc/releases/tag/v1.0.1">seancorfield/next.jdbc 1.0.1</a> which is mostly documentation improvements.</p>

<p>Someone recently commented that this blog had the <a href="https://corfield.org/blog/2019/06/04/next-jdbc/">Release Candidate announcement</a> on June 4th and was surprised I didn&rsquo;t &ldquo;make a big deal&rdquo; about the &ldquo;gold&rdquo; release. The 1.0.0 release is a <strong>big deal</strong> and this blog post is about that &ndash; what it&rsquo;s taken to get here and what&rsquo;s to come.<!-- more --></p>

<h2>clojure.contrib.sql</h2>

<p>I learned Clojure back in 2010 and started using it at work in early 2011. For us to use it in production, we needed JDBC support but <code>clojure.contrib.sql</code> was not being actively maintained at that point and the Clojure 1.3 release was in its Alpha phase. Part of the 1.3 release cycle involved <a href="https://clojure.org/community/contrib_history">breaking up the &ldquo;Monolithic Contrib&rdquo; from the 1.2 release and finding new maintainers</a> in order for its parts to move forward. That&rsquo;s how I became the maintainer of <a href="https://github.com/clojure/java.jdbc"><code>clojure.java.jdbc</code></a> &ndash; <code>clojure.contrib.sql</code>&rsquo;s new name and home. <code>clojure.java.jdbc</code> started life with an 0.0.1 release.</p>

<h2>clojure.java.jdbc</h2>

<p>The 0.0.x releases mostly focused on compatibility with more databases and ease of use enhancements.</p>

<p>0.1.0 rewrote the result set handling to use regular Clojure hash maps instead of the deprecated <code>struct-map</code> machinery, hence the bump in version numbers. The 0.1.x releases continued to expand database support, expand the API, and fix bugs.</p>

<p>0.2.0 merged the internal namespace into the main <code>clojure.java.jdbc</code> namespace and adjusted the visibility (and naming) of several symbols, hence the bump in version numbers. The 0.2.x releases continued the path of improving database support, improving usability, fixing bugs, and some performance improvements.</p>

<p>0.3.0 was a fairly massive overhaul of the API &ndash; these were definitely breaking changes, as most of the existing API was deprecated (based on the dynamic <code>*db*</code> variable), and a new API introduced (which accepted the db spec everywhere as an argument, including the first versions of <code>insert!</code>, <code>query</code>, <code>update!</code>, <code>delete!</code>, and <code>execute!</code>). 0.3.0 also introduced <code>IResultSetReadColumn</code> and <code>ISQLValue</code> as extension points. Prerelease builds of 0.3.0 introduced a mini-DSL for building SQL but that was removed before the gold release &ndash; the DDL support stayed, however. The 0.3.x releases mostly focused on bug releases after the big upheaval in the API, and adding support for more and more options. The modern &ldquo;db-spec&rdquo; with <code>:dbtype</code> and <code>:dbname</code> was introduced during this time.</p>

<p>0.4.0 dropped support for Clojure 1.2 and the 0.4.x releases fixed bugs, broadened database support, and added yet more options.</p>

<p>0.5.0 dropped support for Clojure 1.3 and 0.5.5 started the shift from &ldquo;named&rdquo; arguments (unrolled keyword arguments) to passing options in a single hash map, which makes it much easier to compose function calls. The 0.5.x releases continued deprecation of the unrolled keyword arguments.</p>

<p>0.6.0 removed all deprecated APIs and signatures. This was a pretty volatile time to be using <code>clojure.java.jdbc</code>. There was a 0.6.1 release but the upcoming 0.6.2 release became a series of 0.7.0 prerelease builds as I replumbed the functions to correctly pass options through the entire chain, and dropped support for Clojure 1.4, 1.5, and finally 1.6&hellip; This also saw the introduction of <code>reducible-query</code> (which laid the groundwork for <code>next.jdbc</code>).</p>

<p>By the time 0.7.0 was released, I was beginning to think more seriously about a 1.0.0 release. The 0.7.x releases continued to expand database support, to add more and more options, and also started to look at performance improvements.</p>

<h2>Contrib Evolving</h2>

<p>I&rsquo;d solicited feedback from the Clojure/core folks about what it would mean for a 1.0.0 release at various points, starting as far back as the 0.3x series of releases, and I&rsquo;d been folding that feedback into the various changes over time. Also, over time, it became clear that Clojure/core were less worried about placing restrictions on how maintainers ran their projects. Some Contrib libraries had their 1.0.0 releases and continued on, some were still in the 0.0.x phase, others run the gamut from 0.1.x to 0.10.x.</p>

<p>It&rsquo;s good to read <a href="https://clojure.org/news/2012/02/17/clojure-governance">Stuart Sierra&rsquo;s post from 2012</a> about how Clojure (and Contrib&rsquo;s) governance evolved over the years, as well as the <a href="https://clojure.org/community/contrib_libs">current state of Contrib libraries</a>. In addition to the recent clarifications about Contrib&rsquo;s purpose and governance, we&rsquo;ve seen <code>clojure.tools.nrepl</code> fork back out of Contrib as <a href="https://github.com/nrepl/nrepl">nrepl/nrepl</a> and a lot of adjustment in tooling to adapt to the new group, artifact, and namespace names.</p>

<p>It was in this environment that I continued to think about what a 1.0.0 release of <code>clojure.java.jdbc</code> should be. At Clojure/conj (2018), I was excited about <a href="https://github.com/cognitect-labs/REBL-distro">REBL</a> and <code>datafy</code>/<code>nav</code>, and I introduced <a href="https://corfield.org/blog/2018/12/03/datafy-nav/">experimental support for all that in <code>clojure.java.jdbc</code></a>. I was also thinking about <code>clojure.spec</code> and the shift to qualified keywords and the increased use of transducers and the focus on simplicity and consistency&hellip;</p>

<h2>The Birth of next.jdbc</h2>

<p>It was around that point that I realized that I wouldn&rsquo;t really be comfortable declaring a 1.0.0 release on <code>clojure.java.jdbc</code>: there was no natural &ldquo;end state&rdquo; and it had become large and complex (and slow in places) &ndash; and I couldn&rsquo;t realistically change that without making a whole &lsquo;nother round of breaking changes. But this time I heeded <a href="https://www.youtube.com/watch?v=oyLBGkS5ICk">Rich&rsquo;s advice about accretion and fixation</a> and started to design the &ldquo;next&rdquo; version of <code>clojure.java.jdbc</code> not as a series of (breaking) changes to what already existed but as a completely new set of functions built on a completely new set of implementations, based on what I&rsquo;d learned from nearly eight years of maintaining <code>clojure.java.jdbc</code>.</p>

<p>I talk about my <a href="https://github.com/seancorfield/next-jdbc#motivation">motivation for this new JDBC wrapper</a> in the project README but I&rsquo;ll provide a bullet point recap here as well:</p>

<ul>
<li>Improve performance,</li>
<li>Provide a &ldquo;modern&rdquo; Clojure approach/API,</li>
<li>Provide a simpler library/API.</li>
</ul>


<p>I spent a month or so sketching out what this new version of the library would look like and how it would behave using a local git repository (stored on OneDrive). I first mentioned that I was working on it in early January (in <a href="https://clojureverse.org/t/what-http-server-library-to-use/3423/29?u=seancorfield">a thread about HTTP servers on ClojureVerse</a>, of all places) and moved it into a private GitHub repository, once I had usable code. Over the next three months, I continued to develop it until the first public release on April 21st: 1.0.0-alpha8. Over the next month, I gathered feedback from anyone who was willing to use it, making a few small adjustments in the API, until the first stable release on May 25th: 1.0.0-beta1.</p>

<p>One of the key decisions I had to make was whether this would become new namespaces inside <code>clojure.java.jdbc</code> in Contrib or live standalone somewhere &ndash; because I viewed it very much as the &ldquo;next version&rdquo; of that Contrib library. I was surprised that no one seemed to care if a library was published under someone&rsquo;s name as a group ID, nor even if the namespaces themselves contained someone&rsquo;s name. I&rsquo;d viewed Contrib&rsquo;s well-maintained Continuous Integration system and automated documentation generator as pros, along with my perception that Contrib libraries were easy to find and had some stamp of &ldquo;authority&rdquo; by virtue of being in the <code>clojure</code> GitHub organization &ndash; but I seemed to be very much in the minority in that perception. Once I had CI set up for <a href="https://circleci.com/gh/seancorfield/next-jdbc"><code>next.jdbc</code> on CircleCI</a> and auto-generated <a href="https://cljdoc.org/d/seancorfield/next.jdbc">documentation for <code>next.jdbc</code> on cljdoc.org</a>, I decided that <code>seancorfield/next.jdbc</code> was going to live on, outside Contrib.</p>

<h2>Beta 1 and Stability</h2>

<p>I mentioned above that I considered Beta 1 to be the first stable release. Having gone through so many breaking changes with <code>clojure.java.jdbc</code> and having listened to Rich (and others in the Clojure community) talk about the need for backward compatibility and the futility of semantic versioning, it was important to me that I could draw a line in the sand at some point and say &ldquo;no more breaking changes&rdquo;. I decided that the move from Alpha to Beta should be that line for <code>next.jdbc</code> and the last breaking change was renaming <code>reducible!</code> to <code>plan</code> as part of the beta release &ndash; indeed, that was the gating factor for exiting the alpha phase of development.</p>

<p>My goal is to never break backward compatibility across future versions of <code>next.jdbc</code> &ndash; only adding new functionality (and fixing things that are clearly broken). I expect future versions to appear slowly and contain very few additional features, perhaps focusing mostly on improving the documentation in response to questions from users of the library.</p>

<h2>Wrapping Up</h2>

<p>I couldn&rsquo;t have made <code>next.jdbc</code> without a lot of lessons learned from eight years of maintaining <code>clojure.java.jdbc</code> and all the feedback from the community &ndash; both on <code>clojure.java.jdbc</code> itself and during the alpha phase of <code>next.jdbc</code>&rsquo;s development. It&rsquo;s faster, more modern, and simpler than <code>clojure.java.jdbc</code>. It embraces the host platform by being based on JDBC types directly, but offers value beyond being &ldquo;just&rdquo; a wrapper for those types and their methods. It looks to the future by yielding qualified keywords by default, supporting <code>datafy</code>, <code>nav</code>, and focusing on reducing/transducing as a core part of the main API (via <code>plan</code>).</p>

<p>I consider <code>next.jdbc</code> to be the 1.0.0 release that <code>clojure.java.jdbc</code> was never going to achieve.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Next.JDBC Release Candidate 1]]></title>
    <link href="http://corfield.org/blog/2019/06/04/next-jdbc/"/>
    <updated>2019-06-04T11:30:00-07:00</updated>
    <id>http://corfield.org/blog/2019/06/04/next-jdbc</id>
    <content type="html"><![CDATA[<h1>seancorfield/next.jdbc 1.0.0-rc1</h1>

<p><code>next.jdbc</code> &ndash; the &ldquo;next generation&rdquo; of <code>clojure.java.jdbc</code> &ndash; is a modern Clojure wrapper for JDBC. The first Release Candidate is now available to test &ndash; containing only accretive and fixative changes from Beta 1. The API should be considered stable enough for production usage.</p>

<p><a href="https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-rc1/doc/readme">https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-rc1/doc/readme</a></p>

<p>The focus of this release is providing more flexibility in result set builders, so that it is easier to implement your own naming strategies, via new builders that accept <code>:label-fn</code> and <code>:qualifier-fn</code> options. These mirror the <code>:column-fn</code> and <code>:table-fn</code> options used in <code>next.jdbc.sql</code> &ndash; which are updated versions of <code>clojure.java.jdbc</code>&rsquo;s <code>:entities</code> option. These new builder options are updated versions of <code>clojure.java.jdbc</code>&rsquo;s <code>:identifiers</code> option.</p>

<h2>Changes since Beta 1</h2>

<ul>
<li>Fix #24 by adding return type hints to <code>next.jdbc</code> functions.</li>
<li>Fix #22 by adding <code>next.jdbc.optional</code> with six map builders that omit <code>NULL</code> columns from the row hash maps.</li>
<li>Documentation improvements (#27, #28, and #29), including changing &ldquo;connectable&rdquo; to &ldquo;transactable&rdquo; for the <code>transact</code> function and the <code>with-transaction</code> macro (for consistency with the name of the underlying protocol).</li>
<li>Fix #30 by adding <code>modified</code> variants of column name functions and builders. The <code>lower</code> variants have been rewritten in terms of these new <code>modified</code> variants. This adds <code>:label-fn</code> and <code>:qualifier-fn</code> options that mirror <code>:column-fn</code> and <code>:table-fn</code> for row builders.</li>
</ul>


<p>Please take it for a test drive and let me know if you run into any problems via <a href="https://github.com/seancorfield/next-jdbc/issues">GitHub issues</a> or in the <a href="https://clojurians.slack.com/messages/C1Q164V29/details/"><code>#sql</code> channel on the Clojurians Slack</a> or the <a href="https://clojurians.zulipchat.com/#narrow/stream/152063-sql"><code>#sql</code> stream on the Clojurians Zulip</a>.</p>
]]></content>
  </entry>
  
</feed>
