<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Clojure | An Architect's View]]></title>
  <link href="http://corfield.org/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://corfield.org/"/>
  <updated>2019-04-21T23:07:26-07:00</updated>
  <id>http://corfield.org/</id>
  <author>
    <name><![CDATA[Sean Corfield]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Next.JDBC]]></title>
    <link href="http://corfield.org/blog/2019/04/21/next-jdbc/"/>
    <updated>2019-04-21T16:00:00-07:00</updated>
    <id>http://corfield.org/blog/2019/04/21/next-jdbc</id>
    <content type="html"><![CDATA[<h1>seancorfield/next.jdbc 1.0.0-alpha8</h1>

<p>I&rsquo;ve talked about this in a few groups &ndash; it&rsquo;s been a long time coming. This is the &ldquo;next generation&rdquo; of <code>clojure.java.jdbc</code> &ndash; a modern wrapper for JDBC, that focuses on <code>reduce</code>/transducers, qualified-keywords, and <code>datafy</code>/<code>nav</code> support (so, yes, it requires Clojure 1.10).</p>

<p><a href="https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-alpha8/doc/readme">https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-alpha8/doc/readme</a></p>

<p><em>The next generation of <code>clojure.java.jdbc</code>: a new low-level Clojure wrapper for JDBC-based access to databases.</em>  It&rsquo;s intended to be both faster and simpler than <code>clojure.java.jdbc</code> and it&rsquo;s where I intend to focus my future energy, although I have not yet decided whether it will ultimately be a new set of namespaces in the Contrib lib or a separate, standalone OSS library!</p>

<p>At this point, I&rsquo;m looking for feedback on the API and the approach (as well as bugs, performance issues, etc). Please take it for a spin and let me know what you think via <a href="https://github.com/seancorfield/next-jdbc/issues">GitHub issues</a> or in the <a href="https://clojurians.slack.com/messages/C1Q164V29/details/"><code>#sql</code> channel on the Clojurians Slack</a> or the <a href="https://clojurians.zulipchat.com/#narrow/stream/152063-sql"><code>#sql</code> stream on the Clojurians Zulip</a>.</p>

<p><em>The group/artifact ID will change at some point:</em> and the actual namespaces will too, but I will try to make that as painless as possible when I take this out of the alpha phase.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojurians Slack Alternatives]]></title>
    <link href="http://corfield.org/blog/2019/02/11/clojurians-slack-alternatives/"/>
    <updated>2019-02-11T04:10:00-08:00</updated>
    <id>http://corfield.org/blog/2019/02/11/clojurians-slack-alternatives</id>
    <content type="html"><![CDATA[<p>Daniel Compton has continued his excellent trend of
<a href="https://danielcompton.net/2019/02/06/clojure-survey-2019">writing an analysis of the State of Clojure survey comments</a>
and one of the comments in his <strong>Community</strong> section stood out for me:</p>

<blockquote><p>&ldquo;I suggest moving off of slack to a more accessible chat system. Losing history is a bad thing. Check out discord or matrix or gitter or mattermark or any other number of tools made for this purpose.&rdquo;</p></blockquote>

<!-- more -->


<p>The <a href="https://clojurians.slack.com/">Clojurians Slack</a> <em>[sign up <a href="http://clojurians.net/">here</a>]</em>
started as a small experiment about four years ago and has been far more
successful than anyone could have imagined, with around 15K members signed up
and around 1,700 members considered &ldquo;active&rdquo; on a weekly basis (which means it
would cost almost $9K per month to run this as a paid service!).</p>

<p>A perennial complaint about Slack&rsquo;s free plan is that it limits the accessible
message history to just the most recent 10K messages. In a busy Slack like
Clojurians that limit is hit after three or four days, heavily limiting the
ability to refer back to conversations or to use the massive amount of
&ldquo;knowledge&rdquo; shared there for reference &ndash; exactly as noted in the comment above.</p>

<p>Why that comment inspired me to write this post is that most of the suggested
communities already exist, and have been around for quite some time. Two of
them are linked from the right hand column of the <a href="https://www.reddit.com/r/Clojure/">Clojure sub-Reddit</a>
but here&rsquo;s the list directly:</p>

<ul>
<li><a href="https://discordapp.com/invite/v9QMy9D">Discord</a></li>
<li><a href="https://gitter.im/clojure/general">Gitter</a> &ndash; there are several Clojure rooms on Gitter, most of them are linked to open source projects on GitHub</li>
<li><a href="https://riot.im/app/#/room/#clojure:matrix.org">Matrix/Riot</a></li>
<li>Mattermost &ndash; I&rsquo;m not sure if anyone has set up a Clojure community on Mattermost but several people have advocated for it</li>
</ul>


<p>The &ldquo;original&rdquo; online Clojure community still exists and is still active on IRC
(freenode), of course, and there&rsquo;s also <a href="https://braid.chat/">Braid</a> (written in
Clojure/ClojureScript!).</p>

<p>I was a bit surprised that the commenter did not mention <a href="https://clojurians.zulipchat.com/">Clojurians on Zulip</a>
because that community, started back in early November 2018, already has five hundred
members and seems, to me, like the most capable alternative to Slack. It&rsquo;s open
source, <a href="https://zulipchat.com/for/open-source/">hosted for free to open source communities</a>,
and &ldquo;has a significantly larger and more active development community than other
modern open source group chat solutions like Mattermost, Rocket.Chat, and matrix.org.&rdquo;
Read their <a href="https://zulipchat.com/why-zulip/">Why Zulip? page</a> for more
information about the service and how it compares (specifically to Slack).</p>

<p>One-way bridging between select Slack channels and Zulip streams has been in
place for a while and currently about fifty of the most popular channels on
Slack are available to read in Zulip streams, along with many other active
streams in Zulip. This means you can try Zulip without missing out on Slack
conversations &ndash; some people prefer Zulip&rsquo;s UI just for reading Slack messages!</p>

<p>Clojurians on Slack isn&rsquo;t going away &ndash; a lot of people love the UI and don&rsquo;t
consider the message history limit to be a big deal &ndash; and if you&rsquo;re already
using Slack for work, then it makes perfect sense to also use that for your
Clojure community fix (since you only need one chat client open). The Slack
community isn&rsquo;t &ldquo;official&rdquo; in any way, and you&rsquo;re all welcome to try other
chat clients, but if you feel strongly about open source and unlimited search
history, check out <a href="https://clojurians.zulipchat.com/">Clojurians on Zulip</a>
and if you like it, promote it and encourage other Clojurians to join you
there.</p>

<p>Me? I&rsquo;m one of the long-time admins/moderators of Clojurians on Slack, but I&rsquo;ve
also tried each and every one of the alternatives that various community members
have set up over the last four years. <a href="https://clojurians.zulipchat.com/">Clojurians on Zulip</a>
is the one I&rsquo;ve found myself most active in and the only alternative chat client
that I always have open at this point!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Atom, Chlorine, and Windows]]></title>
    <link href="http://corfield.org/blog/2019/01/22/atom-chlorine-windows/"/>
    <updated>2019-01-22T12:15:00-08:00</updated>
    <id>http://corfield.org/blog/2019/01/22/atom-chlorine-windows</id>
    <content type="html"><![CDATA[<p>About a month ago, I was <a href="http://corfield.org/blog/2018/12/19/atom-chlorine/">praising Chlorine, the new Clojure package for
Atom</a> and I&rsquo;ve been using
it, day-in, day-out, for all my Clojure development. On a Mac, that&rsquo;s
straightforward because I start a Socket REPL on the Mac and I run Atom on the
Mac so when I connect via Chlorine and issue the <code>Chlorine: Load File</code>
command (via <code>Ctrl-, f</code> in my keymap), it sends <code>(load-file "/path/to/file.clj")</code>
to the REPL, for the file being edited, and that is evaluated and loads the
source from disk and compiles it. On Windows&hellip;<!-- more --> Well, on Windows
there are a few obstacles to this workflow.</p>

<p>The first obstacle (for me) is that <code>clj</code> doesn&rsquo;t run on Windows and that&rsquo;s
what I use for everything Clojure on a Mac and on Linux now. There&rsquo;s a
PowerShell implementation in progress but Windows has always been a bit of a
second-class citizen so it&rsquo;s still a ways off. But Windows has WSL (Windows
Subsystem for Linux) so I can
and do run (user-mode) Ubuntu on my Windows laptop and I do all of my Clojure
work on that&hellip;</p>

<p>&hellip;but that brings the second obstacle: file paths on Windows look like
<code>C:\path\to\file.clj</code> and under WSL they look like <code>/mnt/c/path/to/file.clj</code>.
That means your editor on Windows and your REPL on Linux don&rsquo;t quite speak the
same language.</p>

<p>Fortunately, the latest release of Chlorine, 0.0.8, has a &ldquo;smart&rdquo; <code>Load File</code>
command that will work with both a Windows-based Socket REPL and a WSL-based
Socket REPL! It wraps the call to <code>load-file</code> in logic that looks at the
requested file path and also at the
<code>user.dir</code> JVM property and if the former starts with a drive identifier and <code>:</code>,
and the latter does not, it assumes the REPL is running on WSL on Windows and
maps the file path appropriately.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chlorine: Clojure Integration for Atom]]></title>
    <link href="http://corfield.org/blog/2018/12/19/atom-chlorine/"/>
    <updated>2018-12-19T22:45:00-08:00</updated>
    <id>http://corfield.org/blog/2018/12/19/atom-chlorine</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been using the <a href="https://atom.io">Atom</a> editor for about two years now.
I switched from Emacs after Clojure/conj 2016, having seen
<a href="https://youtu.be/buPPGxOnBnk">Jason Gilman&rsquo;s talk about ProtoREPL</a> [video].
It may sound like
heresy, but I&rsquo;d never been happy with Emacs<!-- more --> &ndash; not 17.x back when I first
started using it, not 18.x, not 19.x when I first stopped using it, nor 24.x onward
when I came back to it after learning Clojure a few decades later. I built
several configurations from scratch, I tried several &ldquo;curated&rdquo; configurations,
none of them felt like &ldquo;home&rdquo;. Emacs just leeched too much of my development
time for my tastes. I wanted a simple, modern text editor, that offered a wide
variety of &ldquo;plugins&rdquo; and supported all the languages I used, with a sane set of
defaults. Atom &ndash; with ProtoREPL &ndash; seemed to be exactly what I was looking for!</p>

<p>And for two years, it has been my day-to-day development environment.</p>

<p>But it has been frustrating that ProtoREPL hasn&rsquo;t been getting a huge amount of
love lately. Two releases immediately after that Conj, eleven in the first
half of 2017, and just three since then (in a year and a half).
With the advent of Clojure 1.10 and
<a href="https://github.com/cognitect-labs/REBL-distro">REBL</a>, I wanted to extend
ProtoREPL so I could integrate REBL into my workflow, so I forked it and
hacked in <code>inspect-block</code> and <code>inspect-top-block</code> functionality (see the
<a href="https://github.com/seancorfield/proto-repl/compare/4b13ebf9d0f1e228ab7800c4bc54fe071bacf29e...master">commit log</a>). But it&rsquo;s written in
CoffeeScript and that made me sad.</p>

<p>I&rsquo;ve also had a bit of a long-running love/hate relationship with
<a href="https://github.com/nrepl/nrepl">nREPL</a> over its lifetime. Something about the
wire protocol and overall architecture of it just bothered me and I longed for
tooling built on what Clojure provides out-of-the-box. When I saw <code>prepl</code> drop
in the Clojure 1.10 development cycle, I was very excited: built-in support for
future tooling, on top of the Socket REPL we&rsquo;ve had for a few releases!</p>

<p>I&rsquo;d previously used <a href="https://github.com/Unrepl/unravel">Unravel</a> to interact
with several of our processes at work that spawn a Socket REPL and found that a
very pleasant experience (side-loading <a href="https://github.com/Unrepl/unravel">Compliment</a>
to provide auto-completion while typing).</p>

<blockquote><p>Unravel is a simple command-line client for Clojure REPLs. It is based on the unrepl protocol, so instead of relying on nREPL, unravel communicates with your Clojure process through a Socket Server REPL.</p></blockquote>

<p>&ldquo;instead of relying on nREPL&rdquo; was music to my ears &ndash; I wanted editor integration
that worked this way!</p>

<p>A few days ago, in a side-thread in the <code>#off-topic</code> channel on the
<a href="https://clojurians.slack.com">Clojurians Slack</a> (<a href="http://clojurians.net/">sign up here</a>),
that had started with a question about <a href="https://cursive-ide.com/">Cursive</a> vs
Emacs/CIDER, Maurício Szabo mentioned &ldquo;a (very experimental) package for Atom
that &hellip; uses socket repl&rdquo;. I was intrigued. Could this be what I&rsquo;d been
looking for?</p>

<p>That package is <a href="https://atom.io/packages/chlorine">Chlorine for Atom</a>.
I installed it immediately (and disabled ProtoREPL) so I could take it for a
spin! It&rsquo;s written in ClojureScript. It only needs a Socket REPL. It uses
unrepl to &ldquo;upgrade&rdquo; the REPL as needed. It uses Compliment for auto-completion.
I could connect it directly to various running processes and I could start
REBL up from the command-line with a Socket REPL and connect to that as well.
<strong>This</strong> was exactly the workflow I&rsquo;d been looking for!</p>

<p>Maurício has been awesome to work with and over the last few days he&rsquo;s added
the first version of &ldquo;go to definition&rdquo; as well as merging pull requests from
me to add support for running tests in a namespace or an individual test. I
have pull requests in for adding &ldquo;load file&rdquo; (it already had evaluate selection,
so you could &ldquo;select all + evaluate selection&rdquo; but I was used to &ldquo;load file&rdquo;
from ProtoREPL), and &ldquo;show source&rdquo;.</p>

<p>I&rsquo;ve also <a href="https://github.com/seancorfield/atom-chlorine/commit/b5c4ec4fbe2572a97882e595f6280fec15592114">ported across my &ldquo;inspect&rdquo; functions</a> from ProtoREPL so my entire,
day-to-day workflow with ProtoREPL is now possible with Chlorine, REBL, <code>clj</code>, and
a couple of aliases &ndash; and I have an eminently hackable editor plugin, written
in ClojureScript with a slick auto-compile, auto-reload workflow (thank you
Maurício!).</p>

<p>I&rsquo;m still looking forward to tooling based on <code>prepl</code> so the client libraries
can be even simpler and smaller but, for now, I&rsquo;m a very happy developer and
I&rsquo;m very pleased to see how the Clojure community continues to innovate around
tooling (which, yes, has needed a lot of love over the years!).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL NULL, S/nilable, and Optionality]]></title>
    <link href="http://corfield.org/blog/2018/12/06/null-nilable-optionality/"/>
    <updated>2018-12-06T03:30:00-08:00</updated>
    <id>http://corfield.org/blog/2018/12/06/null-nilable-optionality</id>
    <content type="html"><![CDATA[<p>Rich Hickey gave a very thought-provoking talk at Clojure/conj 2018
called <a href="https://www.youtube.com/watch?v=YR5WdGrpoug&amp;list=PLZdCLR02grLpMkEBXT22FTaJYxB92i3V3&amp;index=2">Maybe Not</a>, where he mused
on optionality and how we represent the absence of a value.<!-- more --></p>

<p>His talk covered many things, including how <code>clojure.spec/keys</code> currently
complects both structure and optionality (and his thoughts on fixing that
in a future version of <code>clojure.spec</code>), but his mention of <code>s/nilable</code> was what
triggered an &ldquo;ah-ha!&rdquo; moment for me.</p>

<p>At <a href="https://worldsinglesnetworks.com">World Singles Networks</a>, we deal with a lot
of data in SQL (specifically in Percona&rsquo;s fork of MySQL) and, in SQL, you represent
the absence of a value with <code>NULL</code> in a column. Columns that represent optional
data must be declared as nullable and when you read data from them with
<a href="https://github.com/clojure/java.jdbc">clojure.java.jdbc</a> you get hash map
entries in the rows that have <code>nil</code> values. If you&rsquo;re using <code>clojure.spec</code> to
describe your tables, rows, and columns, then you are going to have lots of
<code>s/nilable</code> specs &ndash; and now your &ldquo;optionality&rdquo; has been reified into <code>nil</code>
values, cast in the stone of your specs&hellip; which is clearly not an ideal situation!</p>

<p>This made me realize that <code>java.jdbc</code> probably should just omit keys whose
values represent SQL <code>NULL</code>. They are, after all, <em>optional</em> values rather than
truly <em>nilable</em> values.</p>

<p>That would be a potentially breaking change in behavior for <code>java.jdbc</code> users.
Sure, in most cases, if you have a hash map representing a row in a database
table, you&rsquo;re not really going to care whether <code>(:col row)</code> gives you <code>nil</code>
because <code>:col</code> maps to <code>nil</code> or because <code>row</code> doesn&rsquo;t contain <code>:col</code>. There are
use cases where it matters: <code>contains?</code>, row/column specs, tabular printing.</p>

<p>Along with changing the behavior of <code>NULL</code> columns and
<a href="http://corfield.org/blog/2018/12/03/datafy-nav/">supporting <code>datafy</code> and <code>nav</code></a>,
I have a lot of other changes that I&rsquo;d like to apply to <code>java.jdbc</code>, such as
automatically qualifying column keys with the table from which they came,
improving overall performance (by no longer converting <code>ResultSet</code> objects to
sequences of hash maps), dramatically simplifying and streamlining the options
that are available (since many of them are very rarely used), and focusing on a
reducible-first API. All of which would be breaking changes.</p>

<p>I&rsquo;ve learned a lot &ndash; about Clojure, idioms, and databases &ndash; over the seven
years that I&rsquo;ve been maintaining <code>org.clojure/java.jdbc</code>, and it is time for a
new namespace or perhaps even a completely new project, that offers a better
way to deal with SQL databases from Clojure! I&rsquo;ll be writing a series of blog
posts about the differences I envisage between the current de facto standard
JDBC wrapper and where I&rsquo;d like to go with this, so that I can get community
feedback on what should stay, what should change, and what should go. Stay tuned!</p>
]]></content>
  </entry>
  
</feed>
