<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Clojure | An Architect's View]]></title>
  <link href="http://corfield.org/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://corfield.org/"/>
  <updated>2018-12-03T18:06:29-08:00</updated>
  <id>http://corfield.org/</id>
  <author>
    <name><![CDATA[Sean Corfield]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clojure 1.10's Datafy and Nav]]></title>
    <link href="http://corfield.org/blog/2018/12/03/datafy-nav/"/>
    <updated>2018-12-03T09:20:00-08:00</updated>
    <id>http://corfield.org/blog/2018/12/03/datafy-nav</id>
    <content type="html"><![CDATA[<p>One of the more mysterious new features in Clojure 1.10 seems to be the pairing of <a href="https://github.com/clojure/clojure/blob/master/changes.md#26-datafy-and-nav"><code>datafy</code> and <code>nav</code></a> (and their underlying protocols, <code>Datafiable</code> and <code>Navigable</code>). Interest in these new functions has been piqued after Stuart Halloway showed off <a href="https://www.youtube.com/watch?v=c52QhiXsmyI&amp;list=PLZdCLR02grLpMkEBXT22FTaJYxB92i3V3&amp;index=3">REBL at Clojure/conj</a> (video). Stu presented this functionality as &ldquo;generalized laziness&rdquo;: <code>datafy</code> produces a &ldquo;data representation&rdquo; of things and <code>nav</code> lets you (lazily) navigate around that data.<!-- more --></p>

<p>The <a href="http://rebl.cognitect.com/">REBL</a> &ldquo;is a graphical, interactive tool for browsing Clojure data&rdquo;. And in Clojure we&rsquo;re used to the concept of &ldquo;it&rsquo;s just data&rdquo; so a graphical browser might sound useful but not exactly earthshaking. But REBL is just an example of what can be built with the new functionality in 1.10 and, indeed, Stu&rsquo;s claim of &ldquo;generalized laziness&rdquo; is well made but a little hard to grok until you actually build something with the new protocols and functions.</p>

<p>Since I&rsquo;ve done exactly that &ndash; with experimental support for <a href="https://github.com/clojure/java.jdbc/blob/master/src/main/clojure/clojure/java/jdbc/datafy.clj">lazy navigation of related records in <code>java.jdbc</code></a> &ndash; and spent some time on Slack today explaining how it all works, I figured it would be worth writing down in a more permanent place, as a blog post.</p>

<p>The <code>Datafiable</code> protocol (new in <code>clojure.core.protocols</code>) is defined for <code>nil</code> and <code>Object</code> to just return those values as-is, and then extended in <code>clojure.datafy</code> to cover:
* <code>Throwable</code> &ndash; producing a simple hash map by calling <code>Throwable-&gt;map</code>
* <code>clojure.lang.IRef</code> &ndash; producing a vector containing the dereferenced value, with the original metadata from the reference attached to that vector
* <code>clojure.lang.Namespace</code> &ndash; producing a hash map that is the data representation of the namespace (<code>:name</code>, <code>:publics</code>, <code>:imports</code>, and <code>:interns</code>) with the metadata of the namespace attached
* <code>java.lang.Class</code> &ndash; producing the <code>clojure.reflect/reflect</code> representation of the class, with an additional member <code>:name</code>, and the <code>:members</code> of the class grouped by name and sorted</p>

<p>The <code>Navigable</code> protocol (new in <code>clojure.core.protocols</code>) is defined just for <code>Object</code> and, given some sort of object or collection, some sort of &ldquo;key&rdquo;, and a value, it will just return the value itself.</p>

<p>Based on that, it may not be clear how to implement the protocols or use the functions. The key thing that may not be obvious here is that <code>datafy</code> is intended to convert an arbitrary &ldquo;thing&rdquo; of any type into a pure Clojure data representation and, from that starting point, you can then use <code>nav</code> to &ldquo;navigate&rdquo; to a value derived from the original &ldquo;thing&rdquo;, which you would then process with <code>datafy</code> to get a pure Clojure data representation again. Those data representations may contain pieces that satisfy the <code>Navigable</code> protocol so that navigation (via <code>nav</code>) provides more than just a simple data-level lookup.</p>

<p>Using the <code>clojure.java.jdbc.datafy</code> code as an example, you would call <code>query</code> (from that new namespace) and get back a result set. That looks like a sequence of hash maps (rows) but adds metadata to the rows that provides an implementation of <code>Datafiable</code> (<a href="https://github.com/clojure/clojure/blob/master/changes.md#22-protocol-extension-by-metadata">protocol extension via metadata</a> is also new in Clojure 1.10). The row is the &ldquo;arbitrary thing&rdquo; that we are starting with. One or more of the columns in that row may be a foreign key into another table. When you turn the row into a pure Clojure data representation &ndash; by calling <code>datafy</code> on it &ndash; it still looks like a hash map but now it has metadata that provides an implementation of <code>Navigable</code>. That supports calling <code>(nav row column value)</code> and, if the column is considered to be a foreign key to another table, it will fetch the relevant row(s) from that table and return that as the next &ldquo;arbitrary thing&rdquo;, otherwise it will just return the column&rsquo;s value as passed in. The cycle of converting that to data (via <code>datafy</code>) and navigating through it (by navigating the Clojure data and then calling <code>nav</code> on that) can be continued indefinitely, until you bottom out to simple values.</p>

<p>You can sum this up as:
* Starting with a &ldquo;thing&rdquo;&hellip;
* &hellip;you convert it to data (with <code>datafy</code>)&hellip;
* &hellip;and walk it with simple Clojure data access&hellip;
* &hellip;and, at each stage, you can navigate to the corresponding &ldquo;new thing&rdquo; by calling <code>nav</code>&hellip;
* &hellip;which may return just that value or may do something more complex&hellip;
* &hellip;and from that &ldquo;new thing&rdquo; you convert it to data (with <code>datafy</code>) and continue the process.</p>

<p>Relating this back to REBL, it works by taking some arbitrary value produced in the REPL and converting it to data (via <code>datafy</code>) so that it can be displayed in the UI. With any part of that data highlighted you can &ldquo;drill down&rdquo;, at which point REBL calls <code>nav</code> to perform the (potentially lazy, complex) navigation and then converts that to data (via <code>datafy</code>) and displays that as the next &ldquo;level&rdquo; of data. Given an associative data representation, it does <code>(get coll k)</code> first to get <code>v</code>, and then it calls <code>(nav coll k v)</code> to allow the underlying navigation to return an updated value.</p>

<p>You go from &ldquo;thing&rdquo; to &ldquo;data representation&rdquo; of &ldquo;thing&rdquo; (via <code>datafy</code>), and then you can do the simple associative lookup <em>in the data representation, not the original thing</em>, and then you use <code>nav</code> to get back to the relevant equivalent part of the &ldquo;thing&rdquo;, and then you <code>datafy</code> that again to get pure data. For built-in Clojure data types that are already pure data, <code>datafy</code> does nothing and <code>nav</code> just returns the selected value. For hash maps, navigation is just simple key lookup. For vectors, navigation is also simple key (index) lookup. This new machinery only starts to shine in more complex situations.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Excited About Clojure/conj]]></title>
    <link href="http://corfield.org/blog/2018/10/25/clojure-conj/"/>
    <updated>2018-10-25T03:40:00-07:00</updated>
    <id>http://corfield.org/blog/2018/10/25/clojure-conj</id>
    <content type="html"><![CDATA[<p>It has been a crazy busy year, both at work and personally, and it&rsquo;s hard for me to believe my last blog post was in April!</p>

<p><a href="https://2018.clojure-conj.org/">Clojure/conj</a> is coming up fast and the schedule was posted today, which has made me even more excited about it. Here&rsquo;s a run down of the sessions I plan to attend &ndash; I&rsquo;ll write up my thoughts on everything shortly after the conference.</p>

<ul>
<li>Welcome Event &ndash; I&rsquo;m hoping my flight is on time and Lyft can get me there in time to chill and network with all the interesting Clojurians!</li>
<li>Stuart Halloway &ndash; In his recent <a href="https://www.youtube.com/watch?v=6ftW8UwwP_4">Apropos podcast</a>, he hinted that this talk would be about new tooling he has been using. Maybe prepl-related?</li>
<li>Christopher Small &ndash; Clojure on the cyberpunk frontier of democracy &ndash; This sounds fascinating.</li>
<li>Chris Johnson Bidler &ndash; Serverless-ish: Zero to App with Datomic Cloud and GraphQL.</li>
<li>Ghadi Shayban &ndash; Java Made (Somewhat) Simple &ndash; Although Ghadi told me this might be a beginner/intermediate-level talk, he&rsquo;s a great speaker and I look forward to hearing his insights about the platform.</li>
<li>Boris Kourtoukov &ndash; Machines that Judge Us.</li>
<li>Tiago Luchini &ndash; Declarative Domain Modeling for Datomic Ion/Cloud.</li>
<li>Lily Goh + Dom Kiva-Meyer &ndash; Robust APIs with clojure.spec &amp; GraphQL &ndash; I&rsquo;m a huge advocate of spec and we&rsquo;re also using GraphQL at work so this should be very applicable.</li>
<li>Rich Hickey &ndash; Maybe Not &ndash; Rich is always worth the price of entry!</li>
<li>Unsessions &ndash; Looking forward to seeing the schedule for these. Past years' unsessions have included some real diamonds!</li>
<li>David Chelimsky &ndash; AWS, meet Clojure.</li>
<li>Ben Kamphaus &ndash; AI Systems: Foundations for Artificial Minds or Aaron Cummings &ndash; Making Memories: Clojure For Hardware Engineers (And Others). I&rsquo;m undecided but leaning toward the AI talk.</li>
<li>Elena Machkasova &ndash; Babel: middleware for beginner-friendly error messages &ndash; Anything that helps with Clojure&rsquo;s error messages (much improved in Clojure 1.10!) is always worth learning about!</li>
<li>Wilker Lucio da Silva &ndash; Scaling Full-Stack Applications Over Hundreds of Microservices or Daniel Gregoire &ndash; Tables Considered Helpful. Undecided again but leaning toward the table talk.</li>
<li>Nikolas Göbel &ndash; Reactive Datalog for Datomic or Tyler Hobbs &ndash; Code goes in, Art comes out. Undecided but leaning toward the Datalog talk (because I&rsquo;m not hugely interested in art/computing).</li>
<li>Gary Fredericks &ndash; What Are All These Class Files Even About? And Other Stories &ndash; Having been repeatedly bitten by AOT, I&rsquo;m looking forward to this!</li>
<li>Tomomi Livingstone + Hans Livingstone &ndash; Party REPL — A multi-player REPL built for pair-programming &ndash; This looks very, very interesting!</li>
<li>Rebecca Parsons &ndash; Closing day two keynote.</li>
<li>(Party!)</li>
<li>Carin Meier &ndash; Can you GAN? &ndash; No idea about the topic but Carin is always an engaging speaker.</li>
<li>Dave Fetterman &ndash; Learning and Teaching Clojure on the job at Amperity &ndash; Because coming up to speed (and bringing others up to speed) is important.</li>
<li>Vikash Mansinghka &ndash; Probabilistic programming and meta-programming in Clojure &ndash; WAT?</li>
<li>Alex Engelberg and Derek Slager &ndash; Every Clojure Talk Ever &ndash; Cryptically enticing&hellip;</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[All the Paths]]></title>
    <link href="http://corfield.org/blog/2018/04/18/all-the-paths/"/>
    <updated>2018-04-18T03:40:00-07:00</updated>
    <id>http://corfield.org/blog/2018/04/18/all-the-paths</id>
    <content type="html"><![CDATA[<p>With the recent arrival of <a href="https://clojure.org/guides/deps_and_cli"><code>clj</code> and <code>tools.deps.alpha</code></a> as a &ldquo;standard&rdquo; lightweight way to run Clojure programs and the seed for tooling based on <code>deps.edn</code> dependency files, it&rsquo;s time to take a look at the terminology used across Clojure&rsquo;s various tools.<!-- more --></p>

<h2>Running Java/JVM Programs</h2>

<p>Before we dive into Clojure&rsquo;s tools, let&rsquo;s first consider the basics. When you run a compiled Java (or any JVM-based) program, you need two things: a classpath and a <code>main</code> function or, rather, a &ldquo;main class&rdquo;. Everything boils down to <code>java -cp ... MyClass</code> where the <code>...</code> is the &ldquo;classpath&rdquo;: a colon-delimited (or semicolon-delimited on Windows) list of directories or JAR files to search for <code>MyClass</code> and all the classes it needs. A quick look at the many introductory tutorials for Java online shows that the classpath is mostly just glossed over, despite being one of the most important (and, for beginnners, often one of the most perplexing) aspects of running programs on the JVM.</p>

<p>When you are creating deployable versions of programs, you typically use some sort of &ldquo;build&rdquo; tool to gather up all your (compiled) class files and JAR files (dependencies) and put them all together in a single &ldquo;uber&rdquo; JAR file, so that it can be run with just <code>java -jar MyApplication.jar</code>. This is shorthand for specifying <code>MyApplication.jar</code> as the entire classpath and assuming some &ldquo;magic&rdquo; inside the JAR file that specifies how to find the main class (via something called a &ldquo;manifest&rdquo;). The build tools know how to create the manifest (based on some information you provide) as well as managing the assembly of all the component pieces that will make up your complete application.</p>

<p>It&rsquo;s no wonder this can be a minefield for beginners!</p>

<h2>Leiningen</h2>

<p>In the very early days of Clojure, folks relied on the JVM ecosystem for build tools and dealt with all the sharp edges directly. Then along came <a href="https://leiningen.org/">Leiningen</a> with the goal of &ldquo;automating Clojure projects without setting your hair on fire&rdquo; by hiding all the sharp edges of Maven and <code>pom.xml</code> files and manifests and so on. It was so successful that it soon became the de facto standard in the Clojure world and most of the Clojure books out there can safely assume you have Leiningen installed. You can even just type <code>lein new app myapp</code> and you have a nicely structured skeleton of a Clojure project to get you up and running! Leiningen dispensed with all the XML and arcane invocations of the Java world and used a simple <code>project.clj</code> file to declare everything about your program. Your dependencies, your main namespace (class), various different ways of running your program (profiles), and all the tools you needed for development and testing (plugins).</p>

<p>The main aspect of Leiningen that is relevant to this blog post is the concept of &ldquo;paths&rdquo;. As noted above, as far as the JVM is concerned, there&rsquo;s really only the classpath: that&rsquo;s how you run your code. The various build tools need to know what else should be packaged up for deployment (e.g., configuration files, HTML/CSS/JS assets), as well as what you need to run tests or other development-related tasks that do not need to be in the deployment artifact.</p>

<p>Leiningen chose the following terminology for these various things:</p>

<ul>
<li><code>source-paths</code> &ndash; your Clojure code that should be part of every runtime, as well as being packaged up for deployment.</li>
<li><code>java-source-paths</code> &ndash; any Java code in your project that should be compiled, and whose <code>.class</code> files should be packaged up for deployment.</li>
<li><code>test-paths</code> &ndash; your Clojure code needed for development/testing of your application, which should <em>not</em> be part of the deployment artifact.</li>
<li><code>resource-paths</code> &ndash; your non-code files that should be made available at runtime (i.e., on the classpath), as well as being packaged up for deployment.</li>
<li><code>dependencies</code> &ndash; the list of project artifacts (and versions) that your program needs at runtime, and therefore should be packaged up for deployment &ndash; or at least declared in the deployment artifact as being needed for runtime.</li>
</ul>


<p>There&rsquo;s a subtlety here that Leiningen glosses over: there are really two types of files that are not code, that both need to be in the deployment artifact &ndash; those that need to be on the classpath during Leiningen&rsquo;s runtime (configuration files etc) and those that do not (HTML/CSS/JS etc). In Leiningen&rsquo;s world they are all &ldquo;resources&rdquo; and end up on the classpath anyway. This is a harmless convenience, but it&rsquo;s still an important distinction (note: once packaged up, everything in the JAR will be available on that program&rsquo;s runtime and, in general, during development/testing you will usually want your &ldquo;web root&rdquo; to be on your classpath, so that <code>io/resource</code> can find those files).</p>

<h2>Boot</h2>

<p><a href="http://boot-clj.com/">Boot</a> came along later in Clojure&rsquo;s evolution and approached build tools from a different direction. While most build tools (across most languages) are &ldquo;declarative&rdquo;, i.e., they have some sort of Domain-Specific Language (DSL) and a file that describes the various properties of your development/testing/packaging strategies, Boot decided to provide a library and a set of abstractions that would let you write pure Clojure to implement your needs. As Boot&rsquo;s website says &ldquo;It&rsquo;s not a build tool - it&rsquo;s build tooling.&rdquo;</p>

<p>I&rsquo;ve <a href="http://corfield.org/blog/categories/boot/">written about Boot</a> quite a bit since we made our decision at <a href="http://worldsinglesnetworks.com/">World Singles llc</a> to switch our stack from Leiningen to Boot, back in late 2015. Boot feels more like Clojure: it&rsquo;s composable and &ldquo;it&rsquo;s just code&rdquo;. Boot can do everything that Leiningen can do, and quite a bit more. And of course it chose its own terminology for the various JVM-related paths:</p>

<ul>
<li><code>resource-paths</code> &ndash; any files that need to both be on the classpath and packaged up for deployment.</li>
<li><code>source-paths</code> &ndash; any files that need to be on the classpath, but not part of the deployment artifact.</li>
<li><code>asset-paths</code> &ndash; any files that do not need to be on the classpath, but should be packaged up for deployment.</li>
<li><code>dependencies</code> &ndash; the list of project artifacts (and versions) that your program needs at runtime (etc).</li>
</ul>


<p>We see that Boot distinguishes between the two types of files that are not code, that both need to be in the deployment artifact, but blurs the lines between code and non-code files that need to be on the classpath. That means that when we move back and forth between Boot and Leiningen, we need to remember that they call certain core concepts by different names. Boot&rsquo;s <code>source-paths</code> are pretty much equivalent to Leiningen&rsquo;s <code>test-paths</code>. Boot&rsquo;s <code>asset-paths</code> are mapped into Leiningen&rsquo;s <code>resource-paths</code> (despite not needing to be on the classpath during the tool&rsquo;s runtime) and Leiningen&rsquo;s <code>source-paths</code> are mapped into Boot&rsquo;s <code>resource-paths</code> (despite being specifically <em>source</em> code). It definitely has potential to be confusing but it&rsquo;s born out of different approaches to how the fileset is managed across the lifecycle of both tools. In particular, Boot has a fileset abstraction that is key to how tasks are written and how various types of files are manipulated during Boot&rsquo;s execution &ndash; see <a href="https://github.com/boot-clj/boot/wiki/Boot-Environment">https://github.com/boot-clj/boot/wiki/Boot-Environment</a> for more detail about this.</p>

<h2>clj - Bringing It Back Home</h2>

<p>As Clojure 1.9 was being developed, it became important to be able to treat &ldquo;Clojure core&rdquo; as a single artifact, even tho' it consisted of &ldquo;core&rdquo; plus &ldquo;spec.alpha&rdquo; plus &ldquo;core.specs.alpha&rdquo;. Out of that came the <code>deps.edn</code> file for specifying dependencies, the <code>tools.deps.alpha</code> library for manipulating the <code>deps.edn</code> files and the dependencies they declare, and the <code>clj</code> and <code>clojure</code> command-line scripts that provide a standardized way to run Clojure programs based on dependencies specified in <code>deps.edn</code> files.</p>

<p>Just like the underlying Java (JVM) ecosystem, Clojure&rsquo;s new Command-Line Interface (CLI) is primarily about the classpath. It provides a mechanism to specify a set of paths and a set of dependencies, across (typically) three files (the &ldquo;install&rdquo; <code>deps.edn</code>, your &ldquo;home&rdquo; <code>deps.edn</code>, and your &ldquo;project&rdquo; <code>deps.edn</code>). It supports &ldquo;aliases&rdquo; for merging in alternative paths and dependencies. It also supports JVM options, and the options already available in <code>clojure.main</code>: initial and main options, to specify files to load, code to run, and a main namespace.</p>

<p>By getting back to basics, <code>clj</code> mirrors the underlying JVM ecosystem that really only cares about the classpath, constructed in appropriate ways for developing, testing, and running your program. It leaves decisions about packaging up to other tools, by design, and through the <code>tools.deps.alpha</code> library it offers a straightforward API for tool authors to build upon.</p>

<p>Late last year (November 2017), I started work on <a href="https://github.com/seancorfield/boot-tools-deps">boot-tools-deps</a> which was intended as a bridge to add Boot-based tooling on top of an existing <code>deps.edn</code> project. There is also <a href="https://github.com/RickMoynihan/lein-tools-deps">lein-tools-deps</a> which takes a slightly different approach but is intended to integrate <code>deps.edn</code> files into a Leiningen project.</p>

<p>We&rsquo;ve also seen the first two &ldquo;build tools&rdquo; based on <code>deps.edn</code> appear: <a href="https://github.com/healthfinch/depstar">depstar</a> and <a href="https://github.com/juxt/pack.alpha">juxt.pack</a> which, like the Boot and Leiningen tools above, take different approaches but are both intended to build (uber) JAR files from projects based on <code>deps.edn</code>.</p>

<p>This means that we need to look closely at the decisions each of these tools make about paths. The recommended approach with <code>clj</code> and <code>deps.edn</code> is to use aliases (liberally) to delineate the different classpaths (and JVM options and main options and so on) that all your various tasks require. The end result in each case is a specific classpath and options to run your code. For build tools, &ldquo;run your code&rdquo; means take the files on the classpath and package them up into a JAR file &ndash; so the entire file selection process is driven by aliases. This is rather different to the Leiningen and Boot build tools outlined above, since they provide explicit categories in which to declare files and folders for consideration in the classpath, non-classpath, packaging, and non-packaging categories.</p>

<p><code>lein-tools-deps</code> is intended primarily to replace your <code>:dependencies</code> vector by dependencies drawn from various <code>deps.edn</code> files. It doesn&rsquo;t (currently) worry about aliases, and it relies on the existing Leiningen infrastructure for all development/testing/packaging decisions. It&rsquo;s a nice, straightforward metaphor: <code>:mvn/version</code> dependencies in <code>deps.edn</code> are mapped into Leiningen&rsquo;s <code>:dependencies</code> and nothing else changes. The project maintainer, Rick Moynihan, intends to expand its functionality over time.</p>

<p>Both <code>juxt.pack</code> and <code>depstar</code> assume that you know what you&rsquo;re doing with aliases and they take whatever you&rsquo;ve decided is your classpath and they turn it into a JAR file. <code>depstar</code> takes the simpler approach, producing just a JAR file with no assumptions built-in &ndash; you need to tell it what main namespace to run and so on. <code>juxt.pack</code> is closer to a standard build tool and targets both AWS Lambda and traditional uber-JAR approaches.</p>

<p><code>boot-tools-deps</code> is intended to be a hybrid that envelops the underlying <code>deps.edn</code> and <code>tools.deps.alpha</code> machinery, exposing most of the same options, and then allows you to either run Boot tasks using the same, underlying classpath, or merge the <code>clj</code> environment back into the Boot environment to support different tooling. Specifically, it assumes that what comes out of <code>deps.edn</code> in the <code>:paths</code> key should be the <code>:resource-paths</code> &ndash; source and non-source, that is intended to be on the classpath and intended to be packaged for deployment. This includes <code>:git/url</code> and <code>:local/root</code> dependencies (since those are source code paths/folders). It also assumes that what comes out of <code>deps.edn</code> in the <code>:extra-paths</code> key should be the <code>:source-paths</code> &ndash; source code that is intended to be on the classpath but not packaged for deployment. While this is a fairly arbitrary interpretation of an artificial divide between entities on the classpath, I believe this is &ldquo;likely&rdquo; in the real world. In any case, this can be modified by Boot&rsquo;s <code>sift</code> task. Finally, it assumes that what comes out of <code>deps.edn</code> as a map of actual libraries and versions should be the <code>:dependencies</code> for Boot itself. This ought to be a straightforward assumption but it can cause problems if the dependencies use <code>:scope</code> extensively since that is not propagated by the Maven/Resolver library behind <code>tools.deps.alpha</code> and is of dubious value in the first place. In particular, transitive dependencies will not have the same scope as the parent that introduced them! Using aliases to assemble your dependencies is a much safer bet.</p>

<h2>Looking Forward</h2>

<p><code>clj</code> and <code>deps.edn</code> and <code>tools.deps.alpha</code> provide a core, standardized way of dealing with dependencies and various options that are required to run Clojure programs. Over time, this should become the standard baseline for &ldquo;installing&rdquo; and running Clojure code on Linux, Mac, and Windows. Both Leiningen and Boot have a strongly entrenched user base and both provide substantially enhanced behavior above and beyond <code>clj</code> and its components &ndash; that&rsquo;s by design. It is reasonable to assume that tooling based on <code>clj</code>, <code>deps.edn</code>, and <code>tools.deps.alpha</code> will become much more commonplace and there will come a day, possibly soon, where developers who pick up Clojure no longer need to consider installing Boot or Leiningen for their day-to-day work.</p>

<h2>p.s. Building New Projects</h2>

<p>Another common function that both Leiningen and Boot provide is to generate new projects based on a template. Check out <a href="https://github.com/seancorfield/clj-new">clj-new</a> for <code>clj</code>-based tooling that generates new <code>deps.edn</code>-based projects, as well as leveraging existing <code>lein-template</code> and <code>boot-template</code> projects.</p>

<h2>Credits</h2>

<p>Thank you to Alan Dipert, Alex Miller, Richiardi Andrea, and Rick Moynihan for reviewing a draft of this post and providing feedback and suggestions!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boot Localrepo?]]></title>
    <link href="http://corfield.org/blog/2017/11/17/boot-localrepo/"/>
    <updated>2017-11-17T04:50:00-08:00</updated>
    <id>http://corfield.org/blog/2017/11/17/boot-localrepo</id>
    <content type="html"><![CDATA[<p>Sometimes you just can&rsquo;t help having a &ldquo;random 3rd part JAR file&rdquo; in your project. The best practice is, of course, to upload it to your preferred Maven-compatible repository via whatever service or software you use for all your in-house shared artifacts. But sometimes you just want to play with that JAR file locally, or you haven&rsquo;t gotten around to running your own shared repository.</p>

<p>If you&rsquo;re using Leiningen, you&rsquo;ll probably reach for the excellent <a href="https://github.com/kumarshantanu/lein-localrepo"><code>lein-localrepo</code></a> which lets you &ldquo;install&rdquo; your random JAR file into your local Maven cache (in <code>~/.m2/repository</code>).</p>

<p>What do you do if you&rsquo;re using Boot instead?<!-- more --></p>

<p>Well, you <em>could</em> just keep <code>lein</code> installed and use it for this (with the <code>lein-localrepo</code> plugin dependency in your <code>~/.lein/profiles.clj</code>, for example):</p>

<pre><code class="bash">lein localrepo install foobar.jar foo/bar 1.0.1
</code></pre>

<p>Or you could run some command line Boot to make that happen:</p>

<pre><code class="bash">boot pom -p foo/bar -v 1.0.1 target \
    install -f foobar.jar -p target/META-INF/maven/foo/bar/pom.xml
# Don't forget to clean up!
rm -rf target
</code></pre>

<p>What the what? Yeah, that&rsquo;s really kind of ugly. Unfortunately, the <code>install</code> task seems to expect a physical <code>pom.xml</code> file when you specify a physical JAR file. That means we need to drop a <code>target</code> task into the pipeline into order for the generated <code>pom.xml</code> to be written to disk. It would be nice if it would look in the fileset first, because then at least this should work:</p>

<pre><code class="bash"># This does NOT work!
boot pom -p foo/bar -v 1.0.1 install -f foobar.jar -p foo/bar
</code></pre>

<p>So what other options do we have with Boot?</p>

<p>Well, it turns out that you can run some Leiningen plugins directly from Boot, from the command line! Boot lets you specify dependencies on the command line, and it lets you &ldquo;call&rdquo; Clojure code from the command line too. Let&rsquo;s start a REPL with <code>lein-localrepo</code> as a dependency:</p>

<pre><code class="bash">boot -d leiningen -d lein-localrepo repl
</code></pre>

<p>We need Leiningen as well since plugins rely on it as a dependency. Now, in the REPL we can require the main namespace from the plugin, and get information about the entry point:</p>

<pre><code class="clojure">boot.user=&gt; (require '[leiningen.localrepo :as lr])
nil
boot.user=&gt; (doc lr/localrepo)
-------------------------
leiningen.localrepo/localrepo
([_] [_ command &amp; args])
  Work with local Maven repository

Usage: lein localrepo &lt;command&gt; (commands are listed below)
...
</code></pre>

<p>For any given plugin, <code>lein-foo</code>, the entry point is <code>leiningen.foo/foo</code>. Note that it is called with an unused argument and then the actual command line arguments. So we can ask for help on the <code>install</code> command:</p>

<pre><code class="clojure">boot.user=&gt; (lr/localrepo nil "help" "install")
Install artifact to local repository
  Arguments:
    [options] &lt;filename&gt; &lt;artifact-id&gt; &lt;version&gt;
  Options:
...
</code></pre>

<p>So we can call that function to perform the JAR install we want:</p>

<pre><code class="clojure">boot.user=&gt; (lr/localrepo nil "install" "foobar.jar" "foo/bar" "1.0.1")

&gt;
</code></pre>

<p>Oh, that&rsquo;s a bit disappointing &ndash; we exited the REPL and got our command prompt back. I guess that calls <code>(System/exit)</code> which is a bit unfriendly (but, perhaps, not unexpected given the use case for this plugin). But we can verify that the JAR file was installed:</p>

<pre><code class="bash">&gt; ls -R ~/.m2/repository/foo
bar

/Users/sean/.m2/repository/foo/bar:
1.0.1               maven-metadata-local.xml

/Users/sean/.m2/repository/foo/bar/1.0.1:
_remote.repositories    bar-1.0.1.jar       bar-1.0.1.pom
</code></pre>

<p>Now, remember that I said you can &ldquo;call&rdquo; code from the command line with Boot? Since we know the code we need to execute (the <code>require</code> and the call to <code>lr/localrepo</code>), we&rsquo;ll just supply those as command line arguments to the <code>call</code> task:</p>

<pre><code class="bash">boot -d leiningen -d lein-localrepo \
  call -e "(require '[leiningen.localrepo :as lr])" \
       -e '(lr/localrepo nil "install" "foobar.jar" "foo/bar" "1.0.1")'
</code></pre>

<p>Voila!</p>

<p><em>Updated November 22nd, 2017: I published a boot-localrepo task!</em></p>

<p>And if you don&rsquo;t want to type all that, you can now do:</p>

<pre><code class="bash">boot -d seancorfield/boot-localrepo install-artifact -f foobar.jar -P foo/bar -v 1.0.1
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Release 0.7.0 of clojure.java.jdbc]]></title>
    <link href="http://corfield.org/blog/2017/07/17/clojure-java-jdbc-0-7-0/"/>
    <updated>2017-07-17T03:40:00-07:00</updated>
    <id>http://corfield.org/blog/2017/07/17/clojure-java-jdbc-0-7-0</id>
    <content type="html"><![CDATA[<p>The stable 0.7.0 release of <code>java.jdbc</code> &ndash; the <a href="https://github.com/clojure/java.jdbc">Clojure Contrib JDBC library</a> &ndash; has been baking for over a year, across of a trail of alpha and beta releases, and is now, finally, available!</p>

<p>While you <em>could</em> read the <a href="https://github.com/clojure/java.jdbc/blob/master/CHANGES.md"><code>java.jdbc</code> Change Log</a> to figure out what is new in this release, I thought it would be easier to consolidate all the changes into a blog post, with changes organized by category, and provide justification for the various changes.<!-- more --></p>

<p>I recently ran a <a href="https://www.surveymonkey.com/results/SM-CJY2YMHP/">survey about versions</a> of both Clojure and <code>java.jdbc</code> in use and had nearly 100 responses (thank you to everyone who completed the survey!). Only one respondent is still on Clojure 1.7.0, with about two thirds on 1.8.0, and a full third of respondents on a 1.9.0 alpha build. No one responded that they&rsquo;re on an earlier version of Clojure. That&rsquo;s great news for Clojure library maintainers, as it means we can take advantage of modern features in the language (such as transducers), and it also means that it is worthwhile to offer optional namespaces providing specs. <strong>Accordingly, <code>java.jdbc</code> now requires Clojure 1.7.0 or later.</strong></p>

<p>Also very encouraging was to see that almost a third of <code>java.jdbc</code> users are on alpha builds of what has become 0.7.0, with only a handful of users still on &ldquo;legacy&rdquo; versions (prior to 0.6.1).</p>

<p>Let&rsquo;s look at the major changes in 0.7.0, compared to 0.6.1!</p>

<h2>Reducible Queries</h2>

<p>Now that Clojure 1.7.0 is the minimum supported version, <code>java.jdbc</code> can offer query result collections that work with transducers. Two new functions &ndash; <code>reducible-query</code> and <code>reducible-result-set</code> &ndash; produce collections that implement <code>IReduce</code> and will perform resource management when <code>reduce</code>d. A reducible query will run the specified query only when the result is reduced &ndash; and it will run it each time it is reduced. A reducible result set can be constructed from any <code>ResultSet</code> object and will provide a one-off, managed forward read of the underlying data. Both of these support <code>reduced</code> results, which short-circuit the processing of the result set. They also support both the <code>init</code>-arity <code>reduce</code> and the no-<code>init</code>-arity <code>reduce</code>. Consult the docstring for <code>reduce</code> to see the full implications of this: the function passed into the no-<code>init</code>-arity <code>reduce</code> will be called with no arguments if the result set is empty!</p>

<p><code>reducible-query</code> works by invoking <code>db-query-with-resultset</code> only when it is <code>reduce</code>d, passing in a function that calls <code>reducible-result-set</code> and then <code>reduce</code>s the result. <code>reducible-result-set</code> works by computing metadata and key names only when it is <code>reduce</code>d, and then walking through the rows of the result, calling the supplied function (as specified by <code>reduce</code>), stopping if that function returns a <code>reduced?</code> value.</p>

<h2>Improved Database Vendor Support</h2>

<p>The <code>:dbtype</code> key in a <code>db-spec</code> is the preferred way to specify a database vendor, so you don&rsquo;t have to worry about &ldquo;subprotocols&rdquo; and &ldquo;subnames&rdquo; and so on. Just provide <code>:dbtype</code>, <code>:dbname</code>, <code>:host</code>, <code>:port</code>, <code>:user</code>, and <code>:password</code>, and <code>java.jdbc</code> should be able to connect you to most databases. The full list of supported <code>:dbtype</code> values is:</p>

<ul>
<li><code>derby</code> &ndash; Apache Derby</li>
<li><code>h2</code></li>
<li><code>hsql</code> or <code>hsqldb</code></li>
<li><code>jtds</code> or <code>jtds:sqlserver</code> &ndash; the jTDS JDBC driver for Microsoft SQL Server</li>
<li><code>mssql</code> &ndash; an alias for <code>sqlserver</code> below</li>
<li><code>mysql</code></li>
<li><code>oracle</code> or <code>oracle:thin</code>, <code>oracle:oci</code> &ndash; for the two main Oracle JDBC drivers (which use <code>@</code> in front of the <code>host</code> name, instead of <code>//</code>)</li>
<li><code>pgsql</code> &ndash; the Impossibl PostgresSQL JDBC driver</li>
<li><code>postgres</code> or <code>postgresl</code> &ndash; the standard PostgresSQL JDBC driver</li>
<li><code>redshift</code> &ndash; Amazon&rsquo;s Red Shift JDBC driver</li>
<li><code>sqlite</code></li>
<li><code>sqlserver</code> &ndash; Microsoft&rsquo;s default JDBC driver for SQL Server (they have finally released a version on Maven Central!)</li>
</ul>


<p>If your preferred database is not listed, head on over to <a href="https://dev.clojure.org/jira/browse/JDBC"><code>java.jdbc</code>s JIRA site</a> and create an enhancement issue, with details of the JDBC driver and I&rsquo;ll take a look! Note that you can can specify <code>:classname</code>, along with <code>:dbtype</code> if you want to override just the JDBC driver class name that <code>java.jdbc</code> would deduce from <code>:dbtype</code>.</p>

<h2>Option Handling</h2>

<p>An overall goal of 0.7.0 has been to make the API more consistent, especially in the way options are handled and passed around. The intention is that you can provide a hash map of options, as the last argument to any function, and <code>java.jdbc</code> will pass all of those options through the whole call chain, allowing you to control a lot more of the behavior of lower-level functions that are invoked by the higher-level functions. In addition, defaults for all options can be provided in your <code>db-spec</code>, and those will apply to all API functions. This is especially useful for specifying the <code>:entities</code> and <code>:identifiers</code> functions that control how SQL entity names and Clojure identifiers are constructed, everywhere in <code>java.jdbc</code>.</p>

<p>Here are all the new options available:</p>

<ul>
<li><code>:auto-commit?</code> &ndash; Can be passed into any API function that might cause a new database connection to be created. This allows you to turn auto-commit off for <em>new connections</em> in databases that use this setting to control whether a query can stream its results. The behavior is inherently vendor-specific, so you may need additional options to fully enable streaming results (setting <code>:fetch-size</code> to a non-zero value is common).</li>
<li><code>:conditional?</code> &ndash; For the two DDL-generating functions to add an existence check on the table to be created or dropped. May be a simple boolean value, a string (to be inserted between <code>DROP TABLE</code>/<code>CREATE TABLE</code> and the table name), or a function. In the latter case, the DDL string is generated as usual and then that function is called on it. This allows for databases that don&rsquo;t support <code>DROP TABLE IF EXISTS</code> / <code>CREATE TABLE IF NOT EXISTS</code> but instead require the <code>DROP</code> or <code>CREATE</code> statement to be wrapped in a specific existence checking query.</li>
<li><code>:explain?</code> and <code>:explain-fn</code> &ndash; So you can get the database to explain how it will run your query. Supported by <code>query</code>, <code>find-by-keys</code>, and <code>get-by-id</code>, these options will run the generated SQL with an &ldquo;explain&rdquo; option first, and then for real. <code>:explain?</code> can be <code>true</code> which simply prefixes the SQL with <code>"EXPLAIN "</code> or it can be a string if your database needs a different syntax (such as HSQLDB needing <code>"EXPLAIN PLAN FOR "</code>). The explanation output is processed by the <code>:explain-fn</code>, which defaults to <code>println</code>, but can be used to send explanations to a logging system etc.</li>
<li><code>:qualifier</code> &ndash; Lets you easily produce namespace-qualified column names from your queries.</li>
<li><code>:read-columns</code> &ndash; To specify how columns of data are read from a <code>ResultSet</code> object. The default behavior is to call <code>result-set-read-column</code> which implements the <code>IResultSetReadColumn</code> protocol. This allows finer-grained control when you are working with multiple databases in a single application.</li>
<li><code>:read-only?</code> &ndash; Like <code>:auto-commit?</code> this can be passed into any API function that might cause a new database connection to be created. This allows you to specify that <em>new connections</em> be treated as readonly, which may allow the database driver to perform optimizations on how the connection and its queries behave.</li>
</ul>


<h2>clojure.spec</h2>

<p><code>java.jdbc</code> provides an optional <code>clojure.java.jdbc.spec</code> namespace that is compatible with Clojure 1.9.0 Alpha 17 (it uses <code>clojure.spec.alpha</code>). This namespace provides <code>fdef</code> specs for all of the public functions in <code>clojure.java.jdbc</code> so you can <code>instrument</code> your code and get validation on all your interaction with <code>java.jdbc</code>. Note that you cannot do generative testing against <code>java.jdbc</code> because it uses a lot of Java types and a lot of side effects. <em>I have an experimental branch where I&rsquo;ve been investigating what generators would look like for <code>java.jdbc</code> but don&rsquo;t hold your breath for that becoming part of the <strong>master</strong> branch!</em></p>

<h2>New and Changed API Functions</h2>

<ul>
<li><code>as-sql-name</code> dropped its single arity (curried) version.</li>
<li><code>get-isolation-level</code> will return the current isolation level inside a transaction, if any.</li>
<li><code>quoted</code> dropped its 2-arity version, and now supports certain keywords for common entity-quoting strategies: <code>:ansi</code> (wraps entities in double quotes), <code>:mysql</code> (wraps entities in backticks), <code>:oracle</code> (wraps entities in double quotes), and <code>:sqlserver</code> (wraps entities in square brackets). These match the options in HoneySQL.</li>
<li><code>reducible-query</code> and <code>reducible-result-set</code> &ndash; see <strong>Reducible Queries</strong> above.</li>
</ul>


<h2>Documentation</h2>

<p>At present, the auto-generated API documentation (on <a href="https://clojure.github.io">https://clojure.github.io</a>) is stale due to some bugs in the toolchain used by the Clojure Build Server, so I recommend reading the <a href="http://clojure-doc.org/articles/ecosystem/java_jdbc/home.html">community-maintained <code>java.jdbc</code> documentation</a> on clojure-doc.org, in addition to using <code>clojure.repl/doc</code> to review the docstrings for API functions. That community-maintained documentation is currently going through a major overhaul to expand, clarify, and update the information presented &ndash; I encourage users of <code>java.jdbc</code> to get involved by submitting Pull Requests to help improve the documentation for everyone!</p>
]]></content>
  </entry>
  
</feed>
