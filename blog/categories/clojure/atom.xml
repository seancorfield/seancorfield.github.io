<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Clojure | An Architect's View]]></title>
  <link href="http://corfield.org/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://corfield.org/"/>
  <updated>2019-01-22T21:53:58-08:00</updated>
  <id>http://corfield.org/</id>
  <author>
    <name><![CDATA[Sean Corfield]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Atom, Chlorine, and Windows]]></title>
    <link href="http://corfield.org/blog/2019/01/22/atom-chlorine-windows/"/>
    <updated>2019-01-22T12:15:00-08:00</updated>
    <id>http://corfield.org/blog/2019/01/22/atom-chlorine-windows</id>
    <content type="html"><![CDATA[<p>About a month ago, I was <a href="http://corfield.org/blog/2018/12/19/atom-chlorine/">praising Chlorine, the new Clojure package for
Atom</a> and I&rsquo;ve been using
it, day-in, day-out, for all my Clojure development. On a Mac, that&rsquo;s
straightforward because I start a Socket REPL on the Mac and I run Atom on the
Mac so when I connect via Chlorine and issue the <code>Chlorine: Load File</code>
command (via <code>Ctrl-, f</code> in my keymap), it sends <code>(load-file "/path/to/file.clj")</code>
to the REPL, for the file being edited, and that is evaluated and loads the
source from disk and compiles it. On Windows&hellip;<!-- more --> Well, on Windows
there are a few obstacles to this workflow.</p>

<p>The first obstacle (for me) is that <code>clj</code> doesn&rsquo;t run on Windows and that&rsquo;s
what I use for everything Clojure on a Mac and on Linux now. There&rsquo;s a
PowerShell implementation in progress but Windows has always been a bit of a
second-class citizen so it&rsquo;s still a ways off. But Windows has WSL (Windows
Subsystem for Linux) so I can
and do run (user-mode) Ubuntu on my Windows laptop and I do all of my Clojure
work on that&hellip;</p>

<p>&hellip;but that brings the second obstacle: file paths on Windows look like
<code>C:\path\to\file.clj</code> and under WSL they look like <code>/mnt/c/path/to/file.clj</code>.
That means your editor on Windows and your REPL on Linux don&rsquo;t quite speak the
same language.</p>

<p>Fortunately, the latest release of Chlorine, 0.0.8, has a &ldquo;smart&rdquo; <code>Load File</code>
command that will work with both a Windows-based Socket REPL and a WSL-based
Socket REPL! It wraps the call to <code>load-file</code> in logic that looks at the
requested file path and also at the
<code>user.dir</code> JVM property and if the former starts with a drive identifier and <code>:</code>,
and the latter does not, it assumes the REPL is running on WSL on Windows and
maps the file path appropriately.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chlorine: Clojure Integration for Atom]]></title>
    <link href="http://corfield.org/blog/2018/12/19/atom-chlorine/"/>
    <updated>2018-12-19T22:45:00-08:00</updated>
    <id>http://corfield.org/blog/2018/12/19/atom-chlorine</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been using the <a href="https://atom.io">Atom</a> editor for about two years now.
I switched from Emacs after Clojure/conj 2016, having seen
<a href="https://youtu.be/buPPGxOnBnk">Jason Gilman&rsquo;s talk about ProtoREPL</a> [video].
It may sound like
heresy, but I&rsquo;d never been happy with Emacs<!-- more --> &ndash; not 17.x back when I first
started using it, not 18.x, not 19.x when I first stopped using it, nor 24.x onward
when I came back to it after learning Clojure a few decades later. I built
several configurations from scratch, I tried several &ldquo;curated&rdquo; configurations,
none of them felt like &ldquo;home&rdquo;. Emacs just leeched too much of my development
time for my tastes. I wanted a simple, modern text editor, that offered a wide
variety of &ldquo;plugins&rdquo; and supported all the languages I used, with a sane set of
defaults. Atom &ndash; with ProtoREPL &ndash; seemed to be exactly what I was looking for!</p>

<p>And for two years, it has been my day-to-day development environment.</p>

<p>But it has been frustrating that ProtoREPL hasn&rsquo;t been getting a huge amount of
love lately. Two releases immediately after that Conj, eleven in the first
half of 2017, and just three since then (in a year and a half).
With the advent of Clojure 1.10 and
<a href="https://github.com/cognitect-labs/REBL-distro">REBL</a>, I wanted to extend
ProtoREPL so I could integrate REBL into my workflow, so I forked it and
hacked in <code>inspect-block</code> and <code>inspect-top-block</code> functionality (see the
<a href="https://github.com/seancorfield/proto-repl/compare/4b13ebf9d0f1e228ab7800c4bc54fe071bacf29e...master">commit log</a>). But it&rsquo;s written in
CoffeeScript and that made me sad.</p>

<p>I&rsquo;ve also had a bit of a long-running love/hate relationship with
<a href="https://github.com/nrepl/nrepl">nREPL</a> over its lifetime. Something about the
wire protocol and overall architecture of it just bothered me and I longed for
tooling built on what Clojure provides out-of-the-box. When I saw <code>prepl</code> drop
in the Clojure 1.10 development cycle, I was very excited: built-in support for
future tooling, on top of the Socket REPL we&rsquo;ve had for a few releases!</p>

<p>I&rsquo;d previously used <a href="https://github.com/Unrepl/unravel">Unravel</a> to interact
with several of our processes at work that spawn a Socket REPL and found that a
very pleasant experience (side-loading <a href="https://github.com/Unrepl/unravel">Compliment</a>
to provide auto-completion while typing).</p>

<blockquote><p>Unravel is a simple command-line client for Clojure REPLs. It is based on the unrepl protocol, so instead of relying on nREPL, unravel communicates with your Clojure process through a Socket Server REPL.</p></blockquote>

<p>&ldquo;instead of relying on nREPL&rdquo; was music to my ears &ndash; I wanted editor integration
that worked this way!</p>

<p>A few days ago, in a side-thread in the <code>#off-topic</code> channel on the
<a href="https://clojurians.slack.com">Clojurians Slack</a> (<a href="http://clojurians.net/">sign up here</a>),
that had started with a question about <a href="https://cursive-ide.com/">Cursive</a> vs
Emacs/CIDER, Maurício Szabo mentioned &ldquo;a (very experimental) package for Atom
that &hellip; uses socket repl&rdquo;. I was intrigued. Could this be what I&rsquo;d been
looking for?</p>

<p>That package is <a href="https://atom.io/packages/chlorine">Chlorine for Atom</a>.
I installed it immediately (and disabled ProtoREPL) so I could take it for a
spin! It&rsquo;s written in ClojureScript. It only needs a Socket REPL. It uses
unrepl to &ldquo;upgrade&rdquo; the REPL as needed. It uses Compliment for auto-completion.
I could connect it directly to various running processes and I could start
REBL up from the command-line with a Socket REPL and connect to that as well.
<strong>This</strong> was exactly the workflow I&rsquo;d been looking for!</p>

<p>Maurício has been awesome to work with and over the last few days he&rsquo;s added
the first version of &ldquo;go to definition&rdquo; as well as merging pull requests from
me to add support for running tests in a namespace or an individual test. I
have pull requests in for adding &ldquo;load file&rdquo; (it already had evaluate selection,
so you could &ldquo;select all + evaluate selection&rdquo; but I was used to &ldquo;load file&rdquo;
from ProtoREPL), and &ldquo;show source&rdquo;.</p>

<p>I&rsquo;ve also <a href="https://github.com/seancorfield/atom-chlorine/commit/b5c4ec4fbe2572a97882e595f6280fec15592114">ported across my &ldquo;inspect&rdquo; functions</a> from ProtoREPL so my entire,
day-to-day workflow with ProtoREPL is now possible with Chlorine, REBL, <code>clj</code>, and
a couple of aliases &ndash; and I have an eminently hackable editor plugin, written
in ClojureScript with a slick auto-compile, auto-reload workflow (thank you
Maurício!).</p>

<p>I&rsquo;m still looking forward to tooling based on <code>prepl</code> so the client libraries
can be even simpler and smaller but, for now, I&rsquo;m a very happy developer and
I&rsquo;m very pleased to see how the Clojure community continues to innovate around
tooling (which, yes, has needed a lot of love over the years!).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL NULL, S/nilable, and Optionality]]></title>
    <link href="http://corfield.org/blog/2018/12/06/null-nilable-optionality/"/>
    <updated>2018-12-06T03:30:00-08:00</updated>
    <id>http://corfield.org/blog/2018/12/06/null-nilable-optionality</id>
    <content type="html"><![CDATA[<p>Rich Hickey gave a very thought-provoking talk at Clojure/conj 2018
called <a href="https://www.youtube.com/watch?v=YR5WdGrpoug&amp;list=PLZdCLR02grLpMkEBXT22FTaJYxB92i3V3&amp;index=2">Maybe Not</a>, where he mused
on optionality and how we represent the absence of a value.<!-- more --></p>

<p>His talk covered many things, including how <code>clojure.spec/keys</code> currently
complects both structure and optionality (and his thoughts on fixing that
in a future version of <code>clojure.spec</code>), but his mention of <code>s/nilable</code> was what
triggered an &ldquo;ah-ha!&rdquo; moment for me.</p>

<p>At <a href="https://worldsinglesnetworks.com">World Singles Networks</a>, we deal with a lot
of data in SQL (specifically in Percona&rsquo;s fork of MySQL) and, in SQL, you represent
the absence of a value with <code>NULL</code> in a column. Columns that represent optional
data must be declared as nullable and when you read data from them with
<a href="https://github.com/clojure/java.jdbc">clojure.java.jdbc</a> you get hash map
entries in the rows that have <code>nil</code> values. If you&rsquo;re using <code>clojure.spec</code> to
describe your tables, rows, and columns, then you are going to have lots of
<code>s/nilable</code> specs &ndash; and now your &ldquo;optionality&rdquo; has been reified into <code>nil</code>
values, cast in the stone of your specs&hellip; which is clearly not an ideal situation!</p>

<p>This made me realize that <code>java.jdbc</code> probably should just omit keys whose
values represent SQL <code>NULL</code>. They are, after all, <em>optional</em> values rather than
truly <em>nilable</em> values.</p>

<p>That would be a potentially breaking change in behavior for <code>java.jdbc</code> users.
Sure, in most cases, if you have a hash map representing a row in a database
table, you&rsquo;re not really going to care whether <code>(:col row)</code> gives you <code>nil</code>
because <code>:col</code> maps to <code>nil</code> or because <code>row</code> doesn&rsquo;t contain <code>:col</code>. There are
use cases where it matters: <code>contains?</code>, row/column specs, tabular printing.</p>

<p>Along with changing the behavior of <code>NULL</code> columns and
<a href="http://corfield.org/blog/2018/12/03/datafy-nav/">supporting <code>datafy</code> and <code>nav</code></a>,
I have a lot of other changes that I&rsquo;d like to apply to <code>java.jdbc</code>, such as
automatically qualifying column keys with the table from which they came,
improving overall performance (by no longer converting <code>ResultSet</code> objects to
sequences of hash maps), dramatically simplifying and streamlining the options
that are available (since many of them are very rarely used), and focusing on a
reducible-first API. All of which would be breaking changes.</p>

<p>I&rsquo;ve learned a lot &ndash; about Clojure, idioms, and databases &ndash; over the seven
years that I&rsquo;ve been maintaining <code>org.clojure/java.jdbc</code>, and it is time for a
new namespace or perhaps even a completely new project, that offers a better
way to deal with SQL databases from Clojure! I&rsquo;ll be writing a series of blog
posts about the differences I envisage between the current de facto standard
JDBC wrapper and where I&rsquo;d like to go with this, so that I can get community
feedback on what should stay, what should change, and what should go. Stay tuned!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure 1.10's Datafy and Nav]]></title>
    <link href="http://corfield.org/blog/2018/12/03/datafy-nav/"/>
    <updated>2018-12-03T09:20:00-08:00</updated>
    <id>http://corfield.org/blog/2018/12/03/datafy-nav</id>
    <content type="html"><![CDATA[<p>One of the more mysterious new features in Clojure 1.10 seems to be the pairing of <a href="https://github.com/clojure/clojure/blob/master/changes.md#26-datafy-and-nav"><code>datafy</code> and <code>nav</code></a> (and their underlying protocols, <code>Datafiable</code> and <code>Navigable</code>). Interest in these new functions has been piqued after Stuart Halloway showed off <a href="https://www.youtube.com/watch?v=c52QhiXsmyI&amp;list=PLZdCLR02grLpMkEBXT22FTaJYxB92i3V3&amp;index=3">REBL at Clojure/conj</a> (video). Stu presented this functionality as &ldquo;generalized laziness&rdquo;: <code>datafy</code> produces a &ldquo;data representation&rdquo; of things and <code>nav</code> lets you (lazily) navigate around that data.<!-- more --></p>

<p>The <a href="http://rebl.cognitect.com/">REBL</a> &ldquo;is a graphical, interactive tool for browsing Clojure data&rdquo;. And in Clojure we&rsquo;re used to the concept of &ldquo;it&rsquo;s just data&rdquo; so a graphical browser might sound useful but not exactly earthshaking. But REBL is just an example of what can be built with the new functionality in 1.10 and, indeed, Stu&rsquo;s claim of &ldquo;generalized laziness&rdquo; is well made but a little hard to grok until you actually build something with the new protocols and functions.</p>

<p>Since I&rsquo;ve done exactly that &ndash; with experimental support for <a href="https://github.com/clojure/java.jdbc/blob/master/src/main/clojure/clojure/java/jdbc/datafy.clj">lazy navigation of related records in <code>java.jdbc</code></a> &ndash; and spent some time on Slack today explaining how it all works, I figured it would be worth writing down in a more permanent place, as a blog post.</p>

<p>The <code>Datafiable</code> protocol (new in <code>clojure.core.protocols</code>) is defined for <code>nil</code> and <code>Object</code> to just return those values as-is, and then extended in <code>clojure.datafy</code> to cover:</p>

<ul>
<li><code>Throwable</code> &ndash; producing a simple hash map by calling <code>Throwable-&gt;map</code></li>
<li><code>clojure.lang.IRef</code> &ndash; producing a vector containing the dereferenced value, with the original metadata from the reference attached to that vector</li>
<li><code>clojure.lang.Namespace</code> &ndash; producing a hash map that is the data representation of the namespace (<code>:name</code>, <code>:publics</code>, <code>:imports</code>, and <code>:interns</code>) with the metadata of the namespace attached</li>
<li><code>java.lang.Class</code> &ndash; producing the <code>clojure.reflect/reflect</code> representation of the class, with an additional member <code>:name</code>, and the <code>:members</code> of the class grouped by name and sorted</li>
</ul>


<p>The <code>Navigable</code> protocol (new in <code>clojure.core.protocols</code>) is defined just for <code>Object</code> and, given some sort of object or collection, some sort of &ldquo;key&rdquo;, and a value, it will just return the value itself.</p>

<p>Based on that, it may not be clear how to implement the protocols or use the functions. The key thing that may not be obvious here is that <code>datafy</code> is intended to convert an arbitrary &ldquo;thing&rdquo; of any type into a pure Clojure data representation and, from that starting point, you can then use <code>nav</code> to &ldquo;navigate&rdquo; to a value derived from the original &ldquo;thing&rdquo;, which you would then process with <code>datafy</code> to get a pure Clojure data representation again. Those data representations may contain pieces that satisfy the <code>Navigable</code> protocol so that navigation (via <code>nav</code>) provides more than just a simple data-level lookup.</p>

<p>Using the <code>clojure.java.jdbc.datafy</code> code as an example, you would call <code>query</code> (from that new namespace) and get back a result set. That looks like a sequence of hash maps (rows) but adds metadata to the rows that provides an implementation of <code>Datafiable</code> (<a href="https://github.com/clojure/clojure/blob/master/changes.md#22-protocol-extension-by-metadata">protocol extension via metadata</a> is also new in Clojure 1.10). The row is the &ldquo;arbitrary thing&rdquo; that we are starting with. One or more of the columns in that row may be a foreign key into another table. When you turn the row into a pure Clojure data representation &ndash; by calling <code>datafy</code> on it &ndash; it still looks like a hash map but now it has metadata that provides an implementation of <code>Navigable</code>. That supports calling <code>(nav row column value)</code> and, if the column is considered to be a foreign key to another table, it will fetch the relevant row(s) from that table and return that as the next &ldquo;arbitrary thing&rdquo;, otherwise it will just return the column&rsquo;s value as passed in. The cycle of converting that to data (via <code>datafy</code>) and navigating through it (by navigating the Clojure data and then calling <code>nav</code> on that) can be continued indefinitely, until you bottom out to simple values.</p>

<p>You can sum this up as:</p>

<ul>
<li>Starting with a &ldquo;thing&rdquo;&hellip;</li>
<li>&hellip;you convert it to data (with <code>datafy</code>)&hellip;</li>
<li>&hellip;and walk it with simple Clojure data access&hellip;</li>
<li>&hellip;and, at each stage, you can navigate to the corresponding &ldquo;new thing&rdquo; by calling <code>nav</code>&hellip;</li>
<li>&hellip;which may return just that value or may do something more complex&hellip;</li>
<li>&hellip;and from that &ldquo;new thing&rdquo; you convert it to data (with <code>datafy</code>) and continue the process.</li>
</ul>


<p>Relating this back to REBL, it works by taking some arbitrary value produced in the REPL and converting it to data (via <code>datafy</code>) so that it can be displayed in the UI. With any part of that data highlighted you can &ldquo;drill down&rdquo;, at which point REBL calls <code>nav</code> to perform the (potentially lazy, complex) navigation and then converts that to data (via <code>datafy</code>) and displays that as the next &ldquo;level&rdquo; of data. Given an associative data representation, it does <code>(get coll k)</code> first to get <code>v</code>, and then it calls <code>(nav coll k v)</code> to allow the underlying navigation to return an updated value.</p>

<p>You go from &ldquo;thing&rdquo; to &ldquo;data representation&rdquo; of &ldquo;thing&rdquo; (via <code>datafy</code>), and then you can do the simple associative lookup <em>in the data representation, not the original thing</em>, and then you use <code>nav</code> to get back to the relevant equivalent part of the &ldquo;thing&rdquo;, and then you <code>datafy</code> that again to get pure data. For built-in Clojure data types that are already pure data, <code>datafy</code> does nothing and <code>nav</code> just returns the selected value. For hash maps, navigation is just simple key lookup. For vectors, navigation is also simple key (index) lookup. This new machinery only starts to shine in more complex situations.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Excited About Clojure/conj]]></title>
    <link href="http://corfield.org/blog/2018/10/25/clojure-conj/"/>
    <updated>2018-10-25T03:40:00-07:00</updated>
    <id>http://corfield.org/blog/2018/10/25/clojure-conj</id>
    <content type="html"><![CDATA[<p>It has been a crazy busy year, both at work and personally, and it&rsquo;s hard for me to believe my last blog post was in April!</p>

<p><a href="https://2018.clojure-conj.org/">Clojure/conj</a> is coming up fast and the schedule was posted today, which has made me even more excited about it. Here&rsquo;s a run down of the sessions I plan to attend &ndash; I&rsquo;ll write up my thoughts on everything shortly after the conference.</p>

<ul>
<li>Welcome Event &ndash; I&rsquo;m hoping my flight is on time and Lyft can get me there in time to chill and network with all the interesting Clojurians!</li>
<li>Stuart Halloway &ndash; In his recent <a href="https://www.youtube.com/watch?v=6ftW8UwwP_4">Apropos podcast</a>, he hinted that this talk would be about new tooling he has been using. Maybe prepl-related?</li>
<li>Christopher Small &ndash; Clojure on the cyberpunk frontier of democracy &ndash; This sounds fascinating.</li>
<li>Chris Johnson Bidler &ndash; Serverless-ish: Zero to App with Datomic Cloud and GraphQL.</li>
<li>Ghadi Shayban &ndash; Java Made (Somewhat) Simple &ndash; Although Ghadi told me this might be a beginner/intermediate-level talk, he&rsquo;s a great speaker and I look forward to hearing his insights about the platform.</li>
<li>Boris Kourtoukov &ndash; Machines that Judge Us.</li>
<li>Tiago Luchini &ndash; Declarative Domain Modeling for Datomic Ion/Cloud.</li>
<li>Lily Goh + Dom Kiva-Meyer &ndash; Robust APIs with clojure.spec &amp; GraphQL &ndash; I&rsquo;m a huge advocate of spec and we&rsquo;re also using GraphQL at work so this should be very applicable.</li>
<li>Rich Hickey &ndash; Maybe Not &ndash; Rich is always worth the price of entry!</li>
<li>Unsessions &ndash; Looking forward to seeing the schedule for these. Past years' unsessions have included some real diamonds!</li>
<li>David Chelimsky &ndash; AWS, meet Clojure.</li>
<li>Ben Kamphaus &ndash; AI Systems: Foundations for Artificial Minds or Aaron Cummings &ndash; Making Memories: Clojure For Hardware Engineers (And Others). I&rsquo;m undecided but leaning toward the AI talk.</li>
<li>Elena Machkasova &ndash; Babel: middleware for beginner-friendly error messages &ndash; Anything that helps with Clojure&rsquo;s error messages (much improved in Clojure 1.10!) is always worth learning about!</li>
<li>Wilker Lucio da Silva &ndash; Scaling Full-Stack Applications Over Hundreds of Microservices or Daniel Gregoire &ndash; Tables Considered Helpful. Undecided again but leaning toward the table talk.</li>
<li>Nikolas Göbel &ndash; Reactive Datalog for Datomic or Tyler Hobbs &ndash; Code goes in, Art comes out. Undecided but leaning toward the Datalog talk (because I&rsquo;m not hugely interested in art/computing).</li>
<li>Gary Fredericks &ndash; What Are All These Class Files Even About? And Other Stories &ndash; Having been repeatedly bitten by AOT, I&rsquo;m looking forward to this!</li>
<li>Tomomi Livingstone + Hans Livingstone &ndash; Party REPL — A multi-player REPL built for pair-programming &ndash; This looks very, very interesting!</li>
<li>Rebecca Parsons &ndash; Closing day two keynote.</li>
<li>(Party!)</li>
<li>Carin Meier &ndash; Can you GAN? &ndash; No idea about the topic but Carin is always an engaging speaker.</li>
<li>Dave Fetterman &ndash; Learning and Teaching Clojure on the job at Amperity &ndash; Because coming up to speed (and bringing others up to speed) is important.</li>
<li>Vikash Mansinghka &ndash; Probabilistic programming and meta-programming in Clojure &ndash; WAT?</li>
<li>Alex Engelberg and Derek Slager &ndash; Every Clojure Talk Ever &ndash; Cryptically enticing&hellip;</li>
</ul>

]]></content>
  </entry>
  
</feed>
