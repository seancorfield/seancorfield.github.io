<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[An Architect's View]]></title>
  <link href="http://seancorfield.github.io/atom.xml" rel="self"/>
  <link href="http://seancorfield.github.io/"/>
  <updated>2014-06-20T21:29:23-07:00</updated>
  <id>http://seancorfield.github.io/</id>
  <author>
    <name><![CDATA[Sean Corfield]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Some Thoughts on Java 8]]></title>
    <link href="http://seancorfield.github.io/blog/2014/06/20/some-thoughts-on-java-8/"/>
    <updated>2014-06-20T17:58:34-07:00</updated>
    <id>http://seancorfield.github.io/blog/2014/06/20/some-thoughts-on-java-8</id>
    <content type="html"><![CDATA[<p><em>Originally posted on <a href="https://plus.google.com/u/0/+SeanCorfield_A/posts/dTiYLDXV5AV">Google Plus</a> on June 14th, 2014.</em></p>

<p><strong>Why Java 8 might win me back&hellip;</strong></p>

<p>I first started doing Java development in 1997. I was pretty invested in this &ldquo;new&rdquo; technology after being initially skeptical with my strong C++ background. I even wrote an editorial in a C++ journal about &ldquo;the new kid on the block&rdquo;, casting aspersions as to whether it had what it would take to become popular. Over time, Java became the juggernaut of corporate development and I actually found it quite refreshing after C++&rsquo;s somewhat obtuse syntax and complexities: Java was a simple language by comparison, with a well-structured, modular library.</p>

<p>At least, it started out that way.<!-- more --></p>

<p>Java and I parted ways around Java 5. I felt the changes were making it more complex without appropriate benefits. I thought generics and metadata were a disaster. I thought autoboxing would lead to sloppy code instead of forcing developers to think carefully about crossing the primitive/object boundary. I was ambivalent about varargs. I quite liked the new for loop and type-safe enums tho&#8217;. Java 6 and Java 7 left me cold (sure, the collection stuff was a step in the right direction, but most of the rest just piled complexity on complexity).</p>

<p>As far as I was concerned, Java had lost its way and become a bloated, verbose language that acted as a nursemaid to mediocre enterprise developers. I vowed I&rsquo;d never write Java again and took every opportunity to tell recruiters that whenever they contacted me with great opportunities for Java architect roles.</p>

<p>I went off to Groovy, then Scala, then Clojure. And there I&rsquo;ve stayed for the last three or four years.</p>

<p>When Java 8 was first getting press, I was very skeptical: how could they bring the elegance and ease of functional programming to a language so buried in boilerplate and a verbose, simplistic type system? I liked the simplicity of Groovy (and its dynamic approach to typing), I liked the elegance of Scala (even tho&#8217; I found the quirks of its type system and slow compilation to be significant drawbacks), and I really liked Clojure&rsquo;s combination of elegance, simplicity, and dynamic typing.</p>

<p>But, at World Singles, we run our dating platform on the JVM and so an upgrade to Java 8 was inevitable to take advantage of the improvements in heap management and garbage collection. Since I was testing everything on the new JVM, I figured I might as well take a look at Java&rsquo;s new language features&hellip;</p>

<p>And I was pleasantly surprised! Streams providing lazy/efficient map, filter, and reduce. Optional providing a way out of the null-checking tar pit of typical Java code. Lambda expressions providing a huge improvement in expressiveness and conciseness &ndash; compared to the ugly anonymous classes and single-method interfaces we&rsquo;d had to put up with before. All those new functional interfaces. Method references. A lot of improvements in the type system and type inference.</p>

<p>In many ways, Java 8 is a whole new language. It&rsquo;s still fairly verbose but its support for functional programming is actually not bad at all. There are still no immutable collections &ndash; maybe Java 9 will address that &ndash; but streams, lambdas, etc make a huge difference in what you can do with relative ease.</p>

<p>I think I can safely say that I would no longer rather fall on a sword than program in Java &ndash; as long as it&rsquo;s Java 8!</p>

<p><em>p.s. No, I&rsquo;m not switching from Clojure, but now I view Java as &ldquo;palatable&rdquo; rather than &ldquo;hideous&rdquo;.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Started]]></title>
    <link href="http://seancorfield.github.io/blog/2014/06/03/getting-started/"/>
    <updated>2014-06-03T18:42:36-07:00</updated>
    <id>http://seancorfield.github.io/blog/2014/06/03/getting-started</id>
    <content type="html"><![CDATA[<p>Sometimes it&rsquo;s very enlightening to look back at the beginning of a project to see how things got set up and how we started down the path that led to where we are today. In this post, I&rsquo;m going to talk about the first ten tickets we created at World Singles as we kicked off our green field rewrite project five years ago.<!-- more --></p>

<p>I&rsquo;ve been involved with World Singles for about five years now, about three and a half years as a full-time engineer. The project was a green field rewrite of a dating system the company had evolved over about a decade that, back in 2009, was running on ColdFusion 8 on Windows, and using SQL Server. The new platform soft-launched in late 2011 as we migrated a few small sites across and our full launch &ndash; migrating millions of members in the process &ndash; was May 2012. At that point we switched from &ldquo;build&rdquo; mode to &ldquo;operations&rdquo; mode, and today we maintain a large codebase that is a combination of CFML and Clojure, running on Railo 4.2 on Linux, and using MySQL and MongoDB, running partly in our East Coast data center and partly on Amazon.</p>

<p>Like all projects, it&rsquo;s had some ups and downs, but overall it&rsquo;s been great: I love my team, we love working with Clojure, and we have a steady stream of interesting problems to solve, working with a large user base, on a multi-tenant, multi-lingual platform that generates millions of records of data every day. It&rsquo;s a lot of fun. And we all get to work from home.</p>

<p>Sometimes it&rsquo;s very enlightening to look back at the beginning of a project to see how things got set up and how we started down the path that led to where we are today. In this post, I&rsquo;m going to talk about the first ten tickets we created as we kicked the project off. Eleven if you include ticket &ldquo;zero&rdquo;.</p>

<ul>
<li><p>#0 &ndash; Choose a bug tracking / ticketing system. We chose <a href="https://unfuddle.com/">Unfuddle</a>. It&rsquo;s clean and simple. It&rsquo;s easy to use. It provides Git (and SVN) hosting. It provides notebooks (wikis), ticketing, time management, customizable &ldquo;agile&rdquo; task boards, collaboration with external users, and it&rsquo;s pleasing to the eye. I&rsquo;ve never regreted our choice of Unfuddle (even when they did a massive overhaul of the UI and it took us a week or so to get used to the radically new ticket editing workflow!).</p></li>
<li><p>#1 &ndash; Version control. Yes, really, this was our first ticket in Unfuddle. The resolution to this ticket says:</p>

<blockquote><p>Selected vcs system (git), created repository in Unfuddle, and provided detailed documentation on why git, how to set it up, how to connect to the repo and how to work with git.</p></blockquote></li>
<li><p>And the documentation was all there in an Unfuddle notebook for the whole team. A good first step.</p></li>
<li><p>#2 &ndash; Developer image. Once we had version control setup and documented, we needed an easy way for every developer to have a full, self-contained local development environment. We had some developers on Windows, some on OS X, some on Linux, so we created a VMWare image with all the basic development tools, a database, a standardized ColdFusion installation, with Apache properly configured etc. This established a basic working practice for everyone on the team: develop and test everything locally, commit to Git, push to Unfuddle. We could then pull the latest code down to a showcase / QA server for the business team to review, whenever we or they wanted.</p></li>
<li><p>#3 &ndash; Project management system. Although we had bug tracking and wikis, we wanted to nail down how communication would work in practice. We created a project management mailing list for discussion threads. We created a notebook section in Unfuddle for documenting decisions and requirements. We decided to use Basecamp for more free-form evolution of business ideas. We agreed to use tickets in Unfuddle for all actionable work, and we settled on a Scrum-like process for day-to-day development, with short, regular sprints so we could get fast feedback from the business team, and they could easily see what progress we were making.</p></li>
<li><p>#4 &ndash; General project management. Since we had agreed to use Unfuddle for time tracking, we created a ticket against which to track project management hours that didn&rsquo;t fit into any actual work tickets. We used this for the first six months of the project (and logged about 300 hours against it).</p></li>
<li><p>#5 &ndash; Performance planning/tuning. This was mostly a placeholder (and initially focused on how to make a Reactor-based application perform better!). It was superceded by several more specific tickets, six months into the project. But it&rsquo;s one of those things we wanted on the radar early for tracking purposes.</p></li>
<li><p>#6 &ndash; Architectural planning. Like ticket #4, this was a time tracking bucket that we used for the first six months of the project.</p></li>
<li><p>#7 &ndash; Set up Continuous Integration. Yup, even before we got to our first actual coding ticket, as part of the early project setup, we wanted a Continuous Integration server. Whilst we were using ColdFusion for local development (prerelease builds of ACF9, at the time), we chose to use Railo 3.2 for the CI server so that we could ensure our code was cross-platform &ndash; we were still evaluating which engine to ultimately go to production with. The resolution of this ticket says:</p>

<blockquote><p>Apache / Tomcat / Railo / MySQL / Transparensee / Hudson in place. Automated test run restarts Railo, reloads the DB, reloads Transparensee, cleans the Reactor project, runs all test suites and generates test results.</p></blockquote></li>
<li><p>We developed an Ant script that stopped and started Railo, tore down and rebuilt the test database, using a canned dataset we created (with 1,000 random users), repopulated the search engine we use and cleaned up generated files, then ran our fledgling MXUnit test suite (and later our fledgling Selenium test suite).</p></li>
<li><p>#8 &ndash; Display About us/trust. This was our first actual code ticket. The company had selected ColdBox, ColdSpring, and Reactor as our basic frameworks (yeah, no ticket for that, it was a choice that essentially predated the project &ldquo;getting started&rdquo;). This ticket was to produce a first working skeleton of the application that could actually display dynamically generated pages of content from the database. We created the skeleton of the site navigation and handlers for each section as part of this ticket. The &ldquo;trust&rdquo; in the ticket title was about showing that we really could produce basic multilingual content dynamically and show an application architecture that worked for the business.</p></li>
<li><p>#9 &ndash; Implement resource bundles for templates. And this was also an early key requirement: so that we could support Internationalization from day one and perform Localization of each site&rsquo;s content easily.</p></li>
<li><p>#10 &ndash; Display appropriate template for each site. This was our other key requirement: the ability to easily skin each site differently. Like #9, this was an important proof of concept to show we could support multiple sites, in multiple languages, on a single codebase, with easy customization of page layouts, content, and even forms / questions we asked.</p></li>
</ul>


<p>So that&rsquo;s how we got started. Bug tracking, version control, local development environment, continuous integration and the key concepts tackled first!</p>

<p>A reasonable question is to ask what has changed in our approach over the five years since. We&rsquo;re still using Unfuddle (in case you&rsquo;re wondering, we&rsquo;re up to ticket 6537 as I write this!), we&rsquo;re still using Git (and still loving it). Our development stack has changed, as has some of our technology.</p>

<p>Over time we all migrated to Macs for development so maintaining the VM image stopped being important: everyone could have the entire development stack locally. We eventually settled on Railo instead of ColdFusion (we&rsquo;re on Railo 4.2 now), and we added MongoDB to MySQL a couple of years ago. We added some Scala code in 2010 to tackle a problematic long-running process (that did a lot of XML transformation and publishing). We added Clojure code in 2011 for a few key processes and then replaced Scala with Clojure and today Clojure is our primary language for all new development, often running inside Railo. We stopped using Reactor (we wrote a data mapper in Clojure that is very close to the &ldquo;metal&rdquo; of JDBC). Recently we stopped using MXUnit and replaced it with TestBox. We&rsquo;re slowing changing over from Selenium RC tests to WebDriver (powered by Clojure). We have about 20,000 lines of Clojure now and our CFML code base is holding steady at around 39,000 lines of Model and Controller CFCs and 45,000 lines of View cfm files.</p>
]]></content>
  </entry>
  
</feed>
