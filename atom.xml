<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[An Architect's View]]></title>
  <link href="http://corfield.org/atom.xml" rel="self"/>
  <link href="http://corfield.org/"/>
  <updated>2019-12-31T21:07:23-08:00</updated>
  <id>http://corfield.org/</id>
  <author>
    <name><![CDATA[Sean Corfield]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Happy New Releases!]]></title>
    <link href="http://corfield.org/blog/2019/12/31/releases/"/>
    <updated>2019-12-31T15:59:59-08:00</updated>
    <id>http://corfield.org/blog/2019/12/31/releases</id>
    <content type="html"><![CDATA[<h1>Wrapping Up 2019</h1>

<p>It&rsquo;s been a while since I blogged about the projects I maintain so I figured New Year&rsquo;s Eve 2019 was a good time to provide an update!</p>

<h2>expectations/clojure-test 1.2.1</h2>

<p>Mocking in <code>side-effects</code>, optional message argument in <code>expect</code> (like <code>is</code>), <code>between</code> predicate, official support for Clojure 1.8 onward, lots of documentation improvements!</p>

<p>See the <a href="https://github.com/clojure-expectations/clojure-test/blob/master/CHANGELOG.md">change log</a> for more details.</p>

<h2>jkk/honeysql 0.9.8</h2>

<p>Lots of bug fixes, some enhancements (<code>composite</code>, <code>truncate</code>), and some documentation enhancements.</p>

<p>See the <a href="https://github.com/jkk/honeysql/blob/master/CHANGES.md">change log</a> for more details.</p>

<h2>org.clojure/core.cache 0.8.2</h2>

<p>Add <code>clojure.core.cache.wrapped</code> to make using the library easier!</p>

<p>See the <a href="https://github.com/clojure/core.cache/blob/master/README.md#change-log">change log</a> for more details.</p>

<h2>org.clojure/core.memoize 0.8.2</h2>

<p>Bug fixes and a new <code>memoizer</code> function that makes it easier to define custom function caches.</p>

<p>See the <a href="https://github.com/clojure/core.memoize/blob/master/README.md#change-log">change log</a> for more details.</p>

<h2>org.clojure/java.data 0.1.5</h2>

<p>Yup, I took over maintenance of this in October!</p>

<p><code>set-properties</code> to set arbitrary properties post-construction, constructor argument support, numerous bug fixes and reflection warnings addressed.</p>

<p>See the <a href="https://github.com/clojure/java.data/blob/master/README.md#change-log">change log</a> for more details.</p>

<h2>org.clojure/java.jdbc 0.7.11</h2>

<p>This library is officially &ldquo;stable&rdquo; and no longer being actively maintained beyond critical bug fixes &ndash; please consider migrating to <code>seancorfield/next.jdbc</code> (see below).</p>

<p>That said, this got the same transaction rollback exception edge case fix and Turkish locale fix that <code>next.jdbc</code> already had.</p>

<p>See the <a href="https://github.com/clojure/java.jdbc/blob/master/README.md#change-log">change log</a> for more details.</p>

<h2>seancorfield/clj-new 0.8.2</h2>

<p>AOT compilation in <code>app</code> uberjar, <code>pom.xml</code> generation, <code>:uberjar</code> in <code>app</code> and <code>:jar</code> in <code>lib</code> and <code>template</code> projects, <code>-?</code> / <code>--query</code> option to explain what <code>clj-new</code> will attempt to do, <code>-e</code> / <code>--env</code> option to define &ldquo;environment&rdquo; variables that set substitution values in project templates, dependency updates, documentation improvements.</p>

<p>See the <a href="https://github.com/seancorfield/clj-new/blob/master/CHANGELOG.md">change log</a> for more details.</p>

<h2>seancorfield/depstar 0.4.2</h2>

<p>Support for Multi-Release JARs, AOT compilation for uberjars (with <code>pom.xml</code>), JDK 11 support, better handling of unknown file types.</p>

<p>See the <a href="https://github.com/seancorfield/depstar#changes">change log</a> for more details.</p>

<h2>seancorfield/next.jdbc 1.0.13</h2>

<p><code>next.jdbc.prepare/statement</code> and support for <code>java.sql.Statement</code>, arbitrary <code>Connection</code> and <code>Statement</code> property support, fix transaction rollback exception edge case (thank you Jepsen!), expose SQL builders, now tested against MS SQL Server and MySQL (formally), provide additional date/time/timestamp conversion support, CLOB support, <code>:jdbcUrl</code> support, HugSQL quick start guide, result set builder adapters, expanded Tips &amp; Tricks, lots of documentation enhancements!</p>

<p>See the <a href="https://github.com/seancorfield/next-jdbc/blob/master/CHANGELOG.md">change log</a> for more details.</p>

<h2>seancorfield/dot-clojure</h2>

<p>If you getting started with the <a href="https://clojure.org/guides/deps_and_cli">Clojure CLI and <code>deps.edn</code></a> then you might want to check out my <a href="https://github.com/seancorfield/dot-clojure">.clojure/deps.edn file</a> which contains a lot of useful aliases and hints &amp; tips to get you up and running with a powerful set of composable tools: create new projects, start various types of REPLs, run tests &ndash; against multiple versions of Clojure, build JARs and uberjars, benchmark your code, check for outdated dependencies, and more!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Do You Use clojure.spec]]></title>
    <link href="http://corfield.org/blog/2019/09/13/using-spec/"/>
    <updated>2019-09-13T04:00:00-07:00</updated>
    <id>http://corfield.org/blog/2019/09/13/using-spec</id>
    <content type="html"><![CDATA[<p>An interesting Clojure question came up on Quora recently and I decided that <a href="https://www.quora.com/If-you-use-Clojure-Spec-how-do-you-use-it-Do-you-tend-to-put-all-your-specs-in-one-place-or-distribute-them-through-the-modules-of-your-program/answer/Sean-Corfield?srid=upNN">my answer to &ldquo;how do you use clojure.spec&rdquo;</a> there should probably be a blog post so that folks without a Quora account can still read it. <em>[If you do have a Quora account, feel free to read it there instead and upvote it!]</em><!-- more --></p>

<p>The original question on Quora was:</p>

<blockquote><p>If you use Clojure Spec, how do you use it? Do you tend to put all your specs in one place or distribute them through the &ldquo;modules&rdquo; of your program?</p></blockquote>

<p>Here&rsquo;s what I wrote, back in August 2019:</p>

<p>We&rsquo;ve been using Spec very heavily at work since the first alpha builds appeared. We use Spec in a number of ways: we use it for data validation (production), we use it for test data generation for example tests and for generative testing of functions (as well as generative scenario testing &ndash; more below), we use it at dev time as a checker for function calls (instrumentation) as well as for deriving code from the specs of data structures.</p>

<p><strong>Data validation</strong></p>

<p>We write specs for our API inputs and these specs live in their own namespace, along with the predicates needed for the specs. We <code>s/conform</code> the inputs against the specs and test the result with <code>s/invalid?</code> If the inputs conformed, we process the conformed data, else we use <code>s/explain-data</code> and then a heuristic algorithm to turn the explained failure back into an error code and message for API consumers. Note that we actually do some coercion of string inputs into basic data types via some of these specs &ndash; this is not considered good practice by some people but we&rsquo;ve found it very convenient for this use case.</p>

<p>We make sure nearly all of these API input specs will generate so that we can use them to generate test data for example-based tests (next section) or generative testing of some APIs (this isn&rsquo;t practical for a lot of API endpoints but it can help in a few cases).</p>

<p><strong>Test data generation</strong></p>

<p>As noted above, we use the API input specs &ndash; and other specs &ndash; to generate some test data for example-based tests. We use this approach where we want a certain amount of random &ldquo;good&rdquo; data to throw at functions in general, when we only need to control a couple of the arguments or a couple of fields in those arguments &ndash; the randomly-generated data tends to be fairly &ldquo;edge case&rdquo; so it&rsquo;s a good test of robustness (e.g., strings that include Unicode characters, generated from a regex using Gary Fredericks' test.chuck library).</p>

<p><strong>Generative testing of functions</strong></p>

<p>For some &ldquo;key&rdquo; functions, we&rsquo;ll write specs that include <code>:ret</code> and/or <code>:fn</code> and we&rsquo;ll test these generatively. The specs live in the same namespace as the functions, usually immediately above the function they are for. Some of these generative checks are run as part of our main test suite (so they are run every time). Some are too slow for that and the <code>check</code> calls live in <code>(comment ,,,)</code> to be run manually when we&rsquo;ve been working on the function in question (we use Rich Comment Forms a lot for code that is convenient for our development workflow but does not really constitute test code).</p>

<p><strong>Generative scenario testing</strong></p>

<p>This might be an unusual use of specs but I think it&rsquo;s potentially an important one. If you have an interactive application, you will have a number of paths through it that your users can take to get to certain known states. If you think of the paths as collections of user-generated events then you can write a spec for those (valid) paths through the application and you can then rely on spec to generate events that you can use to drive your application and then verify the end state. These specs live in the tests where they are needed.</p>

<p><strong>Development time checking</strong></p>

<p>This is a pretty basic, standard use of spec. Write specs for data structures and some functions. The latter live with the functions (<code>s/fdef</code> immediately above <code>defn</code>). The former may live with the functions if they are tightly coupled to them or in their own namespace if they are more concerned with data structures used by various namespaces. Then you instrument those functions while you are working in the REPL, doing day-to-day development.</p>

<p>Another use of specs in development/testing is within the tests where we want to verify that results from functions are the expected &ldquo;shape&rdquo; in example-based tests. In this case we write specs for &ldquo;good&rdquo; results and &ldquo;bad&rdquo; results and we use <a href="https://github.com/clojure-expectations/clojure-test">clojure-expectations/clojure-test</a> as an add-on for <code>clojure.test</code> so that we can <code>(expect ::some-spec (a-function call here))</code> &ndash; a more expressive form of <code>clojure.test/is</code>.</p>

<p><strong>Deriving code from specs</strong></p>

<p>In this case we write specs for data structures, such as rows in database tables, and then we generate named CRUD operations and supporting functionality from the specs themselves &ndash; using macros that take specs as input with some control parameters and expand into a number of <code>defn</code> and other forms. The important aspect of this is that the spec is the &ldquo;system of record&rdquo; for the data structure: it can be used for validation, test data generation, and as the source for the keys and &ldquo;types&rdquo; that shape the functions needed to operate on them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Release! Release! Release!]]></title>
    <link href="http://corfield.org/blog/2019/08/07/releases/"/>
    <updated>2019-08-07T08:30:00-07:00</updated>
    <id>http://corfield.org/blog/2019/08/07/releases</id>
    <content type="html"><![CDATA[<h1>Lots of Releases</h1>

<p>Over the last week or so I&rsquo;ve released minor updates to several of the projects I maintain, so I thought it would be nice to have a summary blog post rather than a scattering of minor announcements.</p>

<h2>clj-time 0.15.2</h2>

<p>Add type hints, fix a bug in <code>overlaps?</code>, improve tests and documentation.</p>

<p>See the <a href="https://github.com/clj-time/clj-time/blob/master/ChangeLog.md">change log</a> for more details.</p>

<h2>jkk/honeysql 0.9.5</h2>

<p>Support JDK11 for dev/test, support Turkish language users, enhance <code>format-predicate</code> to match <code>format</code> (<code>parameterizer</code>).</p>

<p>See the <a href="https://github.com/jkk/honeysql/blob/master/CHANGES.md">change log</a> for more details.</p>

<h2>seancorfield/clj-new 0.7.7</h2>

<p>Pin Clojure (and <code>test.check</code>) version in generated projects instead of using <code>"RELEASE"</code>.</p>

<p>See the <a href="https://github.com/seancorfield/clj-new/blob/master/CHANGELOG.md">change log</a> for more details.</p>

<h2>seancorfield/depstar 0.3.1</h2>

<p>Add <code>-m</code> / <code>--main</code> option to override <code>Main-Class</code> in generated manifest.</p>

<p>See the <a href="https://github.com/seancorfield/depstar#changes">change log</a> for more details.</p>

<h2>seancorfield/next.jdbc 1.0.5</h2>

<p><code>plan</code>&rsquo;s &ldquo;mapified&rdquo; <code>ResultSet</code> is now a full <code>IPersistentMap</code> implementation which adds support for <code>cons</code>, <code>count</code>, <code>dissoc</code>, <code>empty</code>, etc. Continued improvements to documentation.</p>

<p>See the <a href="https://github.com/seancorfield/next-jdbc/blob/master/CHANGELOG.md">change log</a> for more details.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Next.JDBC to 1.0.0 and Beyond!]]></title>
    <link href="http://corfield.org/blog/2019/07/04/next-jdbc/"/>
    <updated>2019-07-04T03:00:00-07:00</updated>
    <id>http://corfield.org/blog/2019/07/04/next-jdbc</id>
    <content type="html"><![CDATA[<h1>next.jdbc 1.0.0 and 1.0.1</h1>

<p>First off, <a href="https://github.com/seancorfield/next-jdbc/releases/tag/v1.0.0">seancorfield/next.jdbc 1.0.0</a> was released on June 13th, 2019 (and I <a href="https://clojureverse.org/t/next-jdbc-1-0-0-the-gold-release/4379">announced it on ClojureVerse</a> but did not blog about it), and yesterday I released <a href="https://github.com/seancorfield/next-jdbc/releases/tag/v1.0.1">seancorfield/next.jdbc 1.0.1</a> which is mostly documentation improvements.</p>

<p>Someone recently commented that this blog had the <a href="https://corfield.org/blog/2019/06/04/next-jdbc/">Release Candidate announcement</a> on June 4th and was surprised I didn&rsquo;t &ldquo;make a big deal&rdquo; about the &ldquo;gold&rdquo; release. The 1.0.0 release is a <strong>big deal</strong> and this blog post is about that &ndash; what it&rsquo;s taken to get here and what&rsquo;s to come.<!-- more --></p>

<h2>clojure.contrib.sql</h2>

<p>I learned Clojure back in 2010 and started using it at work in early 2011. For us to use it in production, we needed JDBC support but <code>clojure.contrib.sql</code> was not being actively maintained at that point and the Clojure 1.3 release was in its Alpha phase. Part of the 1.3 release cycle involved <a href="https://clojure.org/community/contrib_history">breaking up the &ldquo;Monolithic Contrib&rdquo; from the 1.2 release and finding new maintainers</a> in order for its parts to move forward. That&rsquo;s how I became the maintainer of <a href="https://github.com/clojure/java.jdbc"><code>clojure.java.jdbc</code></a> &ndash; <code>clojure.contrib.sql</code>&rsquo;s new name and home. <code>clojure.java.jdbc</code> started life with an 0.0.1 release.</p>

<h2>clojure.java.jdbc</h2>

<p>The 0.0.x releases mostly focused on compatibility with more databases and ease of use enhancements.</p>

<p>0.1.0 rewrote the result set handling to use regular Clojure hash maps instead of the deprecated <code>struct-map</code> machinery, hence the bump in version numbers. The 0.1.x releases continued to expand database support, expand the API, and fix bugs.</p>

<p>0.2.0 merged the internal namespace into the main <code>clojure.java.jdbc</code> namespace and adjusted the visibility (and naming) of several symbols, hence the bump in version numbers. The 0.2.x releases continued the path of improving database support, improving usability, fixing bugs, and some performance improvements.</p>

<p>0.3.0 was a fairly massive overhaul of the API &ndash; these were definitely breaking changes, as most of the existing API was deprecated (based on the dynamic <code>*db*</code> variable), and a new API introduced (which accepted the db spec everywhere as an argument, including the first versions of <code>insert!</code>, <code>query</code>, <code>update!</code>, <code>delete!</code>, and <code>execute!</code>). 0.3.0 also introduced <code>IResultSetReadColumn</code> and <code>ISQLValue</code> as extension points. Prerelease builds of 0.3.0 introduced a mini-DSL for building SQL but that was removed before the gold release &ndash; the DDL support stayed, however. The 0.3.x releases mostly focused on bug releases after the big upheaval in the API, and adding support for more and more options. The modern &ldquo;db-spec&rdquo; with <code>:dbtype</code> and <code>:dbname</code> was introduced during this time.</p>

<p>0.4.0 dropped support for Clojure 1.2 and the 0.4.x releases fixed bugs, broadened database support, and added yet more options.</p>

<p>0.5.0 dropped support for Clojure 1.3 and 0.5.5 started the shift from &ldquo;named&rdquo; arguments (unrolled keyword arguments) to passing options in a single hash map, which makes it much easier to compose function calls. The 0.5.x releases continued deprecation of the unrolled keyword arguments.</p>

<p>0.6.0 removed all deprecated APIs and signatures. This was a pretty volatile time to be using <code>clojure.java.jdbc</code>. There was a 0.6.1 release but the upcoming 0.6.2 release became a series of 0.7.0 prerelease builds as I replumbed the functions to correctly pass options through the entire chain, and dropped support for Clojure 1.4, 1.5, and finally 1.6&hellip; This also saw the introduction of <code>reducible-query</code> (which laid the groundwork for <code>next.jdbc</code>).</p>

<p>By the time 0.7.0 was released, I was beginning to think more seriously about a 1.0.0 release. The 0.7.x releases continued to expand database support, to add more and more options, and also started to look at performance improvements.</p>

<h2>Contrib Evolving</h2>

<p>I&rsquo;d solicited feedback from the Clojure/core folks about what it would mean for a 1.0.0 release at various points, starting as far back as the 0.3x series of releases, and I&rsquo;d been folding that feedback into the various changes over time. Also, over time, it became clear that Clojure/core were less worried about placing restrictions on how maintainers ran their projects. Some Contrib libraries had their 1.0.0 releases and continued on, some were still in the 0.0.x phase, others run the gamut from 0.1.x to 0.10.x.</p>

<p>It&rsquo;s good to read <a href="https://clojure.org/news/2012/02/17/clojure-governance">Stuart Sierra&rsquo;s post from 2012</a> about how Clojure (and Contrib&rsquo;s) governance evolved over the years, as well as the <a href="https://clojure.org/community/contrib_libs">current state of Contrib libraries</a>. In addition to the recent clarifications about Contrib&rsquo;s purpose and governance, we&rsquo;ve seen <code>clojure.tools.nrepl</code> fork back out of Contrib as <a href="https://github.com/nrepl/nrepl">nrepl/nrepl</a> and a lot of adjustment in tooling to adapt to the new group, artifact, and namespace names.</p>

<p>It was in this environment that I continued to think about what a 1.0.0 release of <code>clojure.java.jdbc</code> should be. At Clojure/conj (2018), I was excited about <a href="https://github.com/cognitect-labs/REBL-distro">REBL</a> and <code>datafy</code>/<code>nav</code>, and I introduced <a href="https://corfield.org/blog/2018/12/03/datafy-nav/">experimental support for all that in <code>clojure.java.jdbc</code></a>. I was also thinking about <code>clojure.spec</code> and the shift to qualified keywords and the increased use of transducers and the focus on simplicity and consistency&hellip;</p>

<h2>The Birth of next.jdbc</h2>

<p>It was around that point that I realized that I wouldn&rsquo;t really be comfortable declaring a 1.0.0 release on <code>clojure.java.jdbc</code>: there was no natural &ldquo;end state&rdquo; and it had become large and complex (and slow in places) &ndash; and I couldn&rsquo;t realistically change that without making a whole &lsquo;nother round of breaking changes. But this time I heeded <a href="https://www.youtube.com/watch?v=oyLBGkS5ICk">Rich&rsquo;s advice about accretion and fixation</a> and started to design the &ldquo;next&rdquo; version of <code>clojure.java.jdbc</code> not as a series of (breaking) changes to what already existed but as a completely new set of functions built on a completely new set of implementations, based on what I&rsquo;d learned from nearly eight years of maintaining <code>clojure.java.jdbc</code>.</p>

<p>I talk about my <a href="https://github.com/seancorfield/next-jdbc#motivation">motivation for this new JDBC wrapper</a> in the project README but I&rsquo;ll provide a bullet point recap here as well:</p>

<ul>
<li>Improve performance,</li>
<li>Provide a &ldquo;modern&rdquo; Clojure approach/API,</li>
<li>Provide a simpler library/API.</li>
</ul>


<p>I spent a month or so sketching out what this new version of the library would look like and how it would behave using a local git repository (stored on OneDrive). I first mentioned that I was working on it in early January (in <a href="https://clojureverse.org/t/what-http-server-library-to-use/3423/29?u=seancorfield">a thread about HTTP servers on ClojureVerse</a>, of all places) and moved it into a private GitHub repository, once I had usable code. Over the next three months, I continued to develop it until the first public release on April 21st: 1.0.0-alpha8. Over the next month, I gathered feedback from anyone who was willing to use it, making a few small adjustments in the API, until the first stable release on May 25th: 1.0.0-beta1.</p>

<p>One of the key decisions I had to make was whether this would become new namespaces inside <code>clojure.java.jdbc</code> in Contrib or live standalone somewhere &ndash; because I viewed it very much as the &ldquo;next version&rdquo; of that Contrib library. I was surprised that no one seemed to care if a library was published under someone&rsquo;s name as a group ID, nor even if the namespaces themselves contained someone&rsquo;s name. I&rsquo;d viewed Contrib&rsquo;s well-maintained Continuous Integration system and automated documentation generator as pros, along with my perception that Contrib libraries were easy to find and had some stamp of &ldquo;authority&rdquo; by virtue of being in the <code>clojure</code> GitHub organization &ndash; but I seemed to be very much in the minority in that perception. Once I had CI set up for <a href="https://circleci.com/gh/seancorfield/next-jdbc"><code>next.jdbc</code> on CircleCI</a> and auto-generated <a href="https://cljdoc.org/d/seancorfield/next.jdbc">documentation for <code>next.jdbc</code> on cljdoc.org</a>, I decided that <code>seancorfield/next.jdbc</code> was going to live on, outside Contrib.</p>

<h2>Beta 1 and Stability</h2>

<p>I mentioned above that I considered Beta 1 to be the first stable release. Having gone through so many breaking changes with <code>clojure.java.jdbc</code> and having listened to Rich (and others in the Clojure community) talk about the need for backward compatibility and the futility of semantic versioning, it was important to me that I could draw a line in the sand at some point and say &ldquo;no more breaking changes&rdquo;. I decided that the move from Alpha to Beta should be that line for <code>next.jdbc</code> and the last breaking change was renaming <code>reducible!</code> to <code>plan</code> as part of the beta release &ndash; indeed, that was the gating factor for exiting the alpha phase of development.</p>

<p>My goal is to never break backward compatibility across future versions of <code>next.jdbc</code> &ndash; only adding new functionality (and fixing things that are clearly broken). I expect future versions to appear slowly and contain very few additional features, perhaps focusing mostly on improving the documentation in response to questions from users of the library.</p>

<h2>Wrapping Up</h2>

<p>I couldn&rsquo;t have made <code>next.jdbc</code> without a lot of lessons learned from eight years of maintaining <code>clojure.java.jdbc</code> and all the feedback from the community &ndash; both on <code>clojure.java.jdbc</code> itself and during the alpha phase of <code>next.jdbc</code>&rsquo;s development. It&rsquo;s faster, more modern, and simpler than <code>clojure.java.jdbc</code>. It embraces the host platform by being based on JDBC types directly, but offers value beyond being &ldquo;just&rdquo; a wrapper for those types and their methods. It looks to the future by yielding qualified keywords by default, supporting <code>datafy</code>, <code>nav</code>, and focusing on reducing/transducing as a core part of the main API (via <code>plan</code>).</p>

<p>I consider <code>next.jdbc</code> to be the 1.0.0 release that <code>clojure.java.jdbc</code> was never going to achieve.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Next.JDBC Release Candidate 1]]></title>
    <link href="http://corfield.org/blog/2019/06/04/next-jdbc/"/>
    <updated>2019-06-04T11:30:00-07:00</updated>
    <id>http://corfield.org/blog/2019/06/04/next-jdbc</id>
    <content type="html"><![CDATA[<h1>seancorfield/next.jdbc 1.0.0-rc1</h1>

<p><code>next.jdbc</code> &ndash; the &ldquo;next generation&rdquo; of <code>clojure.java.jdbc</code> &ndash; is a modern Clojure wrapper for JDBC. The first Release Candidate is now available to test &ndash; containing only accretive and fixative changes from Beta 1. The API should be considered stable enough for production usage.</p>

<p><a href="https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-rc1/doc/readme">https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-rc1/doc/readme</a></p>

<p>The focus of this release is providing more flexibility in result set builders, so that it is easier to implement your own naming strategies, via new builders that accept <code>:label-fn</code> and <code>:qualifier-fn</code> options. These mirror the <code>:column-fn</code> and <code>:table-fn</code> options used in <code>next.jdbc.sql</code> &ndash; which are updated versions of <code>clojure.java.jdbc</code>&rsquo;s <code>:entities</code> option. These new builder options are updated versions of <code>clojure.java.jdbc</code>&rsquo;s <code>:identifiers</code> option.</p>

<h2>Changes since Beta 1</h2>

<ul>
<li>Fix #24 by adding return type hints to <code>next.jdbc</code> functions.</li>
<li>Fix #22 by adding <code>next.jdbc.optional</code> with six map builders that omit <code>NULL</code> columns from the row hash maps.</li>
<li>Documentation improvements (#27, #28, and #29), including changing &ldquo;connectable&rdquo; to &ldquo;transactable&rdquo; for the <code>transact</code> function and the <code>with-transaction</code> macro (for consistency with the name of the underlying protocol).</li>
<li>Fix #30 by adding <code>modified</code> variants of column name functions and builders. The <code>lower</code> variants have been rewritten in terms of these new <code>modified</code> variants. This adds <code>:label-fn</code> and <code>:qualifier-fn</code> options that mirror <code>:column-fn</code> and <code>:table-fn</code> for row builders.</li>
</ul>


<p>Please take it for a test drive and let me know if you run into any problems via <a href="https://github.com/seancorfield/next-jdbc/issues">GitHub issues</a> or in the <a href="https://clojurians.slack.com/messages/C1Q164V29/details/"><code>#sql</code> channel on the Clojurians Slack</a> or the <a href="https://clojurians.zulipchat.com/#narrow/stream/152063-sql"><code>#sql</code> stream on the Clojurians Zulip</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Next.JDBC Beta 1]]></title>
    <link href="http://corfield.org/blog/2019/05/25/next-jdbc/"/>
    <updated>2019-05-25T08:00:00-07:00</updated>
    <id>http://corfield.org/blog/2019/05/25/next-jdbc</id>
    <content type="html"><![CDATA[<h1>seancorfield/next.jdbc 1.0.0-beta1</h1>

<p><code>next.jdbc</code> &ndash; the &ldquo;next generation&rdquo; of <code>clojure.java.jdbc</code> &ndash; is a modern Clojure wrapper for JDBC. Beta 1 is now available to test &ndash; only accretive and fixative changes will be made from this point on, so the API should be considered stable enough for production usage.</p>

<p><a href="https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-beta1/doc/readme">https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-beta1/doc/readme</a></p>

<p>The group and artifact ID will remain <code>seancorfield/next.jdbc</code>, the namespace structure will remain <code>next.jdbc.*</code>. With auto-generated documentation hosted on cljdoc.org and Continuous Integration testing hosted on circleci.com, I have decided to continue work on <code>next.jdbc</code> outside Clojure Contrib, rather than merge it into <code>clojure.java.jdbc</code> as new namespaces there. I have updated the <a href="https://github.com/seancorfield/next-jdbc/blob/master/CONTRIBUTING.md">Contributing page on GitHub</a> to reflect that Pull Requests can now be submitted.</p>

<h2>Changes since Alpha 13</h2>

<ul>
<li>Set up CircleCI testing (just local DBs for now).</li>
<li>Address <a href="https://github.com/seancorfield/next-jdbc/issues/21">#21</a> by adding <code>next.jdbc.specs</code> and documenting basic usage.</li>
<li>Fix <a href="https://github.com/seancorfield/next-jdbc/issues/19">#19</a> by caching loaded database driver classes.</li>
<li>Address <a href="https://github.com/seancorfield/next-jdbc/issues/16">#16</a> by renaming <code>reducible!</code> to <code>plan</code> (this is a <strong>BREAKING CHANGE!</strong> from Alpha 13 &ndash; the naming of this function was the blocker for moving from Alpha to Beta).</li>
<li>Address <a href="https://github.com/seancorfield/next-jdbc/issues/3">#3</a> by deciding to maintain this library outside Clojure Contrib.</li>
</ul>


<p>Please take it for a test drive and let me know if you run into any problems via <a href="https://github.com/seancorfield/next-jdbc/issues">GitHub issues</a> or in the <a href="https://clojurians.slack.com/messages/C1Q164V29/details/"><code>#sql</code> channel on the Clojurians Slack</a> or the <a href="https://clojurians.zulipchat.com/#narrow/stream/152063-sql"><code>#sql</code> stream on the Clojurians Zulip</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Next.JDBC]]></title>
    <link href="http://corfield.org/blog/2019/04/21/next-jdbc/"/>
    <updated>2019-04-21T16:00:00-07:00</updated>
    <id>http://corfield.org/blog/2019/04/21/next-jdbc</id>
    <content type="html"><![CDATA[<h1>seancorfield/next.jdbc 1.0.0-alpha8</h1>

<p>I&rsquo;ve talked about this in a few groups &ndash; it&rsquo;s been a long time coming. This is the &ldquo;next generation&rdquo; of <code>clojure.java.jdbc</code> &ndash; a modern wrapper for JDBC, that focuses on <code>reduce</code>/transducers, qualified-keywords, and <code>datafy</code>/<code>nav</code> support (so, yes, it requires Clojure 1.10).</p>

<p><a href="https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-alpha8/doc/readme">https://cljdoc.org/d/seancorfield/next.jdbc/1.0.0-alpha8/doc/readme</a></p>

<p><em>The next generation of <code>clojure.java.jdbc</code>: a new low-level Clojure wrapper for JDBC-based access to databases.</em>  It&rsquo;s intended to be both faster and simpler than <code>clojure.java.jdbc</code> and it&rsquo;s where I intend to focus my future energy, although I have not yet decided whether it will ultimately be a new set of namespaces in the Contrib lib or a separate, standalone OSS library!</p>

<p>At this point, I&rsquo;m looking for feedback on the API and the approach (as well as bugs, performance issues, etc). Please take it for a spin and let me know what you think via <a href="https://github.com/seancorfield/next-jdbc/issues">GitHub issues</a> or in the <a href="https://clojurians.slack.com/messages/C1Q164V29/details/"><code>#sql</code> channel on the Clojurians Slack</a> or the <a href="https://clojurians.zulipchat.com/#narrow/stream/152063-sql"><code>#sql</code> stream on the Clojurians Zulip</a>.</p>

<p><em>The group/artifact ID will change at some point:</em> and the actual namespaces will too, but I will try to make that as painless as possible when I take this out of the alpha phase.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojurians Slack Alternatives]]></title>
    <link href="http://corfield.org/blog/2019/02/11/clojurians-slack-alternatives/"/>
    <updated>2019-02-11T04:10:00-08:00</updated>
    <id>http://corfield.org/blog/2019/02/11/clojurians-slack-alternatives</id>
    <content type="html"><![CDATA[<p>Daniel Compton has continued his excellent trend of
<a href="https://danielcompton.net/2019/02/06/clojure-survey-2019">writing an analysis of the State of Clojure survey comments</a>
and one of the comments in his <strong>Community</strong> section stood out for me:</p>

<blockquote><p>&ldquo;I suggest moving off of slack to a more accessible chat system. Losing history is a bad thing. Check out discord or matrix or gitter or mattermark or any other number of tools made for this purpose.&rdquo;</p></blockquote>

<!-- more -->


<p>The <a href="https://clojurians.slack.com/">Clojurians Slack</a> <em>[sign up <a href="http://clojurians.net/">here</a>]</em>
started as a small experiment about four years ago and has been far more
successful than anyone could have imagined, with around 15K members signed up
and around 1,700 members considered &ldquo;active&rdquo; on a weekly basis (which means it
would cost almost $9K per month to run this as a paid service!).</p>

<p>A perennial complaint about Slack&rsquo;s free plan is that it limits the accessible
message history to just the most recent 10K messages. In a busy Slack like
Clojurians that limit is hit after three or four days, heavily limiting the
ability to refer back to conversations or to use the massive amount of
&ldquo;knowledge&rdquo; shared there for reference &ndash; exactly as noted in the comment above.</p>

<p>Why that comment inspired me to write this post is that most of the suggested
communities already exist, and have been around for quite some time. Two of
them are linked from the right hand column of the <a href="https://www.reddit.com/r/Clojure/">Clojure sub-Reddit</a>
but here&rsquo;s the list directly:</p>

<ul>
<li><a href="https://discordapp.com/invite/v9QMy9D">Discord</a></li>
<li><a href="https://gitter.im/clojure/general">Gitter</a> &ndash; there are several Clojure rooms on Gitter, most of them are linked to open source projects on GitHub</li>
<li><a href="https://riot.im/app/#/room/#clojure:matrix.org">Matrix/Riot</a></li>
<li>Mattermost &ndash; I&rsquo;m not sure if anyone has set up a Clojure community on Mattermost but several people have advocated for it</li>
</ul>


<p>The &ldquo;original&rdquo; online Clojure community still exists and is still active on IRC
(freenode), of course, and there&rsquo;s also <a href="https://braid.chat/">Braid</a> (written in
Clojure/ClojureScript!).</p>

<p>I was a bit surprised that the commenter did not mention <a href="https://clojurians.zulipchat.com/">Clojurians on Zulip</a>
because that community, started back in early November 2018, already has five hundred
members and seems, to me, like the most capable alternative to Slack. It&rsquo;s open
source, <a href="https://zulipchat.com/for/open-source/">hosted for free to open source communities</a>,
and &ldquo;has a significantly larger and more active development community than other
modern open source group chat solutions like Mattermost, Rocket.Chat, and matrix.org.&rdquo;
Read their <a href="https://zulipchat.com/why-zulip/">Why Zulip? page</a> for more
information about the service and how it compares (specifically to Slack).</p>

<p>One-way bridging between select Slack channels and Zulip streams has been in
place for a while and currently about fifty of the most popular channels on
Slack are available to read in Zulip streams, along with many other active
streams in Zulip. This means you can try Zulip without missing out on Slack
conversations &ndash; some people prefer Zulip&rsquo;s UI just for reading Slack messages!</p>

<p>Clojurians on Slack isn&rsquo;t going away &ndash; a lot of people love the UI and don&rsquo;t
consider the message history limit to be a big deal &ndash; and if you&rsquo;re already
using Slack for work, then it makes perfect sense to also use that for your
Clojure community fix (since you only need one chat client open). The Slack
community isn&rsquo;t &ldquo;official&rdquo; in any way, and you&rsquo;re all welcome to try other
chat clients, but if you feel strongly about open source and unlimited search
history, check out <a href="https://clojurians.zulipchat.com/">Clojurians on Zulip</a>
and if you like it, promote it and encourage other Clojurians to join you
there.</p>

<p>Me? I&rsquo;m one of the long-time admins/moderators of Clojurians on Slack, but I&rsquo;ve
also tried each and every one of the alternatives that various community members
have set up over the last four years. <a href="https://clojurians.zulipchat.com/">Clojurians on Zulip</a>
is the one I&rsquo;ve found myself most active in and the only alternative chat client
that I always have open at this point!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Atom, Chlorine, and Windows]]></title>
    <link href="http://corfield.org/blog/2019/01/22/atom-chlorine-windows/"/>
    <updated>2019-01-22T12:15:00-08:00</updated>
    <id>http://corfield.org/blog/2019/01/22/atom-chlorine-windows</id>
    <content type="html"><![CDATA[<p>About a month ago, I was <a href="http://corfield.org/blog/2018/12/19/atom-chlorine/">praising Chlorine, the new Clojure package for
Atom</a> and I&rsquo;ve been using
it, day-in, day-out, for all my Clojure development. On a Mac, that&rsquo;s
straightforward because I start a Socket REPL on the Mac and I run Atom on the
Mac so when I connect via Chlorine and issue the <code>Chlorine: Load File</code>
command (via <code>Ctrl-, f</code> in my keymap), it sends <code>(load-file "/path/to/file.clj")</code>
to the REPL, for the file being edited, and that is evaluated and loads the
source from disk and compiles it. On Windows&hellip;<!-- more --> Well, on Windows
there are a few obstacles to this workflow.</p>

<p>The first obstacle (for me) is that <code>clj</code> doesn&rsquo;t run on Windows and that&rsquo;s
what I use for everything Clojure on a Mac and on Linux now. There&rsquo;s a
PowerShell implementation in progress but Windows has always been a bit of a
second-class citizen so it&rsquo;s still a ways off. But Windows has WSL (Windows
Subsystem for Linux) so I can
and do run (user-mode) Ubuntu on my Windows laptop and I do all of my Clojure
work on that&hellip;</p>

<p>&hellip;but that brings the second obstacle: file paths on Windows look like
<code>C:\path\to\file.clj</code> and under WSL they look like <code>/mnt/c/path/to/file.clj</code>.
That means your editor on Windows and your REPL on Linux don&rsquo;t quite speak the
same language.</p>

<p>Fortunately, the latest release of Chlorine, 0.0.8, has a &ldquo;smart&rdquo; <code>Load File</code>
command that will work with both a Windows-based Socket REPL and a WSL-based
Socket REPL! It wraps the call to <code>load-file</code> in logic that looks at the
requested file path and also at the
<code>user.dir</code> JVM property and if the former starts with a drive identifier and <code>:</code>,
and the latter does not, it assumes the REPL is running on WSL on Windows and
maps the file path appropriately.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chlorine: Clojure Integration for Atom]]></title>
    <link href="http://corfield.org/blog/2018/12/19/atom-chlorine/"/>
    <updated>2018-12-19T22:45:00-08:00</updated>
    <id>http://corfield.org/blog/2018/12/19/atom-chlorine</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been using the <a href="https://atom.io">Atom</a> editor for about two years now.
I switched from Emacs after Clojure/conj 2016, having seen
<a href="https://youtu.be/buPPGxOnBnk">Jason Gilman&rsquo;s talk about ProtoREPL</a> [video].
It may sound like
heresy, but I&rsquo;d never been happy with Emacs<!-- more --> &ndash; not 17.x back when I first
started using it, not 18.x, not 19.x when I first stopped using it, nor 24.x onward
when I came back to it after learning Clojure a few decades later. I built
several configurations from scratch, I tried several &ldquo;curated&rdquo; configurations,
none of them felt like &ldquo;home&rdquo;. Emacs just leeched too much of my development
time for my tastes. I wanted a simple, modern text editor, that offered a wide
variety of &ldquo;plugins&rdquo; and supported all the languages I used, with a sane set of
defaults. Atom &ndash; with ProtoREPL &ndash; seemed to be exactly what I was looking for!</p>

<p>And for two years, it has been my day-to-day development environment.</p>

<p>But it has been frustrating that ProtoREPL hasn&rsquo;t been getting a huge amount of
love lately. Two releases immediately after that Conj, eleven in the first
half of 2017, and just three since then (in a year and a half).
With the advent of Clojure 1.10 and
<a href="https://github.com/cognitect-labs/REBL-distro">REBL</a>, I wanted to extend
ProtoREPL so I could integrate REBL into my workflow, so I forked it and
hacked in <code>inspect-block</code> and <code>inspect-top-block</code> functionality (see the
<a href="https://github.com/seancorfield/proto-repl/compare/4b13ebf9d0f1e228ab7800c4bc54fe071bacf29e...master">commit log</a>). But it&rsquo;s written in
CoffeeScript and that made me sad.</p>

<p>I&rsquo;ve also had a bit of a long-running love/hate relationship with
<a href="https://github.com/nrepl/nrepl">nREPL</a> over its lifetime. Something about the
wire protocol and overall architecture of it just bothered me and I longed for
tooling built on what Clojure provides out-of-the-box. When I saw <code>prepl</code> drop
in the Clojure 1.10 development cycle, I was very excited: built-in support for
future tooling, on top of the Socket REPL we&rsquo;ve had for a few releases!</p>

<p>I&rsquo;d previously used <a href="https://github.com/Unrepl/unravel">Unravel</a> to interact
with several of our processes at work that spawn a Socket REPL and found that a
very pleasant experience (side-loading <a href="https://github.com/Unrepl/unravel">Compliment</a>
to provide auto-completion while typing).</p>

<blockquote><p>Unravel is a simple command-line client for Clojure REPLs. It is based on the unrepl protocol, so instead of relying on nREPL, unravel communicates with your Clojure process through a Socket Server REPL.</p></blockquote>

<p>&ldquo;instead of relying on nREPL&rdquo; was music to my ears &ndash; I wanted editor integration
that worked this way!</p>

<p>A few days ago, in a side-thread in the <code>#off-topic</code> channel on the
<a href="https://clojurians.slack.com">Clojurians Slack</a> (<a href="http://clojurians.net/">sign up here</a>),
that had started with a question about <a href="https://cursive-ide.com/">Cursive</a> vs
Emacs/CIDER, Maurício Szabo mentioned &ldquo;a (very experimental) package for Atom
that &hellip; uses socket repl&rdquo;. I was intrigued. Could this be what I&rsquo;d been
looking for?</p>

<p>That package is <a href="https://atom.io/packages/chlorine">Chlorine for Atom</a>.
I installed it immediately (and disabled ProtoREPL) so I could take it for a
spin! It&rsquo;s written in ClojureScript. It only needs a Socket REPL. It uses
unrepl to &ldquo;upgrade&rdquo; the REPL as needed. It uses Compliment for auto-completion.
I could connect it directly to various running processes and I could start
REBL up from the command-line with a Socket REPL and connect to that as well.
<strong>This</strong> was exactly the workflow I&rsquo;d been looking for!</p>

<p>Maurício has been awesome to work with and over the last few days he&rsquo;s added
the first version of &ldquo;go to definition&rdquo; as well as merging pull requests from
me to add support for running tests in a namespace or an individual test. I
have pull requests in for adding &ldquo;load file&rdquo; (it already had evaluate selection,
so you could &ldquo;select all + evaluate selection&rdquo; but I was used to &ldquo;load file&rdquo;
from ProtoREPL), and &ldquo;show source&rdquo;.</p>

<p>I&rsquo;ve also <a href="https://github.com/seancorfield/atom-chlorine/commit/b5c4ec4fbe2572a97882e595f6280fec15592114">ported across my &ldquo;inspect&rdquo; functions</a> from ProtoREPL so my entire,
day-to-day workflow with ProtoREPL is now possible with Chlorine, REBL, <code>clj</code>, and
a couple of aliases &ndash; and I have an eminently hackable editor plugin, written
in ClojureScript with a slick auto-compile, auto-reload workflow (thank you
Maurício!).</p>

<p>I&rsquo;m still looking forward to tooling based on <code>prepl</code> so the client libraries
can be even simpler and smaller but, for now, I&rsquo;m a very happy developer and
I&rsquo;m very pleased to see how the Clojure community continues to innovate around
tooling (which, yes, has needed a lot of love over the years!).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL NULL, S/nilable, and Optionality]]></title>
    <link href="http://corfield.org/blog/2018/12/06/null-nilable-optionality/"/>
    <updated>2018-12-06T03:30:00-08:00</updated>
    <id>http://corfield.org/blog/2018/12/06/null-nilable-optionality</id>
    <content type="html"><![CDATA[<p>Rich Hickey gave a very thought-provoking talk at Clojure/conj 2018
called <a href="https://www.youtube.com/watch?v=YR5WdGrpoug&amp;list=PLZdCLR02grLpMkEBXT22FTaJYxB92i3V3&amp;index=2">Maybe Not</a>, where he mused
on optionality and how we represent the absence of a value.<!-- more --></p>

<p>His talk covered many things, including how <code>clojure.spec/keys</code> currently
complects both structure and optionality (and his thoughts on fixing that
in a future version of <code>clojure.spec</code>), but his mention of <code>s/nilable</code> was what
triggered an &ldquo;ah-ha!&rdquo; moment for me.</p>

<p>At <a href="https://worldsinglesnetworks.com">World Singles Networks</a>, we deal with a lot
of data in SQL (specifically in Percona&rsquo;s fork of MySQL) and, in SQL, you represent
the absence of a value with <code>NULL</code> in a column. Columns that represent optional
data must be declared as nullable and when you read data from them with
<a href="https://github.com/clojure/java.jdbc">clojure.java.jdbc</a> you get hash map
entries in the rows that have <code>nil</code> values. If you&rsquo;re using <code>clojure.spec</code> to
describe your tables, rows, and columns, then you are going to have lots of
<code>s/nilable</code> specs &ndash; and now your &ldquo;optionality&rdquo; has been reified into <code>nil</code>
values, cast in the stone of your specs&hellip; which is clearly not an ideal situation!</p>

<p>This made me realize that <code>java.jdbc</code> probably should just omit keys whose
values represent SQL <code>NULL</code>. They are, after all, <em>optional</em> values rather than
truly <em>nilable</em> values.</p>

<p>That would be a potentially breaking change in behavior for <code>java.jdbc</code> users.
Sure, in most cases, if you have a hash map representing a row in a database
table, you&rsquo;re not really going to care whether <code>(:col row)</code> gives you <code>nil</code>
because <code>:col</code> maps to <code>nil</code> or because <code>row</code> doesn&rsquo;t contain <code>:col</code>. There are
use cases where it matters: <code>contains?</code>, row/column specs, tabular printing.</p>

<p>Along with changing the behavior of <code>NULL</code> columns and
<a href="http://corfield.org/blog/2018/12/03/datafy-nav/">supporting <code>datafy</code> and <code>nav</code></a>,
I have a lot of other changes that I&rsquo;d like to apply to <code>java.jdbc</code>, such as
automatically qualifying column keys with the table from which they came,
improving overall performance (by no longer converting <code>ResultSet</code> objects to
sequences of hash maps), dramatically simplifying and streamlining the options
that are available (since many of them are very rarely used), and focusing on a
reducible-first API. All of which would be breaking changes.</p>

<p>I&rsquo;ve learned a lot &ndash; about Clojure, idioms, and databases &ndash; over the seven
years that I&rsquo;ve been maintaining <code>org.clojure/java.jdbc</code>, and it is time for a
new namespace or perhaps even a completely new project, that offers a better
way to deal with SQL databases from Clojure! I&rsquo;ll be writing a series of blog
posts about the differences I envisage between the current de facto standard
JDBC wrapper and where I&rsquo;d like to go with this, so that I can get community
feedback on what should stay, what should change, and what should go. Stay tuned!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure 1.10's Datafy and Nav]]></title>
    <link href="http://corfield.org/blog/2018/12/03/datafy-nav/"/>
    <updated>2018-12-03T09:20:00-08:00</updated>
    <id>http://corfield.org/blog/2018/12/03/datafy-nav</id>
    <content type="html"><![CDATA[<p>One of the more mysterious new features in Clojure 1.10 seems to be the pairing of <a href="https://github.com/clojure/clojure/blob/master/changes.md#26-datafy-and-nav"><code>datafy</code> and <code>nav</code></a> (and their underlying protocols, <code>Datafiable</code> and <code>Navigable</code>). Interest in these new functions has been piqued after Stuart Halloway showed off <a href="https://www.youtube.com/watch?v=c52QhiXsmyI&amp;list=PLZdCLR02grLpMkEBXT22FTaJYxB92i3V3&amp;index=3">REBL at Clojure/conj</a> (video). Stu presented this functionality as &ldquo;generalized laziness&rdquo;: <code>datafy</code> produces a &ldquo;data representation&rdquo; of things and <code>nav</code> lets you (lazily) navigate around that data.<!-- more --></p>

<p>The <a href="http://rebl.cognitect.com/">REBL</a> &ldquo;is a graphical, interactive tool for browsing Clojure data&rdquo;. And in Clojure we&rsquo;re used to the concept of &ldquo;it&rsquo;s just data&rdquo; so a graphical browser might sound useful but not exactly earthshaking. But REBL is just an example of what can be built with the new functionality in 1.10 and, indeed, Stu&rsquo;s claim of &ldquo;generalized laziness&rdquo; is well made but a little hard to grok until you actually build something with the new protocols and functions.</p>

<p>Since I&rsquo;ve done exactly that &ndash; with experimental support for <a href="https://github.com/clojure/java.jdbc/blob/master/src/main/clojure/clojure/java/jdbc/datafy.clj">lazy navigation of related records in <code>java.jdbc</code></a> &ndash; and spent some time on Slack today explaining how it all works, I figured it would be worth writing down in a more permanent place, as a blog post.</p>

<p>The <code>Datafiable</code> protocol (new in <code>clojure.core.protocols</code>) is defined for <code>nil</code> and <code>Object</code> to just return those values as-is, and then extended in <code>clojure.datafy</code> to cover:</p>

<ul>
<li><code>Throwable</code> &ndash; producing a simple hash map by calling <code>Throwable-&gt;map</code></li>
<li><code>clojure.lang.IRef</code> &ndash; producing a vector containing the dereferenced value, with the original metadata from the reference attached to that vector</li>
<li><code>clojure.lang.Namespace</code> &ndash; producing a hash map that is the data representation of the namespace (<code>:name</code>, <code>:publics</code>, <code>:imports</code>, and <code>:interns</code>) with the metadata of the namespace attached</li>
<li><code>java.lang.Class</code> &ndash; producing the <code>clojure.reflect/reflect</code> representation of the class, with an additional member <code>:name</code>, and the <code>:members</code> of the class grouped by name and sorted</li>
</ul>


<p>The <code>Navigable</code> protocol (new in <code>clojure.core.protocols</code>) is defined just for <code>Object</code> and, given some sort of object or collection, some sort of &ldquo;key&rdquo;, and a value, it will just return the value itself.</p>

<p>Based on that, it may not be clear how to implement the protocols or use the functions. The key thing that may not be obvious here is that <code>datafy</code> is intended to convert an arbitrary &ldquo;thing&rdquo; of any type into a pure Clojure data representation and, from that starting point, you can then use <code>nav</code> to &ldquo;navigate&rdquo; to a value derived from the original &ldquo;thing&rdquo;, which you would then process with <code>datafy</code> to get a pure Clojure data representation again. Those data representations may contain pieces that satisfy the <code>Navigable</code> protocol so that navigation (via <code>nav</code>) provides more than just a simple data-level lookup.</p>

<p>Using the <code>clojure.java.jdbc.datafy</code> code as an example, you would call <code>query</code> (from that new namespace) and get back a result set. That looks like a sequence of hash maps (rows) but adds metadata to the rows that provides an implementation of <code>Datafiable</code> (<a href="https://github.com/clojure/clojure/blob/master/changes.md#22-protocol-extension-by-metadata">protocol extension via metadata</a> is also new in Clojure 1.10). The row is the &ldquo;arbitrary thing&rdquo; that we are starting with. One or more of the columns in that row may be a foreign key into another table. When you turn the row into a pure Clojure data representation &ndash; by calling <code>datafy</code> on it &ndash; it still looks like a hash map but now it has metadata that provides an implementation of <code>Navigable</code>. That supports calling <code>(nav row column value)</code> and, if the column is considered to be a foreign key to another table, it will fetch the relevant row(s) from that table and return that as the next &ldquo;arbitrary thing&rdquo;, otherwise it will just return the column&rsquo;s value as passed in. The cycle of converting that to data (via <code>datafy</code>) and navigating through it (by navigating the Clojure data and then calling <code>nav</code> on that) can be continued indefinitely, until you bottom out to simple values.</p>

<p>You can sum this up as:</p>

<ul>
<li>Starting with a &ldquo;thing&rdquo;&hellip;</li>
<li>&hellip;you convert it to data (with <code>datafy</code>)&hellip;</li>
<li>&hellip;and walk it with simple Clojure data access&hellip;</li>
<li>&hellip;and, at each stage, you can navigate to the corresponding &ldquo;new thing&rdquo; by calling <code>nav</code>&hellip;</li>
<li>&hellip;which may return just that value or may do something more complex&hellip;</li>
<li>&hellip;and from that &ldquo;new thing&rdquo; you convert it to data (with <code>datafy</code>) and continue the process.</li>
</ul>


<p>Relating this back to REBL, it works by taking some arbitrary value produced in the REPL and converting it to data (via <code>datafy</code>) so that it can be displayed in the UI. With any part of that data highlighted you can &ldquo;drill down&rdquo;, at which point REBL calls <code>nav</code> to perform the (potentially lazy, complex) navigation and then converts that to data (via <code>datafy</code>) and displays that as the next &ldquo;level&rdquo; of data. Given an associative data representation, it does <code>(get coll k)</code> first to get <code>v</code>, and then it calls <code>(nav coll k v)</code> to allow the underlying navigation to return an updated value.</p>

<p>You go from &ldquo;thing&rdquo; to &ldquo;data representation&rdquo; of &ldquo;thing&rdquo; (via <code>datafy</code>), and then you can do the simple associative lookup <em>in the data representation, not the original thing</em>, and then you use <code>nav</code> to get back to the relevant equivalent part of the &ldquo;thing&rdquo;, and then you <code>datafy</code> that again to get pure data. For built-in Clojure data types that are already pure data, <code>datafy</code> does nothing and <code>nav</code> just returns the selected value. For hash maps, navigation is just simple key lookup. For vectors, navigation is also simple key (index) lookup. This new machinery only starts to shine in more complex situations.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Excited About Clojure/conj]]></title>
    <link href="http://corfield.org/blog/2018/10/25/clojure-conj/"/>
    <updated>2018-10-25T03:40:00-07:00</updated>
    <id>http://corfield.org/blog/2018/10/25/clojure-conj</id>
    <content type="html"><![CDATA[<p>It has been a crazy busy year, both at work and personally, and it&rsquo;s hard for me to believe my last blog post was in April!</p>

<p><a href="https://2018.clojure-conj.org/">Clojure/conj</a> is coming up fast and the schedule was posted today, which has made me even more excited about it. Here&rsquo;s a run down of the sessions I plan to attend &ndash; I&rsquo;ll write up my thoughts on everything shortly after the conference.</p>

<ul>
<li>Welcome Event &ndash; I&rsquo;m hoping my flight is on time and Lyft can get me there in time to chill and network with all the interesting Clojurians!</li>
<li>Stuart Halloway &ndash; In his recent <a href="https://www.youtube.com/watch?v=6ftW8UwwP_4">Apropos podcast</a>, he hinted that this talk would be about new tooling he has been using. Maybe prepl-related?</li>
<li>Christopher Small &ndash; Clojure on the cyberpunk frontier of democracy &ndash; This sounds fascinating.</li>
<li>Chris Johnson Bidler &ndash; Serverless-ish: Zero to App with Datomic Cloud and GraphQL.</li>
<li>Ghadi Shayban &ndash; Java Made (Somewhat) Simple &ndash; Although Ghadi told me this might be a beginner/intermediate-level talk, he&rsquo;s a great speaker and I look forward to hearing his insights about the platform.</li>
<li>Boris Kourtoukov &ndash; Machines that Judge Us.</li>
<li>Tiago Luchini &ndash; Declarative Domain Modeling for Datomic Ion/Cloud.</li>
<li>Lily Goh + Dom Kiva-Meyer &ndash; Robust APIs with clojure.spec &amp; GraphQL &ndash; I&rsquo;m a huge advocate of spec and we&rsquo;re also using GraphQL at work so this should be very applicable.</li>
<li>Rich Hickey &ndash; Maybe Not &ndash; Rich is always worth the price of entry!</li>
<li>Unsessions &ndash; Looking forward to seeing the schedule for these. Past years' unsessions have included some real diamonds!</li>
<li>David Chelimsky &ndash; AWS, meet Clojure.</li>
<li>Ben Kamphaus &ndash; AI Systems: Foundations for Artificial Minds or Aaron Cummings &ndash; Making Memories: Clojure For Hardware Engineers (And Others). I&rsquo;m undecided but leaning toward the AI talk.</li>
<li>Elena Machkasova &ndash; Babel: middleware for beginner-friendly error messages &ndash; Anything that helps with Clojure&rsquo;s error messages (much improved in Clojure 1.10!) is always worth learning about!</li>
<li>Wilker Lucio da Silva &ndash; Scaling Full-Stack Applications Over Hundreds of Microservices or Daniel Gregoire &ndash; Tables Considered Helpful. Undecided again but leaning toward the table talk.</li>
<li>Nikolas Göbel &ndash; Reactive Datalog for Datomic or Tyler Hobbs &ndash; Code goes in, Art comes out. Undecided but leaning toward the Datalog talk (because I&rsquo;m not hugely interested in art/computing).</li>
<li>Gary Fredericks &ndash; What Are All These Class Files Even About? And Other Stories &ndash; Having been repeatedly bitten by AOT, I&rsquo;m looking forward to this!</li>
<li>Tomomi Livingstone + Hans Livingstone &ndash; Party REPL — A multi-player REPL built for pair-programming &ndash; This looks very, very interesting!</li>
<li>Rebecca Parsons &ndash; Closing day two keynote.</li>
<li>(Party!)</li>
<li>Carin Meier &ndash; Can you GAN? &ndash; No idea about the topic but Carin is always an engaging speaker.</li>
<li>Dave Fetterman &ndash; Learning and Teaching Clojure on the job at Amperity &ndash; Because coming up to speed (and bringing others up to speed) is important.</li>
<li>Vikash Mansinghka &ndash; Probabilistic programming and meta-programming in Clojure &ndash; WAT?</li>
<li>Alex Engelberg and Derek Slager &ndash; Every Clojure Talk Ever &ndash; Cryptically enticing&hellip;</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[All the Paths]]></title>
    <link href="http://corfield.org/blog/2018/04/18/all-the-paths/"/>
    <updated>2018-04-18T03:40:00-07:00</updated>
    <id>http://corfield.org/blog/2018/04/18/all-the-paths</id>
    <content type="html"><![CDATA[<p>With the recent arrival of <a href="https://clojure.org/guides/deps_and_cli"><code>clj</code> and <code>tools.deps.alpha</code></a> as a &ldquo;standard&rdquo; lightweight way to run Clojure programs and the seed for tooling based on <code>deps.edn</code> dependency files, it&rsquo;s time to take a look at the terminology used across Clojure&rsquo;s various tools.<!-- more --></p>

<h2>Running Java/JVM Programs</h2>

<p>Before we dive into Clojure&rsquo;s tools, let&rsquo;s first consider the basics. When you run a compiled Java (or any JVM-based) program, you need two things: a classpath and a <code>main</code> function or, rather, a &ldquo;main class&rdquo;. Everything boils down to <code>java -cp ... MyClass</code> where the <code>...</code> is the &ldquo;classpath&rdquo;: a colon-delimited (or semicolon-delimited on Windows) list of directories or JAR files to search for <code>MyClass</code> and all the classes it needs. A quick look at the many introductory tutorials for Java online shows that the classpath is mostly just glossed over, despite being one of the most important (and, for beginnners, often one of the most perplexing) aspects of running programs on the JVM.</p>

<p>When you are creating deployable versions of programs, you typically use some sort of &ldquo;build&rdquo; tool to gather up all your (compiled) class files and JAR files (dependencies) and put them all together in a single &ldquo;uber&rdquo; JAR file, so that it can be run with just <code>java -jar MyApplication.jar</code>. This is shorthand for specifying <code>MyApplication.jar</code> as the entire classpath and assuming some &ldquo;magic&rdquo; inside the JAR file that specifies how to find the main class (via something called a &ldquo;manifest&rdquo;). The build tools know how to create the manifest (based on some information you provide) as well as managing the assembly of all the component pieces that will make up your complete application.</p>

<p>It&rsquo;s no wonder this can be a minefield for beginners!</p>

<h2>Leiningen</h2>

<p>In the very early days of Clojure, folks relied on the JVM ecosystem for build tools and dealt with all the sharp edges directly. Then along came <a href="https://leiningen.org/">Leiningen</a> with the goal of &ldquo;automating Clojure projects without setting your hair on fire&rdquo; by hiding all the sharp edges of Maven and <code>pom.xml</code> files and manifests and so on. It was so successful that it soon became the de facto standard in the Clojure world and most of the Clojure books out there can safely assume you have Leiningen installed. You can even just type <code>lein new app myapp</code> and you have a nicely structured skeleton of a Clojure project to get you up and running! Leiningen dispensed with all the XML and arcane invocations of the Java world and used a simple <code>project.clj</code> file to declare everything about your program. Your dependencies, your main namespace (class), various different ways of running your program (profiles), and all the tools you needed for development and testing (plugins).</p>

<p>The main aspect of Leiningen that is relevant to this blog post is the concept of &ldquo;paths&rdquo;. As noted above, as far as the JVM is concerned, there&rsquo;s really only the classpath: that&rsquo;s how you run your code. The various build tools need to know what else should be packaged up for deployment (e.g., configuration files, HTML/CSS/JS assets), as well as what you need to run tests or other development-related tasks that do not need to be in the deployment artifact.</p>

<p>Leiningen chose the following terminology for these various things:</p>

<ul>
<li><code>source-paths</code> &ndash; your Clojure code that should be part of every runtime, as well as being packaged up for deployment.</li>
<li><code>java-source-paths</code> &ndash; any Java code in your project that should be compiled, and whose <code>.class</code> files should be packaged up for deployment.</li>
<li><code>test-paths</code> &ndash; your Clojure code needed for development/testing of your application, which should <em>not</em> be part of the deployment artifact.</li>
<li><code>resource-paths</code> &ndash; your non-code files that should be made available at runtime (i.e., on the classpath), as well as being packaged up for deployment.</li>
<li><code>dependencies</code> &ndash; the list of project artifacts (and versions) that your program needs at runtime, and therefore should be packaged up for deployment &ndash; or at least declared in the deployment artifact as being needed for runtime.</li>
</ul>


<p>There&rsquo;s a subtlety here that Leiningen glosses over: there are really two types of files that are not code, that both need to be in the deployment artifact &ndash; those that need to be on the classpath during Leiningen&rsquo;s runtime (configuration files etc) and those that do not (HTML/CSS/JS etc). In Leiningen&rsquo;s world they are all &ldquo;resources&rdquo; and end up on the classpath anyway. This is a harmless convenience, but it&rsquo;s still an important distinction (note: once packaged up, everything in the JAR will be available on that program&rsquo;s runtime and, in general, during development/testing you will usually want your &ldquo;web root&rdquo; to be on your classpath, so that <code>io/resource</code> can find those files).</p>

<h2>Boot</h2>

<p><a href="http://boot-clj.com/">Boot</a> came along later in Clojure&rsquo;s evolution and approached build tools from a different direction. While most build tools (across most languages) are &ldquo;declarative&rdquo;, i.e., they have some sort of Domain-Specific Language (DSL) and a file that describes the various properties of your development/testing/packaging strategies, Boot decided to provide a library and a set of abstractions that would let you write pure Clojure to implement your needs. As Boot&rsquo;s website says &ldquo;It&rsquo;s not a build tool - it&rsquo;s build tooling.&rdquo;</p>

<p>I&rsquo;ve <a href="http://corfield.org/blog/categories/boot/">written about Boot</a> quite a bit since we made our decision at <a href="http://worldsinglesnetworks.com/">World Singles llc</a> to switch our stack from Leiningen to Boot, back in late 2015. Boot feels more like Clojure: it&rsquo;s composable and &ldquo;it&rsquo;s just code&rdquo;. Boot can do everything that Leiningen can do, and quite a bit more. And of course it chose its own terminology for the various JVM-related paths:</p>

<ul>
<li><code>resource-paths</code> &ndash; any files that need to both be on the classpath and packaged up for deployment.</li>
<li><code>source-paths</code> &ndash; any files that need to be on the classpath, but not part of the deployment artifact.</li>
<li><code>asset-paths</code> &ndash; any files that do not need to be on the classpath, but should be packaged up for deployment.</li>
<li><code>dependencies</code> &ndash; the list of project artifacts (and versions) that your program needs at runtime (etc).</li>
</ul>


<p>We see that Boot distinguishes between the two types of files that are not code, that both need to be in the deployment artifact, but blurs the lines between code and non-code files that need to be on the classpath. That means that when we move back and forth between Boot and Leiningen, we need to remember that they call certain core concepts by different names. Boot&rsquo;s <code>source-paths</code> are pretty much equivalent to Leiningen&rsquo;s <code>test-paths</code>. Boot&rsquo;s <code>asset-paths</code> are mapped into Leiningen&rsquo;s <code>resource-paths</code> (despite not needing to be on the classpath during the tool&rsquo;s runtime) and Leiningen&rsquo;s <code>source-paths</code> are mapped into Boot&rsquo;s <code>resource-paths</code> (despite being specifically <em>source</em> code). It definitely has potential to be confusing but it&rsquo;s born out of different approaches to how the fileset is managed across the lifecycle of both tools. In particular, Boot has a fileset abstraction that is key to how tasks are written and how various types of files are manipulated during Boot&rsquo;s execution &ndash; see <a href="https://github.com/boot-clj/boot/wiki/Boot-Environment">https://github.com/boot-clj/boot/wiki/Boot-Environment</a> for more detail about this.</p>

<h2>clj - Bringing It Back Home</h2>

<p>As Clojure 1.9 was being developed, it became important to be able to treat &ldquo;Clojure core&rdquo; as a single artifact, even tho' it consisted of &ldquo;core&rdquo; plus &ldquo;spec.alpha&rdquo; plus &ldquo;core.specs.alpha&rdquo;. Out of that came the <code>deps.edn</code> file for specifying dependencies, the <code>tools.deps.alpha</code> library for manipulating the <code>deps.edn</code> files and the dependencies they declare, and the <code>clj</code> and <code>clojure</code> command-line scripts that provide a standardized way to run Clojure programs based on dependencies specified in <code>deps.edn</code> files.</p>

<p>Just like the underlying Java (JVM) ecosystem, Clojure&rsquo;s new Command-Line Interface (CLI) is primarily about the classpath. It provides a mechanism to specify a set of paths and a set of dependencies, across (typically) three files (the &ldquo;install&rdquo; <code>deps.edn</code>, your &ldquo;home&rdquo; <code>deps.edn</code>, and your &ldquo;project&rdquo; <code>deps.edn</code>). It supports &ldquo;aliases&rdquo; for merging in alternative paths and dependencies. It also supports JVM options, and the options already available in <code>clojure.main</code>: initial and main options, to specify files to load, code to run, and a main namespace.</p>

<p>By getting back to basics, <code>clj</code> mirrors the underlying JVM ecosystem that really only cares about the classpath, constructed in appropriate ways for developing, testing, and running your program. It leaves decisions about packaging up to other tools, by design, and through the <code>tools.deps.alpha</code> library it offers a straightforward API for tool authors to build upon.</p>

<p>Late last year (November 2017), I started work on <a href="https://github.com/seancorfield/boot-tools-deps">boot-tools-deps</a> which was intended as a bridge to add Boot-based tooling on top of an existing <code>deps.edn</code> project. There is also <a href="https://github.com/RickMoynihan/lein-tools-deps">lein-tools-deps</a> which takes a slightly different approach but is intended to integrate <code>deps.edn</code> files into a Leiningen project.</p>

<p>We&rsquo;ve also seen the first two &ldquo;build tools&rdquo; based on <code>deps.edn</code> appear: <a href="https://github.com/seancorfield/depstar">depstar</a> and <a href="https://github.com/juxt/pack.alpha">juxt.pack</a> which, like the Boot and Leiningen tools above, take different approaches but are both intended to build (uber) JAR files from projects based on <code>deps.edn</code>.</p>

<p>This means that we need to look closely at the decisions each of these tools make about paths. The recommended approach with <code>clj</code> and <code>deps.edn</code> is to use aliases (liberally) to delineate the different classpaths (and JVM options and main options and so on) that all your various tasks require. The end result in each case is a specific classpath and options to run your code. For build tools, &ldquo;run your code&rdquo; means take the files on the classpath and package them up into a JAR file &ndash; so the entire file selection process is driven by aliases. This is rather different to the Leiningen and Boot build tools outlined above, since they provide explicit categories in which to declare files and folders for consideration in the classpath, non-classpath, packaging, and non-packaging categories.</p>

<p><code>lein-tools-deps</code> is intended primarily to replace your <code>:dependencies</code> vector by dependencies drawn from various <code>deps.edn</code> files. It doesn&rsquo;t (currently) worry about aliases, and it relies on the existing Leiningen infrastructure for all development/testing/packaging decisions. It&rsquo;s a nice, straightforward metaphor: <code>:mvn/version</code> dependencies in <code>deps.edn</code> are mapped into Leiningen&rsquo;s <code>:dependencies</code> and nothing else changes. The project maintainer, Rick Moynihan, intends to expand its functionality over time.</p>

<p>Both <code>juxt.pack</code> and <code>depstar</code> assume that you know what you&rsquo;re doing with aliases and they take whatever you&rsquo;ve decided is your classpath and they turn it into a JAR file. <code>depstar</code> takes the simpler approach, producing just a JAR file with no assumptions built-in &ndash; you need to tell it what main namespace to run and so on. <code>juxt.pack</code> is closer to a standard build tool and targets both AWS Lambda and traditional uber-JAR approaches.</p>

<p><code>boot-tools-deps</code> is intended to be a hybrid that envelops the underlying <code>deps.edn</code> and <code>tools.deps.alpha</code> machinery, exposing most of the same options, and then allows you to either run Boot tasks using the same, underlying classpath, or merge the <code>clj</code> environment back into the Boot environment to support different tooling. Specifically, it assumes that what comes out of <code>deps.edn</code> in the <code>:paths</code> key should be the <code>:resource-paths</code> &ndash; source and non-source, that is intended to be on the classpath and intended to be packaged for deployment. This includes <code>:git/url</code> and <code>:local/root</code> dependencies (since those are source code paths/folders). It also assumes that what comes out of <code>deps.edn</code> in the <code>:extra-paths</code> key should be the <code>:source-paths</code> &ndash; source code that is intended to be on the classpath but not packaged for deployment. While this is a fairly arbitrary interpretation of an artificial divide between entities on the classpath, I believe this is &ldquo;likely&rdquo; in the real world. In any case, this can be modified by Boot&rsquo;s <code>sift</code> task. Finally, it assumes that what comes out of <code>deps.edn</code> as a map of actual libraries and versions should be the <code>:dependencies</code> for Boot itself. This ought to be a straightforward assumption but it can cause problems if the dependencies use <code>:scope</code> extensively since that is not propagated by the Maven/Resolver library behind <code>tools.deps.alpha</code> and is of dubious value in the first place. In particular, transitive dependencies will not have the same scope as the parent that introduced them! Using aliases to assemble your dependencies is a much safer bet.</p>

<h2>Looking Forward</h2>

<p><code>clj</code> and <code>deps.edn</code> and <code>tools.deps.alpha</code> provide a core, standardized way of dealing with dependencies and various options that are required to run Clojure programs. Over time, this should become the standard baseline for &ldquo;installing&rdquo; and running Clojure code on Linux, Mac, and Windows. Both Leiningen and Boot have a strongly entrenched user base and both provide substantially enhanced behavior above and beyond <code>clj</code> and its components &ndash; that&rsquo;s by design. It is reasonable to assume that tooling based on <code>clj</code>, <code>deps.edn</code>, and <code>tools.deps.alpha</code> will become much more commonplace and there will come a day, possibly soon, where developers who pick up Clojure no longer need to consider installing Boot or Leiningen for their day-to-day work.</p>

<h2>p.s. Building New Projects</h2>

<p>Another common function that both Leiningen and Boot provide is to generate new projects based on a template. Check out <a href="https://github.com/seancorfield/clj-new">clj-new</a> for <code>clj</code>-based tooling that generates new <code>deps.edn</code>-based projects, as well as leveraging existing <code>lein-template</code> and <code>boot-template</code> projects.</p>

<h2>Credits</h2>

<p>Thank you to Alan Dipert, Alex Miller, Richiardi Andrea, and Rick Moynihan for reviewing a draft of this post and providing feedback and suggestions!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boot Localrepo?]]></title>
    <link href="http://corfield.org/blog/2017/11/17/boot-localrepo/"/>
    <updated>2017-11-17T04:50:00-08:00</updated>
    <id>http://corfield.org/blog/2017/11/17/boot-localrepo</id>
    <content type="html"><![CDATA[<p>Sometimes you just can&rsquo;t help having a &ldquo;random 3rd part JAR file&rdquo; in your project. The best practice is, of course, to upload it to your preferred Maven-compatible repository via whatever service or software you use for all your in-house shared artifacts. But sometimes you just want to play with that JAR file locally, or you haven&rsquo;t gotten around to running your own shared repository.</p>

<p>If you&rsquo;re using Leiningen, you&rsquo;ll probably reach for the excellent <a href="https://github.com/kumarshantanu/lein-localrepo"><code>lein-localrepo</code></a> which lets you &ldquo;install&rdquo; your random JAR file into your local Maven cache (in <code>~/.m2/repository</code>).</p>

<p>What do you do if you&rsquo;re using Boot instead?<!-- more --></p>

<p>Well, you <em>could</em> just keep <code>lein</code> installed and use it for this (with the <code>lein-localrepo</code> plugin dependency in your <code>~/.lein/profiles.clj</code>, for example):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>lein localrepo install foobar.jar foo/bar 1.0.1
</span></code></pre></td></tr></table></div></figure>


<p>Or you could run some command line Boot to make that happen:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>boot pom -p foo/bar -v 1.0.1 target <span class="se">\</span>
</span><span class='line'>    install -f foobar.jar -p target/META-INF/maven/foo/bar/pom.xml
</span><span class='line'><span class="c"># Don&#39;t forget to clean up!</span>
</span><span class='line'>rm -rf target
</span></code></pre></td></tr></table></div></figure>


<p>What the what? Yeah, that&rsquo;s really kind of ugly. Unfortunately, the <code>install</code> task seems to expect a physical <code>pom.xml</code> file when you specify a physical JAR file. That means we need to drop a <code>target</code> task into the pipeline into order for the generated <code>pom.xml</code> to be written to disk. It would be nice if it would look in the fileset first, because then at least this should work:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># This does NOT work!</span>
</span><span class='line'>boot pom -p foo/bar -v 1.0.1 install -f foobar.jar -p foo/bar
</span></code></pre></td></tr></table></div></figure>


<p>So what other options do we have with Boot?</p>

<p>Well, it turns out that you can run some Leiningen plugins directly from Boot, from the command line! Boot lets you specify dependencies on the command line, and it lets you &ldquo;call&rdquo; Clojure code from the command line too. Let&rsquo;s start a REPL with <code>lein-localrepo</code> as a dependency:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>boot -d leiningen -d lein-localrepo repl
</span></code></pre></td></tr></table></div></figure>


<p>We need Leiningen as well since plugins rely on it as a dependency. Now, in the REPL we can require the main namespace from the plugin, and get information about the entry point:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">boot.user=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">leiningen.localrepo</span> <span class="ss">:as</span> <span class="nv">lr</span><span class="p">])</span>
</span><span class='line'><span class="nv">nil</span>
</span><span class='line'><span class="nv">boot.user=&gt;</span> <span class="p">(</span><span class="nb">doc </span><span class="nv">lr/localrepo</span><span class="p">)</span>
</span><span class='line'><span class="nv">-------------------------</span>
</span><span class='line'><span class="nv">leiningen.localrepo/localrepo</span>
</span><span class='line'><span class="p">([</span><span class="nv">_</span><span class="p">]</span> <span class="p">[</span><span class="nv">_</span> <span class="nv">command</span> <span class="o">&amp;</span> <span class="nv">args</span><span class="p">])</span>
</span><span class='line'>  <span class="nv">Work</span> <span class="nv">with</span> <span class="nv">local</span> <span class="nv">Maven</span> <span class="nv">repository</span>
</span><span class='line'>
</span><span class='line'><span class="nv">Usage</span><span class="err">:</span> <span class="nv">lein</span> <span class="nv">localrepo</span> <span class="nv">&lt;command&gt;</span> <span class="p">(</span><span class="nf">commands</span> <span class="nv">are</span> <span class="nv">listed</span> <span class="nv">below</span><span class="p">)</span>
</span><span class='line'><span class="nv">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>For any given plugin, <code>lein-foo</code>, the entry point is <code>leiningen.foo/foo</code>. Note that it is called with an unused argument and then the actual command line arguments. So we can ask for help on the <code>install</code> command:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">boot.user=&gt;</span> <span class="p">(</span><span class="nf">lr/localrepo</span> <span class="nv">nil</span> <span class="s">&quot;help&quot;</span> <span class="s">&quot;install&quot;</span><span class="p">)</span>
</span><span class='line'><span class="nv">Install</span> <span class="nv">artifact</span> <span class="nv">to</span> <span class="nv">local</span> <span class="nv">repository</span>
</span><span class='line'>  <span class="nv">Arguments</span><span class="err">:</span>
</span><span class='line'>    <span class="p">[</span><span class="nv">options</span><span class="p">]</span> <span class="nv">&lt;filename&gt;</span> <span class="nv">&lt;artifact-id&gt;</span> <span class="nv">&lt;version&gt;</span>
</span><span class='line'>  <span class="nv">Options</span><span class="err">:</span>
</span><span class='line'><span class="nv">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>So we can call that function to perform the JAR install we want:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">boot.user=&gt;</span> <span class="p">(</span><span class="nf">lr/localrepo</span> <span class="nv">nil</span> <span class="s">&quot;install&quot;</span> <span class="s">&quot;foobar.jar&quot;</span> <span class="s">&quot;foo/bar&quot;</span> <span class="s">&quot;1.0.1&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Oh, that&rsquo;s a bit disappointing &ndash; we exited the REPL and got our command prompt back. I guess that calls <code>(System/exit)</code> which is a bit unfriendly (but, perhaps, not unexpected given the use case for this plugin). But we can verify that the JAR file was installed:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&gt; ls -R ~/.m2/repository/foo
</span><span class='line'>bar
</span><span class='line'>
</span><span class='line'>/Users/sean/.m2/repository/foo/bar:
</span><span class='line'>1.0.1             maven-metadata-local.xml
</span><span class='line'>
</span><span class='line'>/Users/sean/.m2/repository/foo/bar/1.0.1:
</span><span class='line'>_remote.repositories  bar-1.0.1.jar       bar-1.0.1.pom
</span></code></pre></td></tr></table></div></figure>


<p>Now, remember that I said you can &ldquo;call&rdquo; code from the command line with Boot? Since we know the code we need to execute (the <code>require</code> and the call to <code>lr/localrepo</code>), we&rsquo;ll just supply those as command line arguments to the <code>call</code> task:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>boot -d leiningen -d lein-localrepo <span class="se">\</span>
</span><span class='line'>  call -e <span class="s2">&quot;(require &#39;[leiningen.localrepo :as lr])&quot;</span> <span class="se">\</span>
</span><span class='line'>       -e <span class="s1">&#39;(lr/localrepo nil &quot;install&quot; &quot;foobar.jar&quot; &quot;foo/bar&quot; &quot;1.0.1&quot;)&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Voila!</p>

<p><em>Updated November 22nd, 2017: I published a boot-localrepo task!</em></p>

<p>And if you don&rsquo;t want to type all that, you can now do:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>boot -d seancorfield/boot-localrepo install-artifact -f foobar.jar -P foo/bar -v 1.0.1
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Release 0.7.0 of clojure.java.jdbc]]></title>
    <link href="http://corfield.org/blog/2017/07/17/clojure-java-jdbc-0-7-0/"/>
    <updated>2017-07-17T03:40:00-07:00</updated>
    <id>http://corfield.org/blog/2017/07/17/clojure-java-jdbc-0-7-0</id>
    <content type="html"><![CDATA[<p>The stable 0.7.0 release of <code>java.jdbc</code> &ndash; the <a href="https://github.com/clojure/java.jdbc">Clojure Contrib JDBC library</a> &ndash; has been baking for over a year, across of a trail of alpha and beta releases, and is now, finally, available!</p>

<p>While you <em>could</em> read the <a href="https://github.com/clojure/java.jdbc/blob/master/CHANGES.md"><code>java.jdbc</code> Change Log</a> to figure out what is new in this release, I thought it would be easier to consolidate all the changes into a blog post, with changes organized by category, and provide justification for the various changes.<!-- more --></p>

<p>I recently ran a <a href="https://www.surveymonkey.com/results/SM-CJY2YMHP/">survey about versions</a> of both Clojure and <code>java.jdbc</code> in use and had nearly 100 responses (thank you to everyone who completed the survey!). Only one respondent is still on Clojure 1.7.0, with about two thirds on 1.8.0, and a full third of respondents on a 1.9.0 alpha build. No one responded that they&rsquo;re on an earlier version of Clojure. That&rsquo;s great news for Clojure library maintainers, as it means we can take advantage of modern features in the language (such as transducers), and it also means that it is worthwhile to offer optional namespaces providing specs. <strong>Accordingly, <code>java.jdbc</code> now requires Clojure 1.7.0 or later.</strong></p>

<p>Also very encouraging was to see that almost a third of <code>java.jdbc</code> users are on alpha builds of what has become 0.7.0, with only a handful of users still on &ldquo;legacy&rdquo; versions (prior to 0.6.1).</p>

<p>Let&rsquo;s look at the major changes in 0.7.0, compared to 0.6.1!</p>

<h2>Reducible Queries</h2>

<p>Now that Clojure 1.7.0 is the minimum supported version, <code>java.jdbc</code> can offer query result collections that work with transducers. Two new functions &ndash; <code>reducible-query</code> and <code>reducible-result-set</code> &ndash; produce collections that implement <code>IReduce</code> and will perform resource management when <code>reduce</code>d. A reducible query will run the specified query only when the result is reduced &ndash; and it will run it each time it is reduced. A reducible result set can be constructed from any <code>ResultSet</code> object and will provide a one-off, managed forward read of the underlying data. Both of these support <code>reduced</code> results, which short-circuit the processing of the result set. They also support both the <code>init</code>-arity <code>reduce</code> and the no-<code>init</code>-arity <code>reduce</code>. Consult the docstring for <code>reduce</code> to see the full implications of this: the function passed into the no-<code>init</code>-arity <code>reduce</code> will be called with no arguments if the result set is empty!</p>

<p><code>reducible-query</code> works by invoking <code>db-query-with-resultset</code> only when it is <code>reduce</code>d, passing in a function that calls <code>reducible-result-set</code> and then <code>reduce</code>s the result. <code>reducible-result-set</code> works by computing metadata and key names only when it is <code>reduce</code>d, and then walking through the rows of the result, calling the supplied function (as specified by <code>reduce</code>), stopping if that function returns a <code>reduced?</code> value.</p>

<h2>Improved Database Vendor Support</h2>

<p>The <code>:dbtype</code> key in a <code>db-spec</code> is the preferred way to specify a database vendor, so you don&rsquo;t have to worry about &ldquo;subprotocols&rdquo; and &ldquo;subnames&rdquo; and so on. Just provide <code>:dbtype</code>, <code>:dbname</code>, <code>:host</code>, <code>:port</code>, <code>:user</code>, and <code>:password</code>, and <code>java.jdbc</code> should be able to connect you to most databases. The full list of supported <code>:dbtype</code> values is:</p>

<ul>
<li><code>derby</code> &ndash; Apache Derby</li>
<li><code>h2</code></li>
<li><code>hsql</code> or <code>hsqldb</code></li>
<li><code>jtds</code> or <code>jtds:sqlserver</code> &ndash; the jTDS JDBC driver for Microsoft SQL Server</li>
<li><code>mssql</code> &ndash; an alias for <code>sqlserver</code> below</li>
<li><code>mysql</code></li>
<li><code>oracle</code> or <code>oracle:thin</code>, <code>oracle:oci</code> &ndash; for the two main Oracle JDBC drivers (which use <code>@</code> in front of the <code>host</code> name, instead of <code>//</code>)</li>
<li><code>pgsql</code> &ndash; the Impossibl PostgresSQL JDBC driver</li>
<li><code>postgres</code> or <code>postgresl</code> &ndash; the standard PostgresSQL JDBC driver</li>
<li><code>redshift</code> &ndash; Amazon&rsquo;s Red Shift JDBC driver</li>
<li><code>sqlite</code></li>
<li><code>sqlserver</code> &ndash; Microsoft&rsquo;s default JDBC driver for SQL Server (they have finally released a version on Maven Central!)</li>
</ul>


<p>If your preferred database is not listed, head on over to <a href="https://dev.clojure.org/jira/browse/JDBC"><code>java.jdbc</code>s JIRA site</a> and create an enhancement issue, with details of the JDBC driver and I&rsquo;ll take a look! Note that you can can specify <code>:classname</code>, along with <code>:dbtype</code> if you want to override just the JDBC driver class name that <code>java.jdbc</code> would deduce from <code>:dbtype</code>.</p>

<h2>Option Handling</h2>

<p>An overall goal of 0.7.0 has been to make the API more consistent, especially in the way options are handled and passed around. The intention is that you can provide a hash map of options, as the last argument to any function, and <code>java.jdbc</code> will pass all of those options through the whole call chain, allowing you to control a lot more of the behavior of lower-level functions that are invoked by the higher-level functions. In addition, defaults for all options can be provided in your <code>db-spec</code>, and those will apply to all API functions. This is especially useful for specifying the <code>:entities</code> and <code>:identifiers</code> functions that control how SQL entity names and Clojure identifiers are constructed, everywhere in <code>java.jdbc</code>.</p>

<p>Here are all the new options available:</p>

<ul>
<li><code>:auto-commit?</code> &ndash; Can be passed into any API function that might cause a new database connection to be created. This allows you to turn auto-commit off for <em>new connections</em> in databases that use this setting to control whether a query can stream its results. The behavior is inherently vendor-specific, so you may need additional options to fully enable streaming results (setting <code>:fetch-size</code> to a non-zero value is common).</li>
<li><code>:conditional?</code> &ndash; For the two DDL-generating functions to add an existence check on the table to be created or dropped. May be a simple boolean value, a string (to be inserted between <code>DROP TABLE</code>/<code>CREATE TABLE</code> and the table name), or a function. In the latter case, the DDL string is generated as usual and then that function is called on it. This allows for databases that don&rsquo;t support <code>DROP TABLE IF EXISTS</code> / <code>CREATE TABLE IF NOT EXISTS</code> but instead require the <code>DROP</code> or <code>CREATE</code> statement to be wrapped in a specific existence checking query.</li>
<li><code>:explain?</code> and <code>:explain-fn</code> &ndash; So you can get the database to explain how it will run your query. Supported by <code>query</code>, <code>find-by-keys</code>, and <code>get-by-id</code>, these options will run the generated SQL with an &ldquo;explain&rdquo; option first, and then for real. <code>:explain?</code> can be <code>true</code> which simply prefixes the SQL with <code>"EXPLAIN "</code> or it can be a string if your database needs a different syntax (such as HSQLDB needing <code>"EXPLAIN PLAN FOR "</code>). The explanation output is processed by the <code>:explain-fn</code>, which defaults to <code>println</code>, but can be used to send explanations to a logging system etc.</li>
<li><code>:qualifier</code> &ndash; Lets you easily produce namespace-qualified column names from your queries.</li>
<li><code>:read-columns</code> &ndash; To specify how columns of data are read from a <code>ResultSet</code> object. The default behavior is to call <code>result-set-read-column</code> which implements the <code>IResultSetReadColumn</code> protocol. This allows finer-grained control when you are working with multiple databases in a single application.</li>
<li><code>:read-only?</code> &ndash; Like <code>:auto-commit?</code> this can be passed into any API function that might cause a new database connection to be created. This allows you to specify that <em>new connections</em> be treated as readonly, which may allow the database driver to perform optimizations on how the connection and its queries behave.</li>
</ul>


<h2>clojure.spec</h2>

<p><code>java.jdbc</code> provides an optional <code>clojure.java.jdbc.spec</code> namespace that is compatible with Clojure 1.9.0 Alpha 17 (it uses <code>clojure.spec.alpha</code>). This namespace provides <code>fdef</code> specs for all of the public functions in <code>clojure.java.jdbc</code> so you can <code>instrument</code> your code and get validation on all your interaction with <code>java.jdbc</code>. Note that you cannot do generative testing against <code>java.jdbc</code> because it uses a lot of Java types and a lot of side effects. <em>I have an experimental branch where I&rsquo;ve been investigating what generators would look like for <code>java.jdbc</code> but don&rsquo;t hold your breath for that becoming part of the <strong>master</strong> branch!</em></p>

<h2>New and Changed API Functions</h2>

<ul>
<li><code>as-sql-name</code> dropped its single arity (curried) version.</li>
<li><code>get-isolation-level</code> will return the current isolation level inside a transaction, if any.</li>
<li><code>quoted</code> dropped its 2-arity version, and now supports certain keywords for common entity-quoting strategies: <code>:ansi</code> (wraps entities in double quotes), <code>:mysql</code> (wraps entities in backticks), <code>:oracle</code> (wraps entities in double quotes), and <code>:sqlserver</code> (wraps entities in square brackets). These match the options in HoneySQL.</li>
<li><code>reducible-query</code> and <code>reducible-result-set</code> &ndash; see <strong>Reducible Queries</strong> above.</li>
</ul>


<h2>Documentation</h2>

<p>At present, the auto-generated API documentation (on <a href="https://clojure.github.io">https://clojure.github.io</a>) is stale due to some bugs in the toolchain used by the Clojure Build Server, so I recommend reading the <a href="http://clojure-doc.org/articles/ecosystem/java_jdbc/home.html">community-maintained <code>java.jdbc</code> documentation</a> on clojure-doc.org, in addition to using <code>clojure.repl/doc</code> to review the docstrings for API functions. That community-maintained documentation is currently going through a major overhaul to expand, clarify, and update the information presented &ndash; I encourage users of <code>java.jdbc</code> to get involved by submitting Pull Requests to help improve the documentation for everyone!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Seancorfield/boot-new Has Moved to Boot/new]]></title>
    <link href="http://corfield.org/blog/2017/01/19/boot-new-moved/"/>
    <updated>2017-01-19T12:40:00-08:00</updated>
    <id>http://corfield.org/blog/2017/01/19/boot-new-moved</id>
    <content type="html"><![CDATA[<p>I&rsquo;m pleased to announce that the &ldquo;Boot new&rdquo; task formerly known as <code>seancorfield/boot-new</code> has moved to the Boot organization, as <a href="https://github.com/boot-clj/boot-new"><code>boot-clj/boot-new</code></a> and that the group/artifact ID is now <code>boot/new</code>.</p>

<p>You can use this to easily create a new Boot-based project:</p>

<pre><code>boot -d boot/new new -t app -n my-new-boot-app
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure, New Relic, and Slow Application Startup]]></title>
    <link href="http://corfield.org/blog/2016/07/29/clojure-new-relic-slow-startup/"/>
    <updated>2016-07-29T13:20:00-07:00</updated>
    <id>http://corfield.org/blog/2016/07/29/clojure-new-relic-slow-startup</id>
    <content type="html"><![CDATA[<p>A couple of years ago, I blogged about <a href="http://corfield.org/blog/2013/05/01/instrumenting-clojure-for-new-relic-monitoring/">instrumenting Clojure for New Relic monitoring</a> and we&rsquo;ve generally been pretty happy with New Relic as a service overall. A while back, we had tried to update our New Relic Agent (used with our Tomcat-based web applications) from 3.21.0 to 3.25.0 and we ran into exceedingly long application start times, so we rolled back and continued on with 3.21.0. Recently, we decided to update the Agent to 3.30.1 to take advantage of advertised performance improvements and security enhancements. Once again we ran into exceedingly long application start times.</p>

<p>An application that took just over four minutes to start up fully with 3.21.0 was taking around forty minutes to start up with 3.30.1 &ndash; an order of magnitude slower!<!-- more --></p>

<p>Since we really wanted this update, we contacted New Relic Technical Support. Somewhat cryptically, they asked us to try version 3.24.1 &ndash; and that did not exhibit the slow startup &ndash; at which point they acknowledged that they&rsquo;d had reports that, with some applications, some customers had experienced slow startups since the 3.25.0 release. They asked us to set the logging level to &ldquo;finest&rdquo;, start the application up on a test machine, and then send them the log file. It was over 230MB(!) and full of Weave violations that the &ldquo;original bytecode&rdquo; could not be found. They very quickly traced this to how their instrumentation code tries to decide which classes to trace and which to ignore &ndash; and noted that Clojure creates a lot of <code>clojure.lang.DynamicClassLoader</code> instances (about 176,000 warnings in the log files originated from this class!) and, since the instrumentation never finds anything useful to instrument, loaded via those classloaders, they suggested that we tell the Agent to skip them.</p>

<p>As far as I can tell, this is not a documented configuration item (although there is a similar <code>classloader_excludes</code> list):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class_transformer:
</span><span class='line'>    classloader_blacklist: clojure.lang.DynamicClassLoader</span></code></pre></td></tr></table></div></figure>


<p>This stops the Agent from examining this classloader and/or the code loaded by it and it dramatically cut the application start times. After adding this to <code>newrelic.yml</code>, our applications started up slightly faster than they had with 3.21.0.</p>

<p>So, thank you to Jesse @ New Relic for the swift troubleshooting on this issue! I&rsquo;m posting this because I couldn&rsquo;t find a solution to the problem via Google &ndash; although I could find people complaining about the problem. Hopefully this will help others using New Relic with Clojure (or other languages that hit the same issue).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Start Your Engine]]></title>
    <link href="http://corfield.org/blog/2016/07/18/start-your-engine/"/>
    <updated>2016-07-18T04:00:00-07:00</updated>
    <id>http://corfield.org/blog/2016/07/18/start-your-engine</id>
    <content type="html"><![CDATA[<p>Today I&rsquo;m inspired by the <a href="http://us4.campaign-archive1.com/?u=a33b5228d1b5bf2e0c68a83f4&amp;id=56d35f53c5">latest issue of Eric Normand&rsquo;s Clojure Gazette</a> which talks about why his &ldquo;Joy of Programming&rdquo; comes from learning and exploration.</p>

<p>I got into programming as a child because I was curious about solving puzzles and problems: given the (relatively) limited vocabulary of a programming language and its input and output features, and some interesting problem that came to mind, can I solve it in a usable (and hopefully elegant) way?</p>

<p>Over the years, I&rsquo;ve written a <strong>lot</strong> of fun little programs to solve all sorts of interesting puzzles and problems that I&rsquo;ve either run across or invented just to amuse myself. I learn different programming languages to learn new vocabularies for solving problems, and new ways of looking at problems.</p>

<p>Some of those programs become libraries that I&rsquo;ve ended up using at work in one form or another, some become open source projects where I&rsquo;m pretty much the only user, a very small number become widely used projects.<!-- more --></p>

<p>Back in 2009, when my work was primarily CFML-based (and I wrote side projects in other languages for fun), I sketched out, figuratively on a <a href="http://framework-one.github.io/blog/2010/02/06/fw1-the-napkin-spec/">napkin, my ideas for a minimal MVC framework, based on conventions</a>. It was intended as an exercise to &ldquo;scratch an itch&rdquo;. It went on to become one of the most popular MVC frameworks in the CFML community (and I still maintain it to this day, even tho' my work is almost entirely Clojure now).</p>

<p>Again, as an exercise to &ldquo;scratch an itch&rdquo;, while I was still relatively new to Clojure, I decided to <a href="http://framework-one.github.io/blog/2011/11/07/fw1-comes-to-clojure/">port the core of that framework to Clojure</a>. It started as a bundle of <a href="https://github.com/ring-clojure/ring">Ring</a>, <a href="https://github.com/cgrand/enlive">Enlive</a>, and a convention-based routes-to-namespace-and-function mapping. Along the way, I replaced Enlive with <a href="https://github.com/yogthos/Selmer">Selmer</a>, and this &ldquo;fun little program&rdquo; now falls into the category of an open source project where I&rsquo;m pretty much the only user (we&rsquo;re starting to use it at work).</p>

<p>About a year ago, I had another puzzle in mind: could I create a usable library that allowed for a separation of queryable data sources, pure business logic, and committable changes (inserts, updates, and deletes). I created <a href="https://github.com/seancorfield/engine">Engine</a> purely to scratch that itch over a few days at the end of May 2015 and, apart from converting it to use Boot at the end of 2015, it&rsquo;s languished on GitHub ever since. Until a few weeks ago, when it looked like a solution to a problem at work.</p>

<p>We wanted a clearly delineated idiom where we could refactor our business logic out into pure functions, that depended on a set of queryable resources (some readonly JDBC and MongoDB data sources, a Component-based &ldquo;system&rdquo;, etc), and produce a set of changes that could be applied to a database or sent over a message queue to be processed or to update a search engine etc. We wanted something that &ldquo;forced&rdquo; this on our code (or at least &ldquo;strongly encouraged&rdquo; this separation of concerns).</p>

<p>Using Engine in the real world has caused it to grow and evolve to make it more fluent in production code (hence the flurry of changes and new releases over the last few weeks) but it&rsquo;s also allowed us to take a long, hard look at what shape our code needs to be, in order to support our legacy production platform, our new production platform, and our future production platform.</p>

<p>Although it would be nice to get extra eyes on both Engine and FW/1 for Clojure and, yes, additional users of both projects, I&rsquo;m posting this mostly as encouragement to &ldquo;scratch your itch&rdquo; and to write code as a way of learning, and exploring new ideas. It doesn&rsquo;t matter if that code is ultimately useful to anyone other than to you, as a medium for expressing your thoughts: write it down, play with it, use it to investigate a new concept or to rethink an existing one. Above all, <strong>enjoy</strong> programming!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More Boot]]></title>
    <link href="http://corfield.org/blog/2016/06/17/more-boot/"/>
    <updated>2016-06-17T13:00:00-07:00</updated>
    <id>http://corfield.org/blog/2016/06/17/more-boot</id>
    <content type="html"><![CDATA[<p>Back in February I talked about <a href="http://corfield.org/blog/2016/02/02/boot-new/">boot-new</a> and talked about a &ldquo;future 1.0.0 release&rdquo;. We&rsquo;re not there yet, but <a href="https://github.com/seancorfield/boot-new#boot-generators">generators</a> got added in release 0.4.0 and, in the four minor releases since, the focus has been on refactoring to match the core <a href="http://boot-clj.com/">Boot</a> task structure and improving compatibility with Leiningen templates. At World Singles, we&rsquo;ve continued to extend our usage of Boot until we have only a couple of Ant tasks left and we expect those to be within Boot&rsquo;s reach soon. In this post, I want to cover some of the things we&rsquo;ve been doing with Boot recently.<!-- more --></p>

<p>I feel I should start with an apology for the &ldquo;radio silence&rdquo; since February &ndash; it&rsquo;s a combination of work being extremely engaging (and busy!) and some aspects of my personal life going somewhat to hell in a handbasket&hellip; But things have improved lately (thankfully!) and I hope to be more regular in my blogging (I certainly have a decent queue of article ideas in my head!).</p>

<p>At work, we depend on a lot of libraries, both Java and Clojure, and we&rsquo;ve tended to be a bit cavalier about conflicts in transitive dependencies. Sure, we check that the desired version of any given library ends up being selected (via <code>boot ... show -p</code>) but we&rsquo;ve tended to only add <code>:exclusions</code> where absolutely necessary to avoid specific cases of the wrong version being selected. That had served us fairly well until we started to experiment with <a href="https://clojure.org/about/spec"><code>clojure.spec</code></a>, introduced in the Clojure 1.9.0 Alpha builds. Along with the new namespace, a number of new predicates have been introduced, in <code>clojure.core</code>, across several of those Alpha builds with names that are common enough that they conflict with user-defined predicates in a number of libraries. Normally, that wouldn&rsquo;t matter much: you&rsquo;d get:</p>

<pre><code>WARNING: ... already refers to: #'clojure.core/... in namespace: ..., being replaced by: #'...
</code></pre>

<p>and your program would continue to function normally. At some point, the library maintainer would add the new symbol to the <code>:exclude</code> list in their <code>:refer-clojure</code> clause, you&rsquo;d update, and life would be good.</p>

<p>Something strange was happening for us, however. Instead of the warnings, the user-defined function would just silently vanish and the program would fail trying to call an unbound <code>Var</code>. Weird. I found a workaround for one case (where a <code>defn</code> was inside a <code>do</code> in a <code>.cljx</code> file) but I couldn&rsquo;t reproduce the problem as a test case (and nor could Kevin Downey, who was skeptical enough of my line of reasoning to spend time trying to help me find the real reason &ndash; thank you sir!). I ran into a couple more similar bugs. It became clear Kevin was right (I feel like saying &ldquo;of course!&rdquo; here) and I needed to approach the problem differently. A few conversations happening around the same time &ndash; including one between Rich Hickey and Micha Niskin in the <a href="https://clojurians.slack.com/messages/boot/">#boot channel on Slack</a> &ndash; led me to focus on version conflicts in our transitive dependencies&hellip; Fortunately, Boot provides an easy way to detect if there are any conflicts (even if they resolve &ldquo;correctly&rdquo;) and Micha shared some code that I turned into the following Boot task:</p>

<pre><code>(deftask check-conflicts
  "Verify there are no dependency conflicts."
  []
  (with-pass-thru fs
    (require '[boot.pedantic :as pedant])
    (let [dep-conflicts (resolve 'pedant/dep-conflicts)]
      (if-let [conflicts (not-empty (dep-conflicts pod/env))]
        (throw (ex-info (str "Unresolved dependency conflicts. "
                             "Use :exclusions to resolve them!")
                        conflicts))
        (println "\nVerified there are no dependency conflicts.")))))
</code></pre>

<p>I added this to our build pipeline and <code>Unresolved dependency conflicts.</code> became a very familiar sight until I&rsquo;d added enough <code>:exclusions</code> to our dependencies to finally see <code>Verified there are no dependency conflicts.</code>. Was I glad to see <em>that</em> at the end of the day!</p>

<p>One of the things I noticed was the huge number of libraries that pull in some old version of Clojure itself as a transitive dependency, so I ended up adding a global exclusion to our <code>build.boot</code> file:</p>

<pre><code>(set-env! :exclusions ['org.clojure/clojure])
</code></pre>

<p>A few discussions ensued on Slack about whether projects should declare <code>org.clojure/clojure</code> as a <code>"provided"</code> dependency but there was no consensus, unfortunately. FWIW, I&rsquo;m in the <code>"provided"</code> camp.</p>

<p>The other big shift we&rsquo;ve made at work is to adopt <a href="https://github.com/stuartsierra/component">Stuart Sierra&rsquo;s Component</a>. This might seem like a no brainer for many people but most of our Clojure code operates inside a large non-Clojure web application and started life as a small set of libraries. Component is a great fit for &ldquo;whole program&rdquo; code but it was <a href="https://github.com/stuartsierra/component#disadvantages-of-the-component-model">hard see how to fit it into our model</a>, especially since (unfortunately) we&rsquo;d gradually sprouted quite a bit of global state (go on, boo all you like!). Having talked to a number of people who introduced Component into &ldquo;legacy&rdquo; Clojure applications, I began to suspect that as long as the <code>start</code> and <code>stop</code> lifecycle methods managed that global state, it wouldn&rsquo;t be too painful to introduce it piecemeal into our code base.</p>

<p>We still have global state (go on, boo again!) but we&rsquo;re slowly moving away from it now and we have some processes that have &ldquo;inverted&rdquo; and are now entirely managed by Component. One of the side effects of moving to Component is that you need to <code>start</code> your system after you fire up your REPL. It&rsquo;s great being able to <code>start</code> and <code>stop</code> your application inside the REPL (we&rsquo;re not quite at the Nirvana of refreshing all our namespaces due to that pesky global state, but we&rsquo;re on track). On the other hand, after years of just firing up a REPL and going to work, it takes some getting used to and seeing the message that our database connections have not been started became fairly familiar for the first few days. OK, weeks.</p>

<p>One of the nice things about Boot is that if you want functions available in the REPL, in your <code>boot.user</code> namespace, you simply define them in your <code>build.boot</code> file. This allows us to follow <a href="http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded">Stuart&rsquo;s &ldquo;Clojure Reloaded&rdquo; workflow</a> with minimal effort. Having the machinery in <code>build.boot</code> to work with Component also lends itself to using that lifecycle in your tasks. That&rsquo;s good hygiene and encourages you to think about packaging functionality into Components which fail into a natural <code>start</code> / <code>stop</code> rhythm around the Boot task pipeline architecture which also has a natural start (followed by other tasks in the pipeline) and then a natural stop. In some ways, Boot and Component are &ldquo;made for each other&rdquo;:</p>

<pre><code>(deftask my-component-task
  "A Component-based task."
  [...]
  (let [my-task (make-task-component ...)]
    (fn [next-handler]
      (fn [fileset]
        (let [app (component/start my-task)]
          ... ; work is done with app here
          (let [fileset' (... fileset)
                fileset' (commit! fileset')
                result   (next-handler fileset')]
            ... ; side effects are performed with app here
            (component/stop app)
            result)))))))
</code></pre>

<p>The final piece of Boot-ness I want to mention in this post is how we&rsquo;ve shifted some of our general shell commands from Ant to Boot. Here&rsquo;s an example of how we invoke Grunt from Boot &ndash; a similar pattern is followed for other shell commands:</p>

<pre><code>(defn ws-root []
  (System/getProperty "user.dir"))

(deftask grunt
  "Run Grunt (in www)."
  []
  (require '[clojure.java.shell :as sh])
  (let [sh (resolve 'sh/sh)]
    (with-pass-thru fs
      (let [{:keys [exit out err]} (sh "grunt" :dir (str (ws-root) "/www"))]
        (println out)
        (when-not (zero? exit)
          (println err)
          (throw (ex-info "Grunt failed." {:exit exit})))))))
</code></pre>

<p>I&rsquo;ll probably post about Boot again when we&rsquo;ve finally laid Ant to rest, and talk about any interesting things we run into during that last sprint.</p>
]]></content>
  </entry>
  
</feed>
