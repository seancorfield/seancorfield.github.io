<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[An Architect's View]]></title>
  <link href="http://corfield.org/atom.xml" rel="self"/>
  <link href="http://corfield.org/"/>
  <updated>2019-02-11T13:01:17-08:00</updated>
  <id>http://corfield.org/</id>
  <author>
    <name><![CDATA[Sean Corfield]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clojurians Slack Alternatives]]></title>
    <link href="http://corfield.org/blog/2019/02/11/clojurians-slack-alternatives/"/>
    <updated>2019-02-11T04:10:00-08:00</updated>
    <id>http://corfield.org/blog/2019/02/11/clojurians-slack-alternatives</id>
    <content type="html"><![CDATA[<p>Daniel Compton has continued his excellent trend of
<a href="https://danielcompton.net/2019/02/06/clojure-survey-2019">writing an analysis of the State of Clojure survey comments</a>
and one of the comments in his <strong>Community</strong> section stood out for me:</p>

<blockquote><p>&ldquo;I suggest moving off of slack to a more accessible chat system. Losing history is a bad thing. Check out discord or matrix or gitter or mattermark or any other number of tools made for this purpose.&rdquo;</p></blockquote>

<!-- more -->


<p>The <a href="https://clojurians.slack.com/">Clojurians Slack</a> <em>[sign up <a href="http://clojurians.net/">here</a>]</em>
started as a small experiment about four years ago and has been far more
successful than anyone could have imagined, with around 15K members signed up
and around 1,700 members considered &ldquo;active&rdquo; on a weekly basis (which means it
would cost almost $9K per month to run this as a paid service!).</p>

<p>A perennial complaint about Slack&rsquo;s free plan is that it limits the accessible
message history to just the most recent 10K messages. In a busy Slack like
Clojurians that limit is hit after three or four days, heavily limiting the
ability to refer back to conversations or to use the massive amount of
&ldquo;knowledge&rdquo; shared there for reference &ndash; exactly as noted in the comment above.</p>

<p>Why that comment inspired me to write this post is that most of the suggested
communities already exist, and have been around for quite some time. Two of
them are linked from the right hand column of the <a href="https://www.reddit.com/r/Clojure/">Clojure sub-Reddit</a>
but here&rsquo;s the list directly:</p>

<ul>
<li><a href="https://discordapp.com/invite/v9QMy9D">Discord</a></li>
<li><a href="https://gitter.im/clojure/general">Gitter</a> &ndash; there are several Clojure rooms on Gitter, most of them are linked to open source projects on GitHub</li>
<li><a href="https://riot.im/app/#/room/#clojure:matrix.org">Matrix/Riot</a></li>
<li>Mattermost &ndash; I&rsquo;m not sure if anyone has set up a Clojure community on Mattermost but several people have advocated for it</li>
</ul>


<p>The &ldquo;original&rdquo; online Clojure community still exists and is still active on IRC
(freenode), of course, and there&rsquo;s also <a href="https://braid.chat/">Braid</a> (written in
Clojure/ClojureScript!).</p>

<p>I was a bit surprised that the commenter did not mention <a href="https://clojurians.zulipchat.com/">Clojurians on Zulip</a>
because that community, started back in early November 2018, already has five hundred
members and seems, to me, like the most capable alternative to Slack. It&rsquo;s open
source, <a href="https://zulipchat.com/for/open-source/">hosted for free to open source communities</a>,
and &ldquo;has a significantly larger and more active development community than other
modern open source group chat solutions like Mattermost, Rocket.Chat, and matrix.org.&rdquo;
Read their <a href="https://zulipchat.com/why-zulip/">Why Zulip? page</a> for more
information about the service and how it compares (specifically to Slack).</p>

<p>One-way bridging between select Slack channels and Zulip streams has been in
place for a while and currently about fifty of the most popular channels on
Slack are available to read in Zulip streams, along with many other active
streams in Zulip. This means you can try Zulip without missing out on Slack
conversations &ndash; some people prefer Zulip&rsquo;s UI just for reading Slack messages!</p>

<p>Clojurians on Slack isn&rsquo;t going away &ndash; a lot of people love the UI and don&rsquo;t
consider the message history limit to be a big deal &ndash; and if you&rsquo;re already
using Slack for work, then it makes perfect sense to also use that for your
Clojure community fix (since you only need one chat client open). The Slack
community isn&rsquo;t &ldquo;official&rdquo; in any way, and you&rsquo;re all welcome to try other
chat clients, but if you feel strongly about open source and unlimited search
history, check out <a href="https://clojurians.zulipchat.com/">Clojurians on Zulip</a>
and if you like it, promote it and encourage other Clojurians to join you
there.</p>

<p>Me? I&rsquo;m one of the long-time admins/moderators of Clojurians on Slack, but I&rsquo;ve
also tried each and every one of the alternatives that various community members
have set up over the last four years. <a href="https://clojurians.zulipchat.com/">Clojurians on Zulip</a>
is the one I&rsquo;ve found myself most active in and the only alternative chat client
that I always have open at this point!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Atom, Chlorine, and Windows]]></title>
    <link href="http://corfield.org/blog/2019/01/22/atom-chlorine-windows/"/>
    <updated>2019-01-22T12:15:00-08:00</updated>
    <id>http://corfield.org/blog/2019/01/22/atom-chlorine-windows</id>
    <content type="html"><![CDATA[<p>About a month ago, I was <a href="http://corfield.org/blog/2018/12/19/atom-chlorine/">praising Chlorine, the new Clojure package for
Atom</a> and I&rsquo;ve been using
it, day-in, day-out, for all my Clojure development. On a Mac, that&rsquo;s
straightforward because I start a Socket REPL on the Mac and I run Atom on the
Mac so when I connect via Chlorine and issue the <code>Chlorine: Load File</code>
command (via <code>Ctrl-, f</code> in my keymap), it sends <code>(load-file "/path/to/file.clj")</code>
to the REPL, for the file being edited, and that is evaluated and loads the
source from disk and compiles it. On Windows&hellip;<!-- more --> Well, on Windows
there are a few obstacles to this workflow.</p>

<p>The first obstacle (for me) is that <code>clj</code> doesn&rsquo;t run on Windows and that&rsquo;s
what I use for everything Clojure on a Mac and on Linux now. There&rsquo;s a
PowerShell implementation in progress but Windows has always been a bit of a
second-class citizen so it&rsquo;s still a ways off. But Windows has WSL (Windows
Subsystem for Linux) so I can
and do run (user-mode) Ubuntu on my Windows laptop and I do all of my Clojure
work on that&hellip;</p>

<p>&hellip;but that brings the second obstacle: file paths on Windows look like
<code>C:\path\to\file.clj</code> and under WSL they look like <code>/mnt/c/path/to/file.clj</code>.
That means your editor on Windows and your REPL on Linux don&rsquo;t quite speak the
same language.</p>

<p>Fortunately, the latest release of Chlorine, 0.0.8, has a &ldquo;smart&rdquo; <code>Load File</code>
command that will work with both a Windows-based Socket REPL and a WSL-based
Socket REPL! It wraps the call to <code>load-file</code> in logic that looks at the
requested file path and also at the
<code>user.dir</code> JVM property and if the former starts with a drive identifier and <code>:</code>,
and the latter does not, it assumes the REPL is running on WSL on Windows and
maps the file path appropriately.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chlorine: Clojure Integration for Atom]]></title>
    <link href="http://corfield.org/blog/2018/12/19/atom-chlorine/"/>
    <updated>2018-12-19T22:45:00-08:00</updated>
    <id>http://corfield.org/blog/2018/12/19/atom-chlorine</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been using the <a href="https://atom.io">Atom</a> editor for about two years now.
I switched from Emacs after Clojure/conj 2016, having seen
<a href="https://youtu.be/buPPGxOnBnk">Jason Gilman&rsquo;s talk about ProtoREPL</a> [video].
It may sound like
heresy, but I&rsquo;d never been happy with Emacs<!-- more --> &ndash; not 17.x back when I first
started using it, not 18.x, not 19.x when I first stopped using it, nor 24.x onward
when I came back to it after learning Clojure a few decades later. I built
several configurations from scratch, I tried several &ldquo;curated&rdquo; configurations,
none of them felt like &ldquo;home&rdquo;. Emacs just leeched too much of my development
time for my tastes. I wanted a simple, modern text editor, that offered a wide
variety of &ldquo;plugins&rdquo; and supported all the languages I used, with a sane set of
defaults. Atom &ndash; with ProtoREPL &ndash; seemed to be exactly what I was looking for!</p>

<p>And for two years, it has been my day-to-day development environment.</p>

<p>But it has been frustrating that ProtoREPL hasn&rsquo;t been getting a huge amount of
love lately. Two releases immediately after that Conj, eleven in the first
half of 2017, and just three since then (in a year and a half).
With the advent of Clojure 1.10 and
<a href="https://github.com/cognitect-labs/REBL-distro">REBL</a>, I wanted to extend
ProtoREPL so I could integrate REBL into my workflow, so I forked it and
hacked in <code>inspect-block</code> and <code>inspect-top-block</code> functionality (see the
<a href="https://github.com/seancorfield/proto-repl/compare/4b13ebf9d0f1e228ab7800c4bc54fe071bacf29e...master">commit log</a>). But it&rsquo;s written in
CoffeeScript and that made me sad.</p>

<p>I&rsquo;ve also had a bit of a long-running love/hate relationship with
<a href="https://github.com/nrepl/nrepl">nREPL</a> over its lifetime. Something about the
wire protocol and overall architecture of it just bothered me and I longed for
tooling built on what Clojure provides out-of-the-box. When I saw <code>prepl</code> drop
in the Clojure 1.10 development cycle, I was very excited: built-in support for
future tooling, on top of the Socket REPL we&rsquo;ve had for a few releases!</p>

<p>I&rsquo;d previously used <a href="https://github.com/Unrepl/unravel">Unravel</a> to interact
with several of our processes at work that spawn a Socket REPL and found that a
very pleasant experience (side-loading <a href="https://github.com/Unrepl/unravel">Compliment</a>
to provide auto-completion while typing).</p>

<blockquote><p>Unravel is a simple command-line client for Clojure REPLs. It is based on the unrepl protocol, so instead of relying on nREPL, unravel communicates with your Clojure process through a Socket Server REPL.</p></blockquote>

<p>&ldquo;instead of relying on nREPL&rdquo; was music to my ears &ndash; I wanted editor integration
that worked this way!</p>

<p>A few days ago, in a side-thread in the <code>#off-topic</code> channel on the
<a href="https://clojurians.slack.com">Clojurians Slack</a> (<a href="http://clojurians.net/">sign up here</a>),
that had started with a question about <a href="https://cursive-ide.com/">Cursive</a> vs
Emacs/CIDER, Maurício Szabo mentioned &ldquo;a (very experimental) package for Atom
that &hellip; uses socket repl&rdquo;. I was intrigued. Could this be what I&rsquo;d been
looking for?</p>

<p>That package is <a href="https://atom.io/packages/chlorine">Chlorine for Atom</a>.
I installed it immediately (and disabled ProtoREPL) so I could take it for a
spin! It&rsquo;s written in ClojureScript. It only needs a Socket REPL. It uses
unrepl to &ldquo;upgrade&rdquo; the REPL as needed. It uses Compliment for auto-completion.
I could connect it directly to various running processes and I could start
REBL up from the command-line with a Socket REPL and connect to that as well.
<strong>This</strong> was exactly the workflow I&rsquo;d been looking for!</p>

<p>Maurício has been awesome to work with and over the last few days he&rsquo;s added
the first version of &ldquo;go to definition&rdquo; as well as merging pull requests from
me to add support for running tests in a namespace or an individual test. I
have pull requests in for adding &ldquo;load file&rdquo; (it already had evaluate selection,
so you could &ldquo;select all + evaluate selection&rdquo; but I was used to &ldquo;load file&rdquo;
from ProtoREPL), and &ldquo;show source&rdquo;.</p>

<p>I&rsquo;ve also <a href="https://github.com/seancorfield/atom-chlorine/commit/b5c4ec4fbe2572a97882e595f6280fec15592114">ported across my &ldquo;inspect&rdquo; functions</a> from ProtoREPL so my entire,
day-to-day workflow with ProtoREPL is now possible with Chlorine, REBL, <code>clj</code>, and
a couple of aliases &ndash; and I have an eminently hackable editor plugin, written
in ClojureScript with a slick auto-compile, auto-reload workflow (thank you
Maurício!).</p>

<p>I&rsquo;m still looking forward to tooling based on <code>prepl</code> so the client libraries
can be even simpler and smaller but, for now, I&rsquo;m a very happy developer and
I&rsquo;m very pleased to see how the Clojure community continues to innovate around
tooling (which, yes, has needed a lot of love over the years!).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL NULL, S/nilable, and Optionality]]></title>
    <link href="http://corfield.org/blog/2018/12/06/null-nilable-optionality/"/>
    <updated>2018-12-06T03:30:00-08:00</updated>
    <id>http://corfield.org/blog/2018/12/06/null-nilable-optionality</id>
    <content type="html"><![CDATA[<p>Rich Hickey gave a very thought-provoking talk at Clojure/conj 2018
called <a href="https://www.youtube.com/watch?v=YR5WdGrpoug&amp;list=PLZdCLR02grLpMkEBXT22FTaJYxB92i3V3&amp;index=2">Maybe Not</a>, where he mused
on optionality and how we represent the absence of a value.<!-- more --></p>

<p>His talk covered many things, including how <code>clojure.spec/keys</code> currently
complects both structure and optionality (and his thoughts on fixing that
in a future version of <code>clojure.spec</code>), but his mention of <code>s/nilable</code> was what
triggered an &ldquo;ah-ha!&rdquo; moment for me.</p>

<p>At <a href="https://worldsinglesnetworks.com">World Singles Networks</a>, we deal with a lot
of data in SQL (specifically in Percona&rsquo;s fork of MySQL) and, in SQL, you represent
the absence of a value with <code>NULL</code> in a column. Columns that represent optional
data must be declared as nullable and when you read data from them with
<a href="https://github.com/clojure/java.jdbc">clojure.java.jdbc</a> you get hash map
entries in the rows that have <code>nil</code> values. If you&rsquo;re using <code>clojure.spec</code> to
describe your tables, rows, and columns, then you are going to have lots of
<code>s/nilable</code> specs &ndash; and now your &ldquo;optionality&rdquo; has been reified into <code>nil</code>
values, cast in the stone of your specs&hellip; which is clearly not an ideal situation!</p>

<p>This made me realize that <code>java.jdbc</code> probably should just omit keys whose
values represent SQL <code>NULL</code>. They are, after all, <em>optional</em> values rather than
truly <em>nilable</em> values.</p>

<p>That would be a potentially breaking change in behavior for <code>java.jdbc</code> users.
Sure, in most cases, if you have a hash map representing a row in a database
table, you&rsquo;re not really going to care whether <code>(:col row)</code> gives you <code>nil</code>
because <code>:col</code> maps to <code>nil</code> or because <code>row</code> doesn&rsquo;t contain <code>:col</code>. There are
use cases where it matters: <code>contains?</code>, row/column specs, tabular printing.</p>

<p>Along with changing the behavior of <code>NULL</code> columns and
<a href="http://corfield.org/blog/2018/12/03/datafy-nav/">supporting <code>datafy</code> and <code>nav</code></a>,
I have a lot of other changes that I&rsquo;d like to apply to <code>java.jdbc</code>, such as
automatically qualifying column keys with the table from which they came,
improving overall performance (by no longer converting <code>ResultSet</code> objects to
sequences of hash maps), dramatically simplifying and streamlining the options
that are available (since many of them are very rarely used), and focusing on a
reducible-first API. All of which would be breaking changes.</p>

<p>I&rsquo;ve learned a lot &ndash; about Clojure, idioms, and databases &ndash; over the seven
years that I&rsquo;ve been maintaining <code>org.clojure/java.jdbc</code>, and it is time for a
new namespace or perhaps even a completely new project, that offers a better
way to deal with SQL databases from Clojure! I&rsquo;ll be writing a series of blog
posts about the differences I envisage between the current de facto standard
JDBC wrapper and where I&rsquo;d like to go with this, so that I can get community
feedback on what should stay, what should change, and what should go. Stay tuned!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure 1.10's Datafy and Nav]]></title>
    <link href="http://corfield.org/blog/2018/12/03/datafy-nav/"/>
    <updated>2018-12-03T09:20:00-08:00</updated>
    <id>http://corfield.org/blog/2018/12/03/datafy-nav</id>
    <content type="html"><![CDATA[<p>One of the more mysterious new features in Clojure 1.10 seems to be the pairing of <a href="https://github.com/clojure/clojure/blob/master/changes.md#26-datafy-and-nav"><code>datafy</code> and <code>nav</code></a> (and their underlying protocols, <code>Datafiable</code> and <code>Navigable</code>). Interest in these new functions has been piqued after Stuart Halloway showed off <a href="https://www.youtube.com/watch?v=c52QhiXsmyI&amp;list=PLZdCLR02grLpMkEBXT22FTaJYxB92i3V3&amp;index=3">REBL at Clojure/conj</a> (video). Stu presented this functionality as &ldquo;generalized laziness&rdquo;: <code>datafy</code> produces a &ldquo;data representation&rdquo; of things and <code>nav</code> lets you (lazily) navigate around that data.<!-- more --></p>

<p>The <a href="http://rebl.cognitect.com/">REBL</a> &ldquo;is a graphical, interactive tool for browsing Clojure data&rdquo;. And in Clojure we&rsquo;re used to the concept of &ldquo;it&rsquo;s just data&rdquo; so a graphical browser might sound useful but not exactly earthshaking. But REBL is just an example of what can be built with the new functionality in 1.10 and, indeed, Stu&rsquo;s claim of &ldquo;generalized laziness&rdquo; is well made but a little hard to grok until you actually build something with the new protocols and functions.</p>

<p>Since I&rsquo;ve done exactly that &ndash; with experimental support for <a href="https://github.com/clojure/java.jdbc/blob/master/src/main/clojure/clojure/java/jdbc/datafy.clj">lazy navigation of related records in <code>java.jdbc</code></a> &ndash; and spent some time on Slack today explaining how it all works, I figured it would be worth writing down in a more permanent place, as a blog post.</p>

<p>The <code>Datafiable</code> protocol (new in <code>clojure.core.protocols</code>) is defined for <code>nil</code> and <code>Object</code> to just return those values as-is, and then extended in <code>clojure.datafy</code> to cover:</p>

<ul>
<li><code>Throwable</code> &ndash; producing a simple hash map by calling <code>Throwable-&gt;map</code></li>
<li><code>clojure.lang.IRef</code> &ndash; producing a vector containing the dereferenced value, with the original metadata from the reference attached to that vector</li>
<li><code>clojure.lang.Namespace</code> &ndash; producing a hash map that is the data representation of the namespace (<code>:name</code>, <code>:publics</code>, <code>:imports</code>, and <code>:interns</code>) with the metadata of the namespace attached</li>
<li><code>java.lang.Class</code> &ndash; producing the <code>clojure.reflect/reflect</code> representation of the class, with an additional member <code>:name</code>, and the <code>:members</code> of the class grouped by name and sorted</li>
</ul>


<p>The <code>Navigable</code> protocol (new in <code>clojure.core.protocols</code>) is defined just for <code>Object</code> and, given some sort of object or collection, some sort of &ldquo;key&rdquo;, and a value, it will just return the value itself.</p>

<p>Based on that, it may not be clear how to implement the protocols or use the functions. The key thing that may not be obvious here is that <code>datafy</code> is intended to convert an arbitrary &ldquo;thing&rdquo; of any type into a pure Clojure data representation and, from that starting point, you can then use <code>nav</code> to &ldquo;navigate&rdquo; to a value derived from the original &ldquo;thing&rdquo;, which you would then process with <code>datafy</code> to get a pure Clojure data representation again. Those data representations may contain pieces that satisfy the <code>Navigable</code> protocol so that navigation (via <code>nav</code>) provides more than just a simple data-level lookup.</p>

<p>Using the <code>clojure.java.jdbc.datafy</code> code as an example, you would call <code>query</code> (from that new namespace) and get back a result set. That looks like a sequence of hash maps (rows) but adds metadata to the rows that provides an implementation of <code>Datafiable</code> (<a href="https://github.com/clojure/clojure/blob/master/changes.md#22-protocol-extension-by-metadata">protocol extension via metadata</a> is also new in Clojure 1.10). The row is the &ldquo;arbitrary thing&rdquo; that we are starting with. One or more of the columns in that row may be a foreign key into another table. When you turn the row into a pure Clojure data representation &ndash; by calling <code>datafy</code> on it &ndash; it still looks like a hash map but now it has metadata that provides an implementation of <code>Navigable</code>. That supports calling <code>(nav row column value)</code> and, if the column is considered to be a foreign key to another table, it will fetch the relevant row(s) from that table and return that as the next &ldquo;arbitrary thing&rdquo;, otherwise it will just return the column&rsquo;s value as passed in. The cycle of converting that to data (via <code>datafy</code>) and navigating through it (by navigating the Clojure data and then calling <code>nav</code> on that) can be continued indefinitely, until you bottom out to simple values.</p>

<p>You can sum this up as:</p>

<ul>
<li>Starting with a &ldquo;thing&rdquo;&hellip;</li>
<li>&hellip;you convert it to data (with <code>datafy</code>)&hellip;</li>
<li>&hellip;and walk it with simple Clojure data access&hellip;</li>
<li>&hellip;and, at each stage, you can navigate to the corresponding &ldquo;new thing&rdquo; by calling <code>nav</code>&hellip;</li>
<li>&hellip;which may return just that value or may do something more complex&hellip;</li>
<li>&hellip;and from that &ldquo;new thing&rdquo; you convert it to data (with <code>datafy</code>) and continue the process.</li>
</ul>


<p>Relating this back to REBL, it works by taking some arbitrary value produced in the REPL and converting it to data (via <code>datafy</code>) so that it can be displayed in the UI. With any part of that data highlighted you can &ldquo;drill down&rdquo;, at which point REBL calls <code>nav</code> to perform the (potentially lazy, complex) navigation and then converts that to data (via <code>datafy</code>) and displays that as the next &ldquo;level&rdquo; of data. Given an associative data representation, it does <code>(get coll k)</code> first to get <code>v</code>, and then it calls <code>(nav coll k v)</code> to allow the underlying navigation to return an updated value.</p>

<p>You go from &ldquo;thing&rdquo; to &ldquo;data representation&rdquo; of &ldquo;thing&rdquo; (via <code>datafy</code>), and then you can do the simple associative lookup <em>in the data representation, not the original thing</em>, and then you use <code>nav</code> to get back to the relevant equivalent part of the &ldquo;thing&rdquo;, and then you <code>datafy</code> that again to get pure data. For built-in Clojure data types that are already pure data, <code>datafy</code> does nothing and <code>nav</code> just returns the selected value. For hash maps, navigation is just simple key lookup. For vectors, navigation is also simple key (index) lookup. This new machinery only starts to shine in more complex situations.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Excited About Clojure/conj]]></title>
    <link href="http://corfield.org/blog/2018/10/25/clojure-conj/"/>
    <updated>2018-10-25T03:40:00-07:00</updated>
    <id>http://corfield.org/blog/2018/10/25/clojure-conj</id>
    <content type="html"><![CDATA[<p>It has been a crazy busy year, both at work and personally, and it&rsquo;s hard for me to believe my last blog post was in April!</p>

<p><a href="https://2018.clojure-conj.org/">Clojure/conj</a> is coming up fast and the schedule was posted today, which has made me even more excited about it. Here&rsquo;s a run down of the sessions I plan to attend &ndash; I&rsquo;ll write up my thoughts on everything shortly after the conference.</p>

<ul>
<li>Welcome Event &ndash; I&rsquo;m hoping my flight is on time and Lyft can get me there in time to chill and network with all the interesting Clojurians!</li>
<li>Stuart Halloway &ndash; In his recent <a href="https://www.youtube.com/watch?v=6ftW8UwwP_4">Apropos podcast</a>, he hinted that this talk would be about new tooling he has been using. Maybe prepl-related?</li>
<li>Christopher Small &ndash; Clojure on the cyberpunk frontier of democracy &ndash; This sounds fascinating.</li>
<li>Chris Johnson Bidler &ndash; Serverless-ish: Zero to App with Datomic Cloud and GraphQL.</li>
<li>Ghadi Shayban &ndash; Java Made (Somewhat) Simple &ndash; Although Ghadi told me this might be a beginner/intermediate-level talk, he&rsquo;s a great speaker and I look forward to hearing his insights about the platform.</li>
<li>Boris Kourtoukov &ndash; Machines that Judge Us.</li>
<li>Tiago Luchini &ndash; Declarative Domain Modeling for Datomic Ion/Cloud.</li>
<li>Lily Goh + Dom Kiva-Meyer &ndash; Robust APIs with clojure.spec &amp; GraphQL &ndash; I&rsquo;m a huge advocate of spec and we&rsquo;re also using GraphQL at work so this should be very applicable.</li>
<li>Rich Hickey &ndash; Maybe Not &ndash; Rich is always worth the price of entry!</li>
<li>Unsessions &ndash; Looking forward to seeing the schedule for these. Past years' unsessions have included some real diamonds!</li>
<li>David Chelimsky &ndash; AWS, meet Clojure.</li>
<li>Ben Kamphaus &ndash; AI Systems: Foundations for Artificial Minds or Aaron Cummings &ndash; Making Memories: Clojure For Hardware Engineers (And Others). I&rsquo;m undecided but leaning toward the AI talk.</li>
<li>Elena Machkasova &ndash; Babel: middleware for beginner-friendly error messages &ndash; Anything that helps with Clojure&rsquo;s error messages (much improved in Clojure 1.10!) is always worth learning about!</li>
<li>Wilker Lucio da Silva &ndash; Scaling Full-Stack Applications Over Hundreds of Microservices or Daniel Gregoire &ndash; Tables Considered Helpful. Undecided again but leaning toward the table talk.</li>
<li>Nikolas Göbel &ndash; Reactive Datalog for Datomic or Tyler Hobbs &ndash; Code goes in, Art comes out. Undecided but leaning toward the Datalog talk (because I&rsquo;m not hugely interested in art/computing).</li>
<li>Gary Fredericks &ndash; What Are All These Class Files Even About? And Other Stories &ndash; Having been repeatedly bitten by AOT, I&rsquo;m looking forward to this!</li>
<li>Tomomi Livingstone + Hans Livingstone &ndash; Party REPL — A multi-player REPL built for pair-programming &ndash; This looks very, very interesting!</li>
<li>Rebecca Parsons &ndash; Closing day two keynote.</li>
<li>(Party!)</li>
<li>Carin Meier &ndash; Can you GAN? &ndash; No idea about the topic but Carin is always an engaging speaker.</li>
<li>Dave Fetterman &ndash; Learning and Teaching Clojure on the job at Amperity &ndash; Because coming up to speed (and bringing others up to speed) is important.</li>
<li>Vikash Mansinghka &ndash; Probabilistic programming and meta-programming in Clojure &ndash; WAT?</li>
<li>Alex Engelberg and Derek Slager &ndash; Every Clojure Talk Ever &ndash; Cryptically enticing&hellip;</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[All the Paths]]></title>
    <link href="http://corfield.org/blog/2018/04/18/all-the-paths/"/>
    <updated>2018-04-18T03:40:00-07:00</updated>
    <id>http://corfield.org/blog/2018/04/18/all-the-paths</id>
    <content type="html"><![CDATA[<p>With the recent arrival of <a href="https://clojure.org/guides/deps_and_cli"><code>clj</code> and <code>tools.deps.alpha</code></a> as a &ldquo;standard&rdquo; lightweight way to run Clojure programs and the seed for tooling based on <code>deps.edn</code> dependency files, it&rsquo;s time to take a look at the terminology used across Clojure&rsquo;s various tools.<!-- more --></p>

<h2>Running Java/JVM Programs</h2>

<p>Before we dive into Clojure&rsquo;s tools, let&rsquo;s first consider the basics. When you run a compiled Java (or any JVM-based) program, you need two things: a classpath and a <code>main</code> function or, rather, a &ldquo;main class&rdquo;. Everything boils down to <code>java -cp ... MyClass</code> where the <code>...</code> is the &ldquo;classpath&rdquo;: a colon-delimited (or semicolon-delimited on Windows) list of directories or JAR files to search for <code>MyClass</code> and all the classes it needs. A quick look at the many introductory tutorials for Java online shows that the classpath is mostly just glossed over, despite being one of the most important (and, for beginnners, often one of the most perplexing) aspects of running programs on the JVM.</p>

<p>When you are creating deployable versions of programs, you typically use some sort of &ldquo;build&rdquo; tool to gather up all your (compiled) class files and JAR files (dependencies) and put them all together in a single &ldquo;uber&rdquo; JAR file, so that it can be run with just <code>java -jar MyApplication.jar</code>. This is shorthand for specifying <code>MyApplication.jar</code> as the entire classpath and assuming some &ldquo;magic&rdquo; inside the JAR file that specifies how to find the main class (via something called a &ldquo;manifest&rdquo;). The build tools know how to create the manifest (based on some information you provide) as well as managing the assembly of all the component pieces that will make up your complete application.</p>

<p>It&rsquo;s no wonder this can be a minefield for beginners!</p>

<h2>Leiningen</h2>

<p>In the very early days of Clojure, folks relied on the JVM ecosystem for build tools and dealt with all the sharp edges directly. Then along came <a href="https://leiningen.org/">Leiningen</a> with the goal of &ldquo;automating Clojure projects without setting your hair on fire&rdquo; by hiding all the sharp edges of Maven and <code>pom.xml</code> files and manifests and so on. It was so successful that it soon became the de facto standard in the Clojure world and most of the Clojure books out there can safely assume you have Leiningen installed. You can even just type <code>lein new app myapp</code> and you have a nicely structured skeleton of a Clojure project to get you up and running! Leiningen dispensed with all the XML and arcane invocations of the Java world and used a simple <code>project.clj</code> file to declare everything about your program. Your dependencies, your main namespace (class), various different ways of running your program (profiles), and all the tools you needed for development and testing (plugins).</p>

<p>The main aspect of Leiningen that is relevant to this blog post is the concept of &ldquo;paths&rdquo;. As noted above, as far as the JVM is concerned, there&rsquo;s really only the classpath: that&rsquo;s how you run your code. The various build tools need to know what else should be packaged up for deployment (e.g., configuration files, HTML/CSS/JS assets), as well as what you need to run tests or other development-related tasks that do not need to be in the deployment artifact.</p>

<p>Leiningen chose the following terminology for these various things:</p>

<ul>
<li><code>source-paths</code> &ndash; your Clojure code that should be part of every runtime, as well as being packaged up for deployment.</li>
<li><code>java-source-paths</code> &ndash; any Java code in your project that should be compiled, and whose <code>.class</code> files should be packaged up for deployment.</li>
<li><code>test-paths</code> &ndash; your Clojure code needed for development/testing of your application, which should <em>not</em> be part of the deployment artifact.</li>
<li><code>resource-paths</code> &ndash; your non-code files that should be made available at runtime (i.e., on the classpath), as well as being packaged up for deployment.</li>
<li><code>dependencies</code> &ndash; the list of project artifacts (and versions) that your program needs at runtime, and therefore should be packaged up for deployment &ndash; or at least declared in the deployment artifact as being needed for runtime.</li>
</ul>


<p>There&rsquo;s a subtlety here that Leiningen glosses over: there are really two types of files that are not code, that both need to be in the deployment artifact &ndash; those that need to be on the classpath during Leiningen&rsquo;s runtime (configuration files etc) and those that do not (HTML/CSS/JS etc). In Leiningen&rsquo;s world they are all &ldquo;resources&rdquo; and end up on the classpath anyway. This is a harmless convenience, but it&rsquo;s still an important distinction (note: once packaged up, everything in the JAR will be available on that program&rsquo;s runtime and, in general, during development/testing you will usually want your &ldquo;web root&rdquo; to be on your classpath, so that <code>io/resource</code> can find those files).</p>

<h2>Boot</h2>

<p><a href="http://boot-clj.com/">Boot</a> came along later in Clojure&rsquo;s evolution and approached build tools from a different direction. While most build tools (across most languages) are &ldquo;declarative&rdquo;, i.e., they have some sort of Domain-Specific Language (DSL) and a file that describes the various properties of your development/testing/packaging strategies, Boot decided to provide a library and a set of abstractions that would let you write pure Clojure to implement your needs. As Boot&rsquo;s website says &ldquo;It&rsquo;s not a build tool - it&rsquo;s build tooling.&rdquo;</p>

<p>I&rsquo;ve <a href="http://corfield.org/blog/categories/boot/">written about Boot</a> quite a bit since we made our decision at <a href="http://worldsinglesnetworks.com/">World Singles llc</a> to switch our stack from Leiningen to Boot, back in late 2015. Boot feels more like Clojure: it&rsquo;s composable and &ldquo;it&rsquo;s just code&rdquo;. Boot can do everything that Leiningen can do, and quite a bit more. And of course it chose its own terminology for the various JVM-related paths:</p>

<ul>
<li><code>resource-paths</code> &ndash; any files that need to both be on the classpath and packaged up for deployment.</li>
<li><code>source-paths</code> &ndash; any files that need to be on the classpath, but not part of the deployment artifact.</li>
<li><code>asset-paths</code> &ndash; any files that do not need to be on the classpath, but should be packaged up for deployment.</li>
<li><code>dependencies</code> &ndash; the list of project artifacts (and versions) that your program needs at runtime (etc).</li>
</ul>


<p>We see that Boot distinguishes between the two types of files that are not code, that both need to be in the deployment artifact, but blurs the lines between code and non-code files that need to be on the classpath. That means that when we move back and forth between Boot and Leiningen, we need to remember that they call certain core concepts by different names. Boot&rsquo;s <code>source-paths</code> are pretty much equivalent to Leiningen&rsquo;s <code>test-paths</code>. Boot&rsquo;s <code>asset-paths</code> are mapped into Leiningen&rsquo;s <code>resource-paths</code> (despite not needing to be on the classpath during the tool&rsquo;s runtime) and Leiningen&rsquo;s <code>source-paths</code> are mapped into Boot&rsquo;s <code>resource-paths</code> (despite being specifically <em>source</em> code). It definitely has potential to be confusing but it&rsquo;s born out of different approaches to how the fileset is managed across the lifecycle of both tools. In particular, Boot has a fileset abstraction that is key to how tasks are written and how various types of files are manipulated during Boot&rsquo;s execution &ndash; see <a href="https://github.com/boot-clj/boot/wiki/Boot-Environment">https://github.com/boot-clj/boot/wiki/Boot-Environment</a> for more detail about this.</p>

<h2>clj - Bringing It Back Home</h2>

<p>As Clojure 1.9 was being developed, it became important to be able to treat &ldquo;Clojure core&rdquo; as a single artifact, even tho' it consisted of &ldquo;core&rdquo; plus &ldquo;spec.alpha&rdquo; plus &ldquo;core.specs.alpha&rdquo;. Out of that came the <code>deps.edn</code> file for specifying dependencies, the <code>tools.deps.alpha</code> library for manipulating the <code>deps.edn</code> files and the dependencies they declare, and the <code>clj</code> and <code>clojure</code> command-line scripts that provide a standardized way to run Clojure programs based on dependencies specified in <code>deps.edn</code> files.</p>

<p>Just like the underlying Java (JVM) ecosystem, Clojure&rsquo;s new Command-Line Interface (CLI) is primarily about the classpath. It provides a mechanism to specify a set of paths and a set of dependencies, across (typically) three files (the &ldquo;install&rdquo; <code>deps.edn</code>, your &ldquo;home&rdquo; <code>deps.edn</code>, and your &ldquo;project&rdquo; <code>deps.edn</code>). It supports &ldquo;aliases&rdquo; for merging in alternative paths and dependencies. It also supports JVM options, and the options already available in <code>clojure.main</code>: initial and main options, to specify files to load, code to run, and a main namespace.</p>

<p>By getting back to basics, <code>clj</code> mirrors the underlying JVM ecosystem that really only cares about the classpath, constructed in appropriate ways for developing, testing, and running your program. It leaves decisions about packaging up to other tools, by design, and through the <code>tools.deps.alpha</code> library it offers a straightforward API for tool authors to build upon.</p>

<p>Late last year (November 2017), I started work on <a href="https://github.com/seancorfield/boot-tools-deps">boot-tools-deps</a> which was intended as a bridge to add Boot-based tooling on top of an existing <code>deps.edn</code> project. There is also <a href="https://github.com/RickMoynihan/lein-tools-deps">lein-tools-deps</a> which takes a slightly different approach but is intended to integrate <code>deps.edn</code> files into a Leiningen project.</p>

<p>We&rsquo;ve also seen the first two &ldquo;build tools&rdquo; based on <code>deps.edn</code> appear: <a href="https://github.com/healthfinch/depstar">depstar</a> and <a href="https://github.com/juxt/pack.alpha">juxt.pack</a> which, like the Boot and Leiningen tools above, take different approaches but are both intended to build (uber) JAR files from projects based on <code>deps.edn</code>.</p>

<p>This means that we need to look closely at the decisions each of these tools make about paths. The recommended approach with <code>clj</code> and <code>deps.edn</code> is to use aliases (liberally) to delineate the different classpaths (and JVM options and main options and so on) that all your various tasks require. The end result in each case is a specific classpath and options to run your code. For build tools, &ldquo;run your code&rdquo; means take the files on the classpath and package them up into a JAR file &ndash; so the entire file selection process is driven by aliases. This is rather different to the Leiningen and Boot build tools outlined above, since they provide explicit categories in which to declare files and folders for consideration in the classpath, non-classpath, packaging, and non-packaging categories.</p>

<p><code>lein-tools-deps</code> is intended primarily to replace your <code>:dependencies</code> vector by dependencies drawn from various <code>deps.edn</code> files. It doesn&rsquo;t (currently) worry about aliases, and it relies on the existing Leiningen infrastructure for all development/testing/packaging decisions. It&rsquo;s a nice, straightforward metaphor: <code>:mvn/version</code> dependencies in <code>deps.edn</code> are mapped into Leiningen&rsquo;s <code>:dependencies</code> and nothing else changes. The project maintainer, Rick Moynihan, intends to expand its functionality over time.</p>

<p>Both <code>juxt.pack</code> and <code>depstar</code> assume that you know what you&rsquo;re doing with aliases and they take whatever you&rsquo;ve decided is your classpath and they turn it into a JAR file. <code>depstar</code> takes the simpler approach, producing just a JAR file with no assumptions built-in &ndash; you need to tell it what main namespace to run and so on. <code>juxt.pack</code> is closer to a standard build tool and targets both AWS Lambda and traditional uber-JAR approaches.</p>

<p><code>boot-tools-deps</code> is intended to be a hybrid that envelops the underlying <code>deps.edn</code> and <code>tools.deps.alpha</code> machinery, exposing most of the same options, and then allows you to either run Boot tasks using the same, underlying classpath, or merge the <code>clj</code> environment back into the Boot environment to support different tooling. Specifically, it assumes that what comes out of <code>deps.edn</code> in the <code>:paths</code> key should be the <code>:resource-paths</code> &ndash; source and non-source, that is intended to be on the classpath and intended to be packaged for deployment. This includes <code>:git/url</code> and <code>:local/root</code> dependencies (since those are source code paths/folders). It also assumes that what comes out of <code>deps.edn</code> in the <code>:extra-paths</code> key should be the <code>:source-paths</code> &ndash; source code that is intended to be on the classpath but not packaged for deployment. While this is a fairly arbitrary interpretation of an artificial divide between entities on the classpath, I believe this is &ldquo;likely&rdquo; in the real world. In any case, this can be modified by Boot&rsquo;s <code>sift</code> task. Finally, it assumes that what comes out of <code>deps.edn</code> as a map of actual libraries and versions should be the <code>:dependencies</code> for Boot itself. This ought to be a straightforward assumption but it can cause problems if the dependencies use <code>:scope</code> extensively since that is not propagated by the Maven/Resolver library behind <code>tools.deps.alpha</code> and is of dubious value in the first place. In particular, transitive dependencies will not have the same scope as the parent that introduced them! Using aliases to assemble your dependencies is a much safer bet.</p>

<h2>Looking Forward</h2>

<p><code>clj</code> and <code>deps.edn</code> and <code>tools.deps.alpha</code> provide a core, standardized way of dealing with dependencies and various options that are required to run Clojure programs. Over time, this should become the standard baseline for &ldquo;installing&rdquo; and running Clojure code on Linux, Mac, and Windows. Both Leiningen and Boot have a strongly entrenched user base and both provide substantially enhanced behavior above and beyond <code>clj</code> and its components &ndash; that&rsquo;s by design. It is reasonable to assume that tooling based on <code>clj</code>, <code>deps.edn</code>, and <code>tools.deps.alpha</code> will become much more commonplace and there will come a day, possibly soon, where developers who pick up Clojure no longer need to consider installing Boot or Leiningen for their day-to-day work.</p>

<h2>p.s. Building New Projects</h2>

<p>Another common function that both Leiningen and Boot provide is to generate new projects based on a template. Check out <a href="https://github.com/seancorfield/clj-new">clj-new</a> for <code>clj</code>-based tooling that generates new <code>deps.edn</code>-based projects, as well as leveraging existing <code>lein-template</code> and <code>boot-template</code> projects.</p>

<h2>Credits</h2>

<p>Thank you to Alan Dipert, Alex Miller, Richiardi Andrea, and Rick Moynihan for reviewing a draft of this post and providing feedback and suggestions!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boot Localrepo?]]></title>
    <link href="http://corfield.org/blog/2017/11/17/boot-localrepo/"/>
    <updated>2017-11-17T04:50:00-08:00</updated>
    <id>http://corfield.org/blog/2017/11/17/boot-localrepo</id>
    <content type="html"><![CDATA[<p>Sometimes you just can&rsquo;t help having a &ldquo;random 3rd part JAR file&rdquo; in your project. The best practice is, of course, to upload it to your preferred Maven-compatible repository via whatever service or software you use for all your in-house shared artifacts. But sometimes you just want to play with that JAR file locally, or you haven&rsquo;t gotten around to running your own shared repository.</p>

<p>If you&rsquo;re using Leiningen, you&rsquo;ll probably reach for the excellent <a href="https://github.com/kumarshantanu/lein-localrepo"><code>lein-localrepo</code></a> which lets you &ldquo;install&rdquo; your random JAR file into your local Maven cache (in <code>~/.m2/repository</code>).</p>

<p>What do you do if you&rsquo;re using Boot instead?<!-- more --></p>

<p>Well, you <em>could</em> just keep <code>lein</code> installed and use it for this (with the <code>lein-localrepo</code> plugin dependency in your <code>~/.lein/profiles.clj</code>, for example):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>lein localrepo install foobar.jar foo/bar 1.0.1
</span></code></pre></td></tr></table></div></figure>


<p>Or you could run some command line Boot to make that happen:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>boot pom -p foo/bar -v 1.0.1 target <span class="se">\</span>
</span><span class='line'>    install -f foobar.jar -p target/META-INF/maven/foo/bar/pom.xml
</span><span class='line'><span class="c"># Don&#39;t forget to clean up!</span>
</span><span class='line'>rm -rf target
</span></code></pre></td></tr></table></div></figure>


<p>What the what? Yeah, that&rsquo;s really kind of ugly. Unfortunately, the <code>install</code> task seems to expect a physical <code>pom.xml</code> file when you specify a physical JAR file. That means we need to drop a <code>target</code> task into the pipeline into order for the generated <code>pom.xml</code> to be written to disk. It would be nice if it would look in the fileset first, because then at least this should work:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># This does NOT work!</span>
</span><span class='line'>boot pom -p foo/bar -v 1.0.1 install -f foobar.jar -p foo/bar
</span></code></pre></td></tr></table></div></figure>


<p>So what other options do we have with Boot?</p>

<p>Well, it turns out that you can run some Leiningen plugins directly from Boot, from the command line! Boot lets you specify dependencies on the command line, and it lets you &ldquo;call&rdquo; Clojure code from the command line too. Let&rsquo;s start a REPL with <code>lein-localrepo</code> as a dependency:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>boot -d leiningen -d lein-localrepo repl
</span></code></pre></td></tr></table></div></figure>


<p>We need Leiningen as well since plugins rely on it as a dependency. Now, in the REPL we can require the main namespace from the plugin, and get information about the entry point:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">boot.user=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">leiningen.localrepo</span> <span class="ss">:as</span> <span class="nv">lr</span><span class="p">])</span>
</span><span class='line'><span class="nv">nil</span>
</span><span class='line'><span class="nv">boot.user=&gt;</span> <span class="p">(</span><span class="nb">doc </span><span class="nv">lr/localrepo</span><span class="p">)</span>
</span><span class='line'><span class="nv">-------------------------</span>
</span><span class='line'><span class="nv">leiningen.localrepo/localrepo</span>
</span><span class='line'><span class="p">([</span><span class="nv">_</span><span class="p">]</span> <span class="p">[</span><span class="nv">_</span> <span class="nv">command</span> <span class="o">&amp;</span> <span class="nv">args</span><span class="p">])</span>
</span><span class='line'>  <span class="nv">Work</span> <span class="nv">with</span> <span class="nv">local</span> <span class="nv">Maven</span> <span class="nv">repository</span>
</span><span class='line'>
</span><span class='line'><span class="nv">Usage</span><span class="err">:</span> <span class="nv">lein</span> <span class="nv">localrepo</span> <span class="nv">&lt;command&gt;</span> <span class="p">(</span><span class="nf">commands</span> <span class="nv">are</span> <span class="nv">listed</span> <span class="nv">below</span><span class="p">)</span>
</span><span class='line'><span class="nv">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>For any given plugin, <code>lein-foo</code>, the entry point is <code>leiningen.foo/foo</code>. Note that it is called with an unused argument and then the actual command line arguments. So we can ask for help on the <code>install</code> command:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">boot.user=&gt;</span> <span class="p">(</span><span class="nf">lr/localrepo</span> <span class="nv">nil</span> <span class="s">&quot;help&quot;</span> <span class="s">&quot;install&quot;</span><span class="p">)</span>
</span><span class='line'><span class="nv">Install</span> <span class="nv">artifact</span> <span class="nv">to</span> <span class="nv">local</span> <span class="nv">repository</span>
</span><span class='line'>  <span class="nv">Arguments</span><span class="err">:</span>
</span><span class='line'>    <span class="p">[</span><span class="nv">options</span><span class="p">]</span> <span class="nv">&lt;filename&gt;</span> <span class="nv">&lt;artifact-id&gt;</span> <span class="nv">&lt;version&gt;</span>
</span><span class='line'>  <span class="nv">Options</span><span class="err">:</span>
</span><span class='line'><span class="nv">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>So we can call that function to perform the JAR install we want:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">boot.user=&gt;</span> <span class="p">(</span><span class="nf">lr/localrepo</span> <span class="nv">nil</span> <span class="s">&quot;install&quot;</span> <span class="s">&quot;foobar.jar&quot;</span> <span class="s">&quot;foo/bar&quot;</span> <span class="s">&quot;1.0.1&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Oh, that&rsquo;s a bit disappointing &ndash; we exited the REPL and got our command prompt back. I guess that calls <code>(System/exit)</code> which is a bit unfriendly (but, perhaps, not unexpected given the use case for this plugin). But we can verify that the JAR file was installed:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&gt; ls -R ~/.m2/repository/foo
</span><span class='line'>bar
</span><span class='line'>
</span><span class='line'>/Users/sean/.m2/repository/foo/bar:
</span><span class='line'>1.0.1             maven-metadata-local.xml
</span><span class='line'>
</span><span class='line'>/Users/sean/.m2/repository/foo/bar/1.0.1:
</span><span class='line'>_remote.repositories  bar-1.0.1.jar       bar-1.0.1.pom
</span></code></pre></td></tr></table></div></figure>


<p>Now, remember that I said you can &ldquo;call&rdquo; code from the command line with Boot? Since we know the code we need to execute (the <code>require</code> and the call to <code>lr/localrepo</code>), we&rsquo;ll just supply those as command line arguments to the <code>call</code> task:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>boot -d leiningen -d lein-localrepo <span class="se">\</span>
</span><span class='line'>  call -e <span class="s2">&quot;(require &#39;[leiningen.localrepo :as lr])&quot;</span> <span class="se">\</span>
</span><span class='line'>       -e <span class="s1">&#39;(lr/localrepo nil &quot;install&quot; &quot;foobar.jar&quot; &quot;foo/bar&quot; &quot;1.0.1&quot;)&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Voila!</p>

<p><em>Updated November 22nd, 2017: I published a boot-localrepo task!</em></p>

<p>And if you don&rsquo;t want to type all that, you can now do:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>boot -d seancorfield/boot-localrepo install-artifact -f foobar.jar -P foo/bar -v 1.0.1
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Release 0.7.0 of clojure.java.jdbc]]></title>
    <link href="http://corfield.org/blog/2017/07/17/clojure-java-jdbc-0-7-0/"/>
    <updated>2017-07-17T03:40:00-07:00</updated>
    <id>http://corfield.org/blog/2017/07/17/clojure-java-jdbc-0-7-0</id>
    <content type="html"><![CDATA[<p>The stable 0.7.0 release of <code>java.jdbc</code> &ndash; the <a href="https://github.com/clojure/java.jdbc">Clojure Contrib JDBC library</a> &ndash; has been baking for over a year, across of a trail of alpha and beta releases, and is now, finally, available!</p>

<p>While you <em>could</em> read the <a href="https://github.com/clojure/java.jdbc/blob/master/CHANGES.md"><code>java.jdbc</code> Change Log</a> to figure out what is new in this release, I thought it would be easier to consolidate all the changes into a blog post, with changes organized by category, and provide justification for the various changes.<!-- more --></p>

<p>I recently ran a <a href="https://www.surveymonkey.com/results/SM-CJY2YMHP/">survey about versions</a> of both Clojure and <code>java.jdbc</code> in use and had nearly 100 responses (thank you to everyone who completed the survey!). Only one respondent is still on Clojure 1.7.0, with about two thirds on 1.8.0, and a full third of respondents on a 1.9.0 alpha build. No one responded that they&rsquo;re on an earlier version of Clojure. That&rsquo;s great news for Clojure library maintainers, as it means we can take advantage of modern features in the language (such as transducers), and it also means that it is worthwhile to offer optional namespaces providing specs. <strong>Accordingly, <code>java.jdbc</code> now requires Clojure 1.7.0 or later.</strong></p>

<p>Also very encouraging was to see that almost a third of <code>java.jdbc</code> users are on alpha builds of what has become 0.7.0, with only a handful of users still on &ldquo;legacy&rdquo; versions (prior to 0.6.1).</p>

<p>Let&rsquo;s look at the major changes in 0.7.0, compared to 0.6.1!</p>

<h2>Reducible Queries</h2>

<p>Now that Clojure 1.7.0 is the minimum supported version, <code>java.jdbc</code> can offer query result collections that work with transducers. Two new functions &ndash; <code>reducible-query</code> and <code>reducible-result-set</code> &ndash; produce collections that implement <code>IReduce</code> and will perform resource management when <code>reduce</code>d. A reducible query will run the specified query only when the result is reduced &ndash; and it will run it each time it is reduced. A reducible result set can be constructed from any <code>ResultSet</code> object and will provide a one-off, managed forward read of the underlying data. Both of these support <code>reduced</code> results, which short-circuit the processing of the result set. They also support both the <code>init</code>-arity <code>reduce</code> and the no-<code>init</code>-arity <code>reduce</code>. Consult the docstring for <code>reduce</code> to see the full implications of this: the function passed into the no-<code>init</code>-arity <code>reduce</code> will be called with no arguments if the result set is empty!</p>

<p><code>reducible-query</code> works by invoking <code>db-query-with-resultset</code> only when it is <code>reduce</code>d, passing in a function that calls <code>reducible-result-set</code> and then <code>reduce</code>s the result. <code>reducible-result-set</code> works by computing metadata and key names only when it is <code>reduce</code>d, and then walking through the rows of the result, calling the supplied function (as specified by <code>reduce</code>), stopping if that function returns a <code>reduced?</code> value.</p>

<h2>Improved Database Vendor Support</h2>

<p>The <code>:dbtype</code> key in a <code>db-spec</code> is the preferred way to specify a database vendor, so you don&rsquo;t have to worry about &ldquo;subprotocols&rdquo; and &ldquo;subnames&rdquo; and so on. Just provide <code>:dbtype</code>, <code>:dbname</code>, <code>:host</code>, <code>:port</code>, <code>:user</code>, and <code>:password</code>, and <code>java.jdbc</code> should be able to connect you to most databases. The full list of supported <code>:dbtype</code> values is:</p>

<ul>
<li><code>derby</code> &ndash; Apache Derby</li>
<li><code>h2</code></li>
<li><code>hsql</code> or <code>hsqldb</code></li>
<li><code>jtds</code> or <code>jtds:sqlserver</code> &ndash; the jTDS JDBC driver for Microsoft SQL Server</li>
<li><code>mssql</code> &ndash; an alias for <code>sqlserver</code> below</li>
<li><code>mysql</code></li>
<li><code>oracle</code> or <code>oracle:thin</code>, <code>oracle:oci</code> &ndash; for the two main Oracle JDBC drivers (which use <code>@</code> in front of the <code>host</code> name, instead of <code>//</code>)</li>
<li><code>pgsql</code> &ndash; the Impossibl PostgresSQL JDBC driver</li>
<li><code>postgres</code> or <code>postgresl</code> &ndash; the standard PostgresSQL JDBC driver</li>
<li><code>redshift</code> &ndash; Amazon&rsquo;s Red Shift JDBC driver</li>
<li><code>sqlite</code></li>
<li><code>sqlserver</code> &ndash; Microsoft&rsquo;s default JDBC driver for SQL Server (they have finally released a version on Maven Central!)</li>
</ul>


<p>If your preferred database is not listed, head on over to <a href="https://dev.clojure.org/jira/browse/JDBC"><code>java.jdbc</code>s JIRA site</a> and create an enhancement issue, with details of the JDBC driver and I&rsquo;ll take a look! Note that you can can specify <code>:classname</code>, along with <code>:dbtype</code> if you want to override just the JDBC driver class name that <code>java.jdbc</code> would deduce from <code>:dbtype</code>.</p>

<h2>Option Handling</h2>

<p>An overall goal of 0.7.0 has been to make the API more consistent, especially in the way options are handled and passed around. The intention is that you can provide a hash map of options, as the last argument to any function, and <code>java.jdbc</code> will pass all of those options through the whole call chain, allowing you to control a lot more of the behavior of lower-level functions that are invoked by the higher-level functions. In addition, defaults for all options can be provided in your <code>db-spec</code>, and those will apply to all API functions. This is especially useful for specifying the <code>:entities</code> and <code>:identifiers</code> functions that control how SQL entity names and Clojure identifiers are constructed, everywhere in <code>java.jdbc</code>.</p>

<p>Here are all the new options available:</p>

<ul>
<li><code>:auto-commit?</code> &ndash; Can be passed into any API function that might cause a new database connection to be created. This allows you to turn auto-commit off for <em>new connections</em> in databases that use this setting to control whether a query can stream its results. The behavior is inherently vendor-specific, so you may need additional options to fully enable streaming results (setting <code>:fetch-size</code> to a non-zero value is common).</li>
<li><code>:conditional?</code> &ndash; For the two DDL-generating functions to add an existence check on the table to be created or dropped. May be a simple boolean value, a string (to be inserted between <code>DROP TABLE</code>/<code>CREATE TABLE</code> and the table name), or a function. In the latter case, the DDL string is generated as usual and then that function is called on it. This allows for databases that don&rsquo;t support <code>DROP TABLE IF EXISTS</code> / <code>CREATE TABLE IF NOT EXISTS</code> but instead require the <code>DROP</code> or <code>CREATE</code> statement to be wrapped in a specific existence checking query.</li>
<li><code>:explain?</code> and <code>:explain-fn</code> &ndash; So you can get the database to explain how it will run your query. Supported by <code>query</code>, <code>find-by-keys</code>, and <code>get-by-id</code>, these options will run the generated SQL with an &ldquo;explain&rdquo; option first, and then for real. <code>:explain?</code> can be <code>true</code> which simply prefixes the SQL with <code>"EXPLAIN "</code> or it can be a string if your database needs a different syntax (such as HSQLDB needing <code>"EXPLAIN PLAN FOR "</code>). The explanation output is processed by the <code>:explain-fn</code>, which defaults to <code>println</code>, but can be used to send explanations to a logging system etc.</li>
<li><code>:qualifier</code> &ndash; Lets you easily produce namespace-qualified column names from your queries.</li>
<li><code>:read-columns</code> &ndash; To specify how columns of data are read from a <code>ResultSet</code> object. The default behavior is to call <code>result-set-read-column</code> which implements the <code>IResultSetReadColumn</code> protocol. This allows finer-grained control when you are working with multiple databases in a single application.</li>
<li><code>:read-only?</code> &ndash; Like <code>:auto-commit?</code> this can be passed into any API function that might cause a new database connection to be created. This allows you to specify that <em>new connections</em> be treated as readonly, which may allow the database driver to perform optimizations on how the connection and its queries behave.</li>
</ul>


<h2>clojure.spec</h2>

<p><code>java.jdbc</code> provides an optional <code>clojure.java.jdbc.spec</code> namespace that is compatible with Clojure 1.9.0 Alpha 17 (it uses <code>clojure.spec.alpha</code>). This namespace provides <code>fdef</code> specs for all of the public functions in <code>clojure.java.jdbc</code> so you can <code>instrument</code> your code and get validation on all your interaction with <code>java.jdbc</code>. Note that you cannot do generative testing against <code>java.jdbc</code> because it uses a lot of Java types and a lot of side effects. <em>I have an experimental branch where I&rsquo;ve been investigating what generators would look like for <code>java.jdbc</code> but don&rsquo;t hold your breath for that becoming part of the <strong>master</strong> branch!</em></p>

<h2>New and Changed API Functions</h2>

<ul>
<li><code>as-sql-name</code> dropped its single arity (curried) version.</li>
<li><code>get-isolation-level</code> will return the current isolation level inside a transaction, if any.</li>
<li><code>quoted</code> dropped its 2-arity version, and now supports certain keywords for common entity-quoting strategies: <code>:ansi</code> (wraps entities in double quotes), <code>:mysql</code> (wraps entities in backticks), <code>:oracle</code> (wraps entities in double quotes), and <code>:sqlserver</code> (wraps entities in square brackets). These match the options in HoneySQL.</li>
<li><code>reducible-query</code> and <code>reducible-result-set</code> &ndash; see <strong>Reducible Queries</strong> above.</li>
</ul>


<h2>Documentation</h2>

<p>At present, the auto-generated API documentation (on <a href="https://clojure.github.io">https://clojure.github.io</a>) is stale due to some bugs in the toolchain used by the Clojure Build Server, so I recommend reading the <a href="http://clojure-doc.org/articles/ecosystem/java_jdbc/home.html">community-maintained <code>java.jdbc</code> documentation</a> on clojure-doc.org, in addition to using <code>clojure.repl/doc</code> to review the docstrings for API functions. That community-maintained documentation is currently going through a major overhaul to expand, clarify, and update the information presented &ndash; I encourage users of <code>java.jdbc</code> to get involved by submitting Pull Requests to help improve the documentation for everyone!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Seancorfield/boot-new Has Moved to Boot/new]]></title>
    <link href="http://corfield.org/blog/2017/01/19/boot-new-moved/"/>
    <updated>2017-01-19T12:40:00-08:00</updated>
    <id>http://corfield.org/blog/2017/01/19/boot-new-moved</id>
    <content type="html"><![CDATA[<p>I&rsquo;m pleased to announce that the &ldquo;Boot new&rdquo; task formerly known as <code>seancorfield/boot-new</code> has moved to the Boot organization, as <a href="https://github.com/boot-clj/boot-new"><code>boot-clj/boot-new</code></a> and that the group/artifact ID is now <code>boot/new</code>.</p>

<p>You can use this to easily create a new Boot-based project:</p>

<pre><code>boot -d boot/new new -t app -n my-new-boot-app
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure, New Relic, and Slow Application Startup]]></title>
    <link href="http://corfield.org/blog/2016/07/29/clojure-new-relic-slow-startup/"/>
    <updated>2016-07-29T13:20:00-07:00</updated>
    <id>http://corfield.org/blog/2016/07/29/clojure-new-relic-slow-startup</id>
    <content type="html"><![CDATA[<p>A couple of years ago, I blogged about <a href="http://corfield.org/blog/2013/05/01/instrumenting-clojure-for-new-relic-monitoring/">instrumenting Clojure for New Relic monitoring</a> and we&rsquo;ve generally been pretty happy with New Relic as a service overall. A while back, we had tried to update our New Relic Agent (used with our Tomcat-based web applications) from 3.21.0 to 3.25.0 and we ran into exceedingly long application start times, so we rolled back and continued on with 3.21.0. Recently, we decided to update the Agent to 3.30.1 to take advantage of advertised performance improvements and security enhancements. Once again we ran into exceedingly long application start times.</p>

<p>An application that took just over four minutes to start up fully with 3.21.0 was taking around forty minutes to start up with 3.30.1 &ndash; an order of magnitude slower!<!-- more --></p>

<p>Since we really wanted this update, we contacted New Relic Technical Support. Somewhat cryptically, they asked us to try version 3.24.1 &ndash; and that did not exhibit the slow startup &ndash; at which point they acknowledged that they&rsquo;d had reports that, with some applications, some customers had experienced slow startups since the 3.25.0 release. They asked us to set the logging level to &ldquo;finest&rdquo;, start the application up on a test machine, and then send them the log file. It was over 230MB(!) and full of Weave violations that the &ldquo;original bytecode&rdquo; could not be found. They very quickly traced this to how their instrumentation code tries to decide which classes to trace and which to ignore &ndash; and noted that Clojure creates a lot of <code>clojure.lang.DynamicClassLoader</code> instances (about 176,000 warnings in the log files originated from this class!) and, since the instrumentation never finds anything useful to instrument, loaded via those classloaders, they suggested that we tell the Agent to skip them.</p>

<p>As far as I can tell, this is not a documented configuration item (although there is a similar <code>classloader_excludes</code> list):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class_transformer:
</span><span class='line'>    classloader_blacklist: clojure.lang.DynamicClassLoader</span></code></pre></td></tr></table></div></figure>


<p>This stops the Agent from examining this classloader and/or the code loaded by it and it dramatically cut the application start times. After adding this to <code>newrelic.yml</code>, our applications started up slightly faster than they had with 3.21.0.</p>

<p>So, thank you to Jesse @ New Relic for the swift troubleshooting on this issue! I&rsquo;m posting this because I couldn&rsquo;t find a solution to the problem via Google &ndash; although I could find people complaining about the problem. Hopefully this will help others using New Relic with Clojure (or other languages that hit the same issue).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Start Your Engine]]></title>
    <link href="http://corfield.org/blog/2016/07/18/start-your-engine/"/>
    <updated>2016-07-18T04:00:00-07:00</updated>
    <id>http://corfield.org/blog/2016/07/18/start-your-engine</id>
    <content type="html"><![CDATA[<p>Today I&rsquo;m inspired by the <a href="http://us4.campaign-archive1.com/?u=a33b5228d1b5bf2e0c68a83f4&amp;id=56d35f53c5">latest issue of Eric Normand&rsquo;s Clojure Gazette</a> which talks about why his &ldquo;Joy of Programming&rdquo; comes from learning and exploration.</p>

<p>I got into programming as a child because I was curious about solving puzzles and problems: given the (relatively) limited vocabulary of a programming language and its input and output features, and some interesting problem that came to mind, can I solve it in a usable (and hopefully elegant) way?</p>

<p>Over the years, I&rsquo;ve written a <strong>lot</strong> of fun little programs to solve all sorts of interesting puzzles and problems that I&rsquo;ve either run across or invented just to amuse myself. I learn different programming languages to learn new vocabularies for solving problems, and new ways of looking at problems.</p>

<p>Some of those programs become libraries that I&rsquo;ve ended up using at work in one form or another, some become open source projects where I&rsquo;m pretty much the only user, a very small number become widely used projects.<!-- more --></p>

<p>Back in 2009, when my work was primarily CFML-based (and I wrote side projects in other languages for fun), I sketched out, figuratively on a <a href="http://framework-one.github.io/blog/2010/02/06/fw1-the-napkin-spec/">napkin, my ideas for a minimal MVC framework, based on conventions</a>. It was intended as an exercise to &ldquo;scratch an itch&rdquo;. It went on to become one of the most popular MVC frameworks in the CFML community (and I still maintain it to this day, even tho' my work is almost entirely Clojure now).</p>

<p>Again, as an exercise to &ldquo;scratch an itch&rdquo;, while I was still relatively new to Clojure, I decided to <a href="http://framework-one.github.io/blog/2011/11/07/fw1-comes-to-clojure/">port the core of that framework to Clojure</a>. It started as a bundle of <a href="https://github.com/ring-clojure/ring">Ring</a>, <a href="https://github.com/cgrand/enlive">Enlive</a>, and a convention-based routes-to-namespace-and-function mapping. Along the way, I replaced Enlive with <a href="https://github.com/yogthos/Selmer">Selmer</a>, and this &ldquo;fun little program&rdquo; now falls into the category of an open source project where I&rsquo;m pretty much the only user (we&rsquo;re starting to use it at work).</p>

<p>About a year ago, I had another puzzle in mind: could I create a usable library that allowed for a separation of queryable data sources, pure business logic, and committable changes (inserts, updates, and deletes). I created <a href="https://github.com/seancorfield/engine">Engine</a> purely to scratch that itch over a few days at the end of May 2015 and, apart from converting it to use Boot at the end of 2015, it&rsquo;s languished on GitHub ever since. Until a few weeks ago, when it looked like a solution to a problem at work.</p>

<p>We wanted a clearly delineated idiom where we could refactor our business logic out into pure functions, that depended on a set of queryable resources (some readonly JDBC and MongoDB data sources, a Component-based &ldquo;system&rdquo;, etc), and produce a set of changes that could be applied to a database or sent over a message queue to be processed or to update a search engine etc. We wanted something that &ldquo;forced&rdquo; this on our code (or at least &ldquo;strongly encouraged&rdquo; this separation of concerns).</p>

<p>Using Engine in the real world has caused it to grow and evolve to make it more fluent in production code (hence the flurry of changes and new releases over the last few weeks) but it&rsquo;s also allowed us to take a long, hard look at what shape our code needs to be, in order to support our legacy production platform, our new production platform, and our future production platform.</p>

<p>Although it would be nice to get extra eyes on both Engine and FW/1 for Clojure and, yes, additional users of both projects, I&rsquo;m posting this mostly as encouragement to &ldquo;scratch your itch&rdquo; and to write code as a way of learning, and exploring new ideas. It doesn&rsquo;t matter if that code is ultimately useful to anyone other than to you, as a medium for expressing your thoughts: write it down, play with it, use it to investigate a new concept or to rethink an existing one. Above all, <strong>enjoy</strong> programming!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More Boot]]></title>
    <link href="http://corfield.org/blog/2016/06/17/more-boot/"/>
    <updated>2016-06-17T13:00:00-07:00</updated>
    <id>http://corfield.org/blog/2016/06/17/more-boot</id>
    <content type="html"><![CDATA[<p>Back in February I talked about <a href="http://corfield.org/blog/2016/02/02/boot-new/">boot-new</a> and talked about a &ldquo;future 1.0.0 release&rdquo;. We&rsquo;re not there yet, but <a href="https://github.com/seancorfield/boot-new#boot-generators">generators</a> got added in release 0.4.0 and, in the four minor releases since, the focus has been on refactoring to match the core <a href="http://boot-clj.com/">Boot</a> task structure and improving compatibility with Leiningen templates. At World Singles, we&rsquo;ve continued to extend our usage of Boot until we have only a couple of Ant tasks left and we expect those to be within Boot&rsquo;s reach soon. In this post, I want to cover some of the things we&rsquo;ve been doing with Boot recently.<!-- more --></p>

<p>I feel I should start with an apology for the &ldquo;radio silence&rdquo; since February &ndash; it&rsquo;s a combination of work being extremely engaging (and busy!) and some aspects of my personal life going somewhat to hell in a handbasket&hellip; But things have improved lately (thankfully!) and I hope to be more regular in my blogging (I certainly have a decent queue of article ideas in my head!).</p>

<p>At work, we depend on a lot of libraries, both Java and Clojure, and we&rsquo;ve tended to be a bit cavalier about conflicts in transitive dependencies. Sure, we check that the desired version of any given library ends up being selected (via <code>boot ... show -p</code>) but we&rsquo;ve tended to only add <code>:exclusions</code> where absolutely necessary to avoid specific cases of the wrong version being selected. That had served us fairly well until we started to experiment with <a href="https://clojure.org/about/spec"><code>clojure.spec</code></a>, introduced in the Clojure 1.9.0 Alpha builds. Along with the new namespace, a number of new predicates have been introduced, in <code>clojure.core</code>, across several of those Alpha builds with names that are common enough that they conflict with user-defined predicates in a number of libraries. Normally, that wouldn&rsquo;t matter much: you&rsquo;d get:</p>

<pre><code>WARNING: ... already refers to: #'clojure.core/... in namespace: ..., being replaced by: #'...
</code></pre>

<p>and your program would continue to function normally. At some point, the library maintainer would add the new symbol to the <code>:exclude</code> list in their <code>:refer-clojure</code> clause, you&rsquo;d update, and life would be good.</p>

<p>Something strange was happening for us, however. Instead of the warnings, the user-defined function would just silently vanish and the program would fail trying to call an unbound <code>Var</code>. Weird. I found a workaround for one case (where a <code>defn</code> was inside a <code>do</code> in a <code>.cljx</code> file) but I couldn&rsquo;t reproduce the problem as a test case (and nor could Kevin Downey, who was skeptical enough of my line of reasoning to spend time trying to help me find the real reason &ndash; thank you sir!). I ran into a couple more similar bugs. It became clear Kevin was right (I feel like saying &ldquo;of course!&rdquo; here) and I needed to approach the problem differently. A few conversations happening around the same time &ndash; including one between Rich Hickey and Micha Niskin in the <a href="https://clojurians.slack.com/messages/boot/">#boot channel on Slack</a> &ndash; led me to focus on version conflicts in our transitive dependencies&hellip; Fortunately, Boot provides an easy way to detect if there are any conflicts (even if they resolve &ldquo;correctly&rdquo;) and Micha shared some code that I turned into the following Boot task:</p>

<pre><code>(deftask check-conflicts
  "Verify there are no dependency conflicts."
  []
  (with-pass-thru fs
    (require '[boot.pedantic :as pedant])
    (let [dep-conflicts (resolve 'pedant/dep-conflicts)]
      (if-let [conflicts (not-empty (dep-conflicts pod/env))]
        (throw (ex-info (str "Unresolved dependency conflicts. "
                             "Use :exclusions to resolve them!")
                        conflicts))
        (println "\nVerified there are no dependency conflicts.")))))
</code></pre>

<p>I added this to our build pipeline and <code>Unresolved dependency conflicts.</code> became a very familiar sight until I&rsquo;d added enough <code>:exclusions</code> to our dependencies to finally see <code>Verified there are no dependency conflicts.</code>. Was I glad to see <em>that</em> at the end of the day!</p>

<p>One of the things I noticed was the huge number of libraries that pull in some old version of Clojure itself as a transitive dependency, so I ended up adding a global exclusion to our <code>build.boot</code> file:</p>

<pre><code>(set-env! :exclusions ['org.clojure/clojure])
</code></pre>

<p>A few discussions ensued on Slack about whether projects should declare <code>org.clojure/clojure</code> as a <code>"provided"</code> dependency but there was no consensus, unfortunately. FWIW, I&rsquo;m in the <code>"provided"</code> camp.</p>

<p>The other big shift we&rsquo;ve made at work is to adopt <a href="https://github.com/stuartsierra/component">Stuart Sierra&rsquo;s Component</a>. This might seem like a no brainer for many people but most of our Clojure code operates inside a large non-Clojure web application and started life as a small set of libraries. Component is a great fit for &ldquo;whole program&rdquo; code but it was <a href="https://github.com/stuartsierra/component#disadvantages-of-the-component-model">hard see how to fit it into our model</a>, especially since (unfortunately) we&rsquo;d gradually sprouted quite a bit of global state (go on, boo all you like!). Having talked to a number of people who introduced Component into &ldquo;legacy&rdquo; Clojure applications, I began to suspect that as long as the <code>start</code> and <code>stop</code> lifecycle methods managed that global state, it wouldn&rsquo;t be too painful to introduce it piecemeal into our code base.</p>

<p>We still have global state (go on, boo again!) but we&rsquo;re slowly moving away from it now and we have some processes that have &ldquo;inverted&rdquo; and are now entirely managed by Component. One of the side effects of moving to Component is that you need to <code>start</code> your system after you fire up your REPL. It&rsquo;s great being able to <code>start</code> and <code>stop</code> your application inside the REPL (we&rsquo;re not quite at the Nirvana of refreshing all our namespaces due to that pesky global state, but we&rsquo;re on track). On the other hand, after years of just firing up a REPL and going to work, it takes some getting used to and seeing the message that our database connections have not been started became fairly familiar for the first few days. OK, weeks.</p>

<p>One of the nice things about Boot is that if you want functions available in the REPL, in your <code>boot.user</code> namespace, you simply define them in your <code>build.boot</code> file. This allows us to follow <a href="http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded">Stuart&rsquo;s &ldquo;Clojure Reloaded&rdquo; workflow</a> with minimal effort. Having the machinery in <code>build.boot</code> to work with Component also lends itself to using that lifecycle in your tasks. That&rsquo;s good hygiene and encourages you to think about packaging functionality into Components which fail into a natural <code>start</code> / <code>stop</code> rhythm around the Boot task pipeline architecture which also has a natural start (followed by other tasks in the pipeline) and then a natural stop. In some ways, Boot and Component are &ldquo;made for each other&rdquo;:</p>

<pre><code>(deftask my-component-task
  "A Component-based task."
  [...]
  (let [my-task (make-task-component ...)]
    (fn [next-handler]
      (fn [fileset]
        (let [app (component/start my-task)]
          ... ; work is done with app here
          (let [fileset' (... fileset)
                fileset' (commit! fileset')
                result   (next-handler fileset')]
            ... ; side effects are performed with app here
            (component/stop app)
            result)))))))
</code></pre>

<p>The final piece of Boot-ness I want to mention in this post is how we&rsquo;ve shifted some of our general shell commands from Ant to Boot. Here&rsquo;s an example of how we invoke Grunt from Boot &ndash; a similar pattern is followed for other shell commands:</p>

<pre><code>(defn ws-root []
  (System/getProperty "user.dir"))

(deftask grunt
  "Run Grunt (in www)."
  []
  (require '[clojure.java.shell :as sh])
  (let [sh (resolve 'sh/sh)]
    (with-pass-thru fs
      (let [{:keys [exit out err]} (sh "grunt" :dir (str (ws-root) "/www"))]
        (println out)
        (when-not (zero? exit)
          (println err)
          (throw (ex-info "Grunt failed." {:exit exit})))))))
</code></pre>

<p>I&rsquo;ll probably post about Boot again when we&rsquo;ve finally laid Ant to rest, and talk about any interesting things we run into during that last sprint.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boot-new]]></title>
    <link href="http://corfield.org/blog/2016/02/02/boot-new/"/>
    <updated>2016-02-02T09:00:00-08:00</updated>
    <id>http://corfield.org/blog/2016/02/02/boot-new</id>
    <content type="html"><![CDATA[<p>In my previous three blog posts about <a href="http://boot-clj.com/">Boot</a> &ndash; <a href="http://corfield.org/blog/2016/01/29/rebooting-clojure/">Rebooting Clojure</a>, <a href="http://corfield.org/blog/2016/01/30/building-on-boot/">Building On Boot</a>, and <a href="http://corfield.org/blog/2016/01/31/testing-with-boot/">Testing With Boot</a> &ndash; I looked at why World Singles decided to switch from Leiningen to Boot, as well discussing one of the missing pieces for us (testing). Once I had <a href="https://github.com/seancorfield/boot-expectations">boot-expectations</a> written, I was casting around for other missing pieces in the ecosystem and one glaring one was the lack of something to generate new projects from templates.<!-- more --></p>

<p>Leiningen has long-supported the generation of new projects from templates and it&rsquo;s pretty slick. Want to get a new <a href="https://github.com/framework-one/fw1-clj">Framework One</a> application up and running?</p>

<pre><code>lein new fw1 myapp
cd myapp
PORT=8123 lein run
</code></pre>

<p>That&rsquo;s all it takes. No directories and files to create, no editing. Just tell Leiningen to create a new <code>fw1</code> project called <code>myapp</code>, drop into that newly created directory and run the generated skeleton application.</p>

<p>Behind the scenes, Leiningen looks for the most recent release of the <code>fw1/lein-template</code> artifact on Clojars (or Maven Central), downloads it and adds it to the classpath, then it <code>require</code>s the <code>leiningen.new.fw1</code> namespace (assumed to be in that artifact) and calls the <code>fw1</code> function within that namespace. That <code>fw1</code> template project in turn relies on the <code>leiningen.new.templates</code> namespace to provide a number of functions to <code>render</code> new project files from mustache-style templates, using the <a href="https://github.com/davidsantiago/stencil">Stencil library</a>. Leiningen templates may also depend on Leiningen&rsquo;s core code, as well as a few libraries that Leiningen always makes available (such as <a href="https://github.com/scgilardi/slingshot">Slingshot</a>).</p>

<p>I figured that in order to kickstart any <code>boot new</code> functionality, it would make sense for it to be able to render existing Leiningen templates, as well as Boot-specific templates. Since Boot deliberately includes source code directly from other projects so as to minimize the number of dependencies it brings in, and it already had several pieces of Leiningen copied into it, I reached out to <a href="https://github.com/hyPiRion">Leiningen&rsquo;s current maintainer, Jean Niklas L'orange</a> and asked permission to include parts of Leiningen&rsquo;s new/template support. He graciously said yes &ndash; thank you! &ndash; so I created a raw first cut of a <code>new</code> task for Boot, based directly on Leiningen&rsquo;s code, which in turn depended on Bultitude and <code>leiningen-core</code> (and a few other bits and pieces). Because Boot tasks are &ldquo;just Clojure&rdquo;, it was fairly straightforward to get to a <a href="https://github.com/seancorfield/boot-new/blob/v0.1.0/src/boot/new.clj">working 0.1.0 version</a> that had basic parity with <code>lein new</code>.</p>

<p>Since Boot already provided ways to manage dependencies and the classpath, my next goal was <a href="https://github.com/seancorfield/boot-new/blob/v0.2.0/src/boot/new.clj">an 0.2.0 version that didn&rsquo;t rely on Leiningen&rsquo;s core</a>. This version provided the same functionality (well, almost, it had compatibility bugs that took another version to iron out) but no longer needed to bring in <code>leiningen-core</code> as a dependency (unless you were generating a Leiningen template which might itself rely on that).</p>

<p>At this point, I was able to implement built-in templates to match Leiningen&rsquo;s <code>app</code>, <code>default</code> (library), <code>plugin</code>, and <code>template</code>, which would produce Boot-specific versions. The <a href="https://github.com/seancorfield/boot-new/tree/v0.2.1/src/boot/new">0.2.1 version included built-in templates</a> for <code>app</code>, <code>default</code>, <code>task</code> (the Boot equivalent of a plugin), and <code>template</code>.</p>

<p>Boot <code>new</code> had both <code>leiningen.new.templates</code> (adapted to run inside Boot) and <code>boot.new.templates</code> to support Boot templates. A Boot template is just like a Leiningen template, with a couple of important exceptions: the artifact name is of the form <code>foo/boot-template</code> (instead of <code>foo/lein-template</code>) and the template&rsquo;s main namespace is <code>boot.new.foo</code> (instead of <code>leiningen.new.foo</code>). In addition, a Boot template is expected to rely on Boot&rsquo;s internals or explicitly specify its own dependencies &ndash; instead of depending on Leiningen&rsquo;s core library. As a final piece of clean up for this &ldquo;initial&rdquo; version of Boot <code>new</code>, I removed the dependency on Bultitude (which actually hadn&rsquo;t been needed for a while) and deferred the addition of the <code>leiningen-core</code> and <code>slingshot</code> dependencies so they wouldn&rsquo;t be pulled in if you were generating a project from a Boot template.</p>

<p>At this point, I felt Boot <code>new</code> was ready to announce to the world! I could do:</p>

<pre><code>boot -d seancorfield/boot-new new -t fw1 -n myapp
</code></pre>

<p>and get a freshly generated Framework One app, even if that still used Leiningen to actually run the new app. I could do:</p>

<pre><code>boot -d seancorfield/boot-new new -t app -n myapp
</code></pre>

<p>to get a skeleton for an application that was &ldquo;powered by Boot&rdquo;: the generated <code>build.boot</code> file provides tasks for <code>build</code>ing the application uber-JAR and <code>run</code>ing the application itself.</p>

<p><a href="https://github.com/alandipert">Alan Dipert</a> and <a href="https://github.com/pesterhazy">Paulus Esterhazy</a> were the first two people to uncover compatibility bugs with existing Leiningen templates (for Hoplon and Chestnut, respectively). Thank you! And that brought me to Release 0.3.1 of <a href="https://github.com/seancorfield/boot-new">boot-new</a>.</p>

<p>The next thing on my roadmap is to add some sort of &ldquo;generator&rdquo; function (not unlike <a href="https://github.com/weavejester/lein-generate">James Reeves' lein-generate</a>) which will allow you to add new pieces to your existing projects, much Rails/Grails have built-in commands to let you add new models, controllers, and so on. That will be part of 0.4.0 and probably go through a couple of revisions. At some point, I&rsquo;ll feel comfortable declaring a 1.0.0 release and then we&rsquo;ll see about getting Boot <code>new</code> merged into the core of Boot itself.</p>

<p>Boot originally started life as a part of Hoplon and for a long time, you needed Leiningen in order to generate a new Hoplon project, even tho' Hoplon itself was powered-by-Boot. It&rsquo;s nice to see <a href="https://github.com/hoplon/hoplon/wiki/Get-Started#start-from-a-template">Hoplon&rsquo;s Getting Started</a> using <code>boot-new</code> as the recommended way to generate a new Hoplon project (it&rsquo;s still a Leiningen template!).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing With Boot]]></title>
    <link href="http://corfield.org/blog/2016/01/31/testing-with-boot/"/>
    <updated>2016-01-31T07:30:00-08:00</updated>
    <id>http://corfield.org/blog/2016/01/31/testing-with-boot</id>
    <content type="html"><![CDATA[<p>In <a href="http://corfield.org/blog/2016/01/30/building-on-boot/">Building On Boot</a>, I gave some high level benefits we&rsquo;d found with Boot, compared to Leiningen, and how it had helped up streamline our build process. That article closed with a note about Boot not having the equivalent of common Leiningen plugins, and that&rsquo;s what I&rsquo;m going to cover here, since that was the first real obstacle we encountered.<!-- more --></p>

<p>We use <a href="http://jayfields.com/expectations/">Jay Fields' Expectations</a> library very heavily for most of our testing needs. We use <code>clojure.test</code> only for our <a href="https://github.com/semperos/clj-webdriver">Clojure-powered WebDriver testing</a>. Leiningen has a <code>test</code> task built-in and we had been using <a href="https://github.com/gar3thjon3s/lein-expectations">lein-expectations</a> for years. It was quite a shock to find out that Boot has no testing tasks built-in!</p>

<p>Boot&rsquo;s standard for driving <code>clojure.test</code> is <a href="https://github.com/adzerk-oss/boot-test">Adzerk&rsquo;s boot-test</a>. Using it in your <code>build.boot</code> file is as simple as adding a dependency on <code>[adzerk/boot-test "1.0.7" :scope "test"]</code> and then referring in the <code>test</code> task:</p>

<pre><code>(merge-env! :dependencies '[[adzerk/boot-test "1.0.7" :scope "test"]])
(require '[adzerk.boot-test :refer [test]])
</code></pre>

<p>Now you can do <code>boot test</code> and run any tests in any of the namespaces in your source paths. Unfortunately there was no equivalent for Expectations so this was my first chance to roll up my sleeves and write a Boot task as a standalone project. The result is <a href="https://github.com/seancorfield/boot-expectations">boot-expectations</a>. Add a dependency on <code>[seancorfield/boot-expectations "1.0.5" :scope "test"]</code> and then refer in the <code>expectations</code> task:</p>

<pre><code>(merge-env! :dependencies '[[seancorfield/boot-expectations "1.0.5" :scope "test"]])
(require '[seancorfield.boot-expectations :refer [expectation]])
</code></pre>

<p>Now you can do <code>boot expectations</code> to run any Expectations tests in any of the namespaces in your source paths. Do <code>boot expectations -h</code> to see all the options the task provides.</p>

<p>I relied very heavily on two sources for this project: Adzerk&rsquo;s <code>boot-test</code> for the shape of the code and the <a href="https://clojurians.slack.com/messages/boot/">#boot channel</a> on the <a href="http://clojurians.net">Clojurians Slack</a> where Boot&rsquo;s maintainers hang out and are <em>extremely attentive and helpful</em>! In particular, <a href="https://github.com/micha">Micha Niskin</a> was invaluable, answering all my newbie questions and making suggestions. Boot&rsquo;s &ldquo;pods&rdquo; made it easy to specify the version of Clojure to use when running the tests, without affecting the version of Clojure used for anything else in the build process (we have always run our tests against the released version we are actually using as well as the latest snapshot of Clojure&rsquo;s master branch so we don&rsquo;t get surprised by any changes being introduced in the next release). The &ldquo;pod&rdquo; machinery also made it straightforward to have namespaces required into the testing environment, and shutdown functions run after the tests, again without affecting the main build process. And all in a single JVM process that runs for the duration of the build.</p>

<p>As you can see on Boot&rsquo;s wiki, the ecosystem of <a href="https://github.com/boot-clj/boot/wiki/Community-Tasks">community-maintained Boot tasks</a> is already pretty strong and growing all the time.</p>

<p>Back to our build process and one of the key drivers for looking at Boot in the first place: we&rsquo;d hit around 30K lines of production Clojure and 10K lines of test Clojure code, and we had it in three fair-sized projects with Leiningen. We wanted to reorganize the code and break it up into many more projects in order to have more flexibility in how we deploy code as well as being able to develop and test smaller chunks of code in isolation. We also wanted to be able to &ldquo;pin&rdquo; versions of certain libraries that we depended on across multiple &ldquo;projects&rdquo;. With Leiningen we&rsquo;d had multiple <code>project.clj</code> files and were already finding that we were pushing the declarative envelope of Leiningen by having to escape executable code into our <code>defproject</code> form. It felt like we were starting to fight the build tool. The declarative nature of <code>project.clj</code> didn&rsquo;t feel natural for the more fluid approach we wanted to take with our code base. What appealed about Boot was the possibility of a single <code>build.boot</code> file that could mix'n'match source and test code from various locations to allow the more modular develop / test approach we were aiming for, while still being able to easily build, push, and depend on artifacts from sub-projects. With Leiningen, we had a project for our WebDriver tests and it depended on a JAR built from the main source code project, so we would build and install (locally) a JAR of our main project, as part of the build. With Boot and a single <code>build.boot</code> file it was much easier to set up execution and test &ldquo;contexts&rdquo; as tasks that built the list of dependencies and source paths needed for each testing task. We now have all our Clojure code as &ldquo;sub-projects&rdquo; but can treat it as a single project too where that is more convenient.</p>

<p>In the next post, I&rsquo;ll take a diversion from World Singles' use of Boot and look at the <a href="https://github.com/seancorfield/boot-new">Boot new</a> project I&rsquo;ve been working on for a month &ndash; another &ldquo;missing piece of the ecosystem&rdquo; that I wanted to help fill!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building on Boot]]></title>
    <link href="http://corfield.org/blog/2016/01/30/building-on-boot/"/>
    <updated>2016-01-30T12:30:00-08:00</updated>
    <id>http://corfield.org/blog/2016/01/30/building-on-boot</id>
    <content type="html"><![CDATA[<p>In yesterday&rsquo;s blog post, <a href="http://corfield.org/blog/2016/01/29/rebooting-clojure/">Rebooting Clojure</a>, I talked about our switch from Leiningen to Boot but, as Sven Richter observed in the comments, I only gave general reasons why we preferred Boot, without a list of pros and cons.</p>

<p>Over the coming weeks, I&rsquo;ll write a series of posts about some of the specifics that worked better for us, as well as some of the obstacles we had to overcome in the transition.</p>

<p>In this post, I&rsquo;m going to cover some of the pros at a high level as it improved our build / test process.<!-- more --></p>

<p>I mentioned that we&rsquo;d evolved a fair size Ant script over time that does most of the heavy lifting of our build / test / deploy process. We&rsquo;d gradually been replacing parts of that process with Clojure code but it was easier to stick a <code>-main</code> function in certain namespaces to call into our code than to turn chunks of our code into Leiningen plugins. A case in point was our database and data migration tasks. We have developed a persistence layer in Clojure, built on top of <a href="https://github.com/clojure/java.jdbc">clojure.java.jdbc</a>, that encapsulates our connection pooling strategies and environment settings. Our migration code was built on top of that. Our Ant script invoked Leiningen to run these <code>-main</code> functions at various points. With each of these, we had repeated code to deal with command line arguments, process and environment set up, and then calls to what were, in effect, a series of &ldquo;tasks&rdquo;.</p>

<p>With Boot, we were able to eliminate a lot of that boilerplate. Boot tasks have command line argument parsing built-in. There&rsquo;s no need to create a <code>-main</code> function &ndash; the Boot tasks can call directly into our code. At this point we could easily compose tasks in a pipeline to satisfy any combination of database and data migration scenarios we needed, and we could simplify our Ant script to run a pipeline of Boot tasks as needed: which also meant we only fired up one JVM for that whole part of our build, instead of multiple invocations of Leiningen, each invoking a <code>-main</code> function.</p>

<p>We also have some CFML applications in the mix. Because history. We had several tasks accessible via HTTP requests into those CFML applications and those were also invoked by the Ant script because it was easy to do. Over time, we&rsquo;re committed to moving more and more of the CFML functionality down into Clojure (for what I hope are obvious reasons). Some of the tasks we were invoking via HTTP in Ant were already just thin CFML veneers over Clojure functionality, fortunately, so we were easily able to create a Boot task to call that functionality instead of going through CFML via HTTP.</p>

<p>Could we have done all this with Leiningen and plugins? Perhaps. Our experience with writing Leiningen plugins at this point had discouraged us from large scale plugin development. We were able to achieve more in a couple of weeks with Boot than we&rsquo;d able or willing to attempt with Leiningen in a long time.</p>

<p>There were cons too, of course, and the biggest was that several of Leiningen&rsquo;s built-in tasks and popular plugins, on which we relied heavily, were either absent or extremely different with Boot. I&rsquo;ll cover some of those in my next post.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rebooting Clojure]]></title>
    <link href="http://corfield.org/blog/2016/01/29/rebooting-clojure/"/>
    <updated>2016-01-29T14:30:00-08:00</updated>
    <id>http://corfield.org/blog/2016/01/29/rebooting-clojure</id>
    <content type="html"><![CDATA[<p>We switched from <a href="http://leiningen.org/">Leiningen</a> to <a href="http://boot-clj.com/">Boot</a>. What is Boot and why did we switch?<!-- more --></p>

<h2>Leiningen</h2>

<p>Before we talk about Boot, let&rsquo;s first talk about Leiningen. Leiningen describes itself as being &ldquo;for automating Clojure projects without setting your hair on fire&rdquo; and claims to be &ldquo;the easiest way to use Clojure&rdquo;. Rightly so. Leiningen hides all of the messy Maven-y dependency stuff, makes it drop-dead simple to package your applications and libraries as JAR files, makes it easy to run Clojure and provides a nice REPL experience, as well as integrating well with all the editors that Clojurians enjoy.</p>

<p>For a long time, Leiningen was the only game in town, and when we started using Clojure at World Singles, it was the fundamental basis of everything we did with parentheses. We started with a 1.x version of Leiningen, we upgraded to 2.x and we constructed a fair bit of our build / deploy / execute chain around it.</p>

<p>We wrote a couple of Leiningen plugins to deal with some &ldquo;interesting&rdquo; use cases in our environment: one to copy just dependencies to a specific target folder, one to set up a browser environment to run multiple <a href="https://github.com/semperos/clj-webdriver">clj-webdriver</a> tests in a single browser session.</p>

<p>Over time we evolved a fairly large Ant script and a bunch of shell scripts but we really wanted to do more of that automation with Leiningen &ndash; since it&rsquo;s all about &ldquo;automating Clojure projects&rdquo; &ndash; but the reality of writing Leiningen plugins for general automation doesn&rsquo;t quite live up to the promise. Between the declarative nature of <code>project.clj</code> and overall framework in which plugins must execute, there&rsquo;s a lot more than just &ldquo;writing Clojure&rdquo; and there are evaluation restrictions around the processes. Bottom line, we just didn&rsquo;t get as far as we&rsquo;d have liked with Leiningen.</p>

<h2>Early Boot</h2>

<p>Going back to the second ever <a href="http://www.clojurebridge.org/">ClojureBridge</a> workshop. I was organizing this and at teacher training we were going over the curriculum that had been built for the first workshop and it used an early version of Boot. Unfortunately, it was a very rough experience and virtually unusable on Windows. As my first exposure to Boot, it was less than ideal and it put me off exploring it any further.</p>

<p>Looking back, I&rsquo;m sure Boot was well-designed from the start and the design choices made were all solid &ndash; Boot was created by some very smart people &ndash; but I was less than charitable about Boot and unnecessarily vocal. I didn&rsquo;t take Boot very seriously.</p>

<h2>Boot 2.5.0</h2>

<p>Coming back to the present, Boot 2.5.0 was released in mid-December 2015. I owed it a serious second look. I was impressed. For starters, the installation process had become hella slick and the documentation looked really good. My early exploration was to try Boot on Windows 10, Mac OS X, and Linux for both the REPL experience and the basic project build process. One of the most striking differences from Leiningen was that &ldquo;it&rsquo;s just Clojure&rdquo;: the build script is straightforward executable Clojure, and tasks are just functions, and everything is based on an abstraction of a fileset. Another striking difference is that composability is baked right into the core of Boot: tasks are like Ring middleware and can wrap each other in a pipeline that allows tasks to take control both before and after other tasks in the pipeline.</p>

<p>After a promising &ldquo;first look&rdquo;, I decided to convert a couple of our core processes to run under Boot so that I could see what a real <code>build.boot</code> would look like in our environment. The only fly in the ointment for us was that Boot uses a single JVM and we were used to being able to compute our JVM options in <code>project.clj</code> (inside the first Leiningen JVM) for use by the application JVM (Leiningen&rsquo;s second JVM). By contrast, Boot uses environment variables to set up a single JVM environment and is a minimal intrusion itself. Boot further mitigates its own intrusion by allowing you execute code in a &ldquo;pod&rdquo; with its own isolated dependencies.</p>

<p>We opted for a wrapper shell script to deal with our JVM environment computation. Once we had that in place, having just a single JVM up and running was a win all round: every process started up faster, our task and automation code was simpler.</p>

<p>We decided on a two week spike to replace Leiningen with Boot across our entire project, and lift all of our executable processes up as Boot tasks. As of January 21st, we have Boot as an integral part of our production infrastructure. We&rsquo;re happy.</p>

<p>In the next blog post, I&rsquo;ll talk about some of the specifics in our Boot infrastructure and the tasks we&rsquo;re writing. As a teaser, you can look at <a href="https://github.com/seancorfield/boot-expectations">boot-expectations</a> and <a href="https://github.com/seancorfield/boot-new">boot-new</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Where Did 2015 Go?]]></title>
    <link href="http://corfield.org/blog/2016/01/03/where-did-2015-go/"/>
    <updated>2016-01-03T08:00:00-08:00</updated>
    <id>http://corfield.org/blog/2016/01/03/where-did-2015-go</id>
    <content type="html"><![CDATA[<p>I did not intend to stop blogging in 2015 but that&rsquo;s certainly what it looks like here!</p>

<p>So what kept me so busy that I didn&rsquo;t get around to blogging anything?<!-- more --></p>

<p>Almost a year ago, I <a href="http://corfield.org/blog/2015/02/13/frege-and-clojure/">talked about my Leiningen plugin for Frege</a>. Back then it was version 3.22.367. That plugin is now version 3.23.450 and there&rsquo;s a Leiningen template to go with it, tracking prerelease builds of Frege which I&rsquo;ve been publishing to Sonatype&rsquo;s OSS Snapshots repository.</p>

<pre><code>lein new frege myapp
</code></pre>

<p>That will generate a new, pure Frege project for you to build on. If you want a mixed Frege and Clojure project, like the original concept:</p>

<pre><code>lein new frege myapp -- :with-clojure
</code></pre>

<p>I haven&rsquo;t gotten to work with Frege as much as I&rsquo;d hoped but I managed to contribute ports of two very small Haskell 2010 libraries (<code>System.Environment</code> and <code>System.Exit</code>) as well as exposing a few more pieces of Java&rsquo;s <code>Runtime</code> class in Frege&rsquo;s <code>java.lang.System</code> data type. I hope 2016 will bring a lot more Frege to my life!</p>

<p>In that blog post, I also talked about learning a new language every year. I mentioned <a href="http://elm-lang.org/">Elm</a>: I&rsquo;d experimented with it quite a bit in its early days and I&rsquo;d hoped to continue experimenting, but work and life distracted me from front end concerns and I lost touch with Elm&rsquo;s evolution. All I can say is that Elm continues to go from strength to strength, and it is gaining more press inches and more visibility at conferences, which is all good. It&rsquo;s truly innovative and I want to see it succeed! I did however spend quite a bit of time learning a little <a href="https://www.rust-lang.org">Rust</a> and it makes me wish I did a lot more close-to-the-metal programming: it&rsquo;s a <em>really</em> nice language and the &ldquo;borrowing&rdquo; system is very impressive (even if you find yourself fighting with it a lot at first!).</p>

<p>In the past, I&rsquo;ve also blogged about almost every conference I&rsquo;ve attended so you would be forgiven for thinking I didn&rsquo;t attend any events in 2015. I was able to attend The Strange Loop and Clojure/conj this past year. I would have loved to have attended Clojure/West as <a href="http://clojurewest.org/speakers#fhanreich">my colleague Fumiko gave a talk about HoneySQL</a>. That link will evaporate when this year&rsquo;s conference comes around but you can <a href="https://www.youtube.com/watch?v=alkcjyhesjI">watch Fumiko&rsquo;s talk about HoneySQL</a> on ClojureTV. It was her first ever conference talk and she did a great job &ndash; I&rsquo;m very proud of her! Oh, she also likes Elm.</p>

<p>Fumiko and I worked on a project with ClojureScript, <a href="http://reagent-project.github.io/">Reagent</a> &ndash; a ClojureScript wrapper for <a href="http://facebook.github.io/react/">React.js</a>, and <a href="https://github.com/ptaoussanis/sente">Sente</a> &ndash; core.async over WebSockets. It was a lot of fun and very interesting. It was a proof of concept but, in the end, our company decided to go with JavaScript as being more mainstream (but still with React.js so, win!).</p>

<p><a href="http://www.thestrangeloop.com/">The Strange Loop</a> was its usual amazing self. Alex Miller and his team manage to excel themselves, year-on-year. The keynote talks were <em>phenomenal</em> this year with Idalin Bob&eacute;&rsquo;s inspiring talk about activism and Morgan Marquis-Boire&rsquo;s terrifying security and espionage talk as the highlights of the whole conference. The &ldquo;theme&rdquo; this year was distributed systems. I think this image sums it up well:</p>

<p><img class="center" src="http://corfield.org/images/distributed.jpg" width="600" height="450" title="image" alt="images"></p>

<p>The other highlight for me was a social event: the <a href="http://lgbtq.technology/">LGBTQ in Technology Slack</a> dinner, generously sponsored by <a href="https://codeclimate.com/">Code Climate</a>. The Strange Loop team work hard to ensure the conference is a diverse, welcoming, safe space for everyone and I was excited to be able to organize this dinner with the support of the conference organizers.</p>

<p>That social theme continued at <a href="http://clojure-conj.org/">Clojure/conj</a> in Philadelphia where I was able to spend time with more folks from the LGBTQ in Technology Slack community (and had a lovely dinner at <a href="http://www.thetwistedtail.com/">The Twisted Tail</a> with my friend <a href="https://twitter.com/quephird">Danielle</a>. If you&rsquo;re ever in Philly, <em>go to that restaurant</em>!!).</p>

<p>As usual, Clojure/conj was an incredible mix of real world Clojure, academic research, and bleeding edge exploration in industry. One talk made the entire conference worth the cost for me: Bobby Calderwood&rsquo;s <a href="https://www.youtube.com/watch?v=qDNPQo9UmJA">From REST to CQRS</a> with Clojure, Kafka (and Samza), and Datomic. The &ldquo;hallway track&rdquo; that followed this talk caused me to miss the last two talks but it was oh so valuable! Fast forward two months and we&rsquo;re starting down the path of Kafka and distributed systems at work. Priceless, as they say. Other highlights were the father and son Engelbergs on Automata, Ram Krishnan&rsquo;s &ldquo;Clojure for Business Teams&rdquo;, Stuart Halloway&rsquo;s keynote &ldquo;Debugging with the Scientific Method&rdquo; (<em>everyone</em> should watch <a href="https://www.youtube.com/watch?v=FihU5JxmnBg">this talk</a>), Lee Spector&rsquo;s &ldquo;Genetic Programming&rdquo; talk, and Benjamin Pierce&rsquo;s keynote about formal specifications and generative testing.</p>

<p>And then there was work&hellip;</p>

<p>I love my job, I love my team, and we get to solve some fascinating problems at <a href="http://worldsinglesnetworks.com/">World Singles</a>. The company has a history of using <a href="http://www.adobe.com/products/coldfusion-family.html">ColdFusion</a>, although we switched to a Free Open Source Software alternative in 2009 and we&rsquo;ve been running on <a href="http://lucee.org/">Lucee</a> for most of 2015. We started using Clojure in production almost five years ago now (with Clojure 1.3 Alpha 7 or Alpha 8) and we declared it our &ldquo;primary language&rdquo; about a year ago. Since then we&rsquo;ve systematically rewritten code in Clojure as we&rsquo;ve needed to enhance functionality &ndash; definitely a situation where &ldquo;refactor&rdquo; really does mean &ldquo;rewrite&rdquo;. I created a bridge project that allows Cloure to be loaded and run easily inside CFML engines about five years ago and that&rsquo;s continued to evolve. The MVC framework I created in 2009 has continued to evolve as well, with 2015 seeing release 3.1 and 3.5 &ndash; the latter has integrated the Clojure bridge, to enable seamless mixed language projects. We rely heavily on this. Release 4.0 is almost ready for Alpha 1, and focuses on enhancing REST API capabilities.</p>

<p>In addition, we created an OAuth 2 server, mostly in Clojure, to support our REST API, and we&rsquo;ve worked hard to move all of our persistence from CFML&rsquo;s &ldquo;query&rdquo; functionality to a Clojure &ldquo;<a href="https://github.com/seancorfield/datamapper">data mapper</a>&rdquo; based on <a href="http://clojure-doc.org/articles/ecosystem/java_jdbc/home.html">clojure.java.jdbc</a>. We closed out 2015 with <em>all</em> of our persistence handled by Clojure, a big win for performance and maintainability!</p>

<p>Our other big change, coming at the tail end of year, was a switch from <a href="http://leiningen.org/">Leiningen</a> to <a href="http://boot-clj.com/">Boot</a> for our primary Clojure build tool. I&rsquo;ll be blogging about this more in due course, but for now I&rsquo;ll just mention the <a href="https://github.com/seancorfield/boot-expectations">Boot task for running Expectations tests</a> and that Leiningen-style templates will be coming to Boot soon&hellip;</p>

<p>Happy 2016!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Frege (and Clojure)]]></title>
    <link href="http://corfield.org/blog/2015/02/13/frege-and-clojure/"/>
    <updated>2015-02-13T03:32:18-07:00</updated>
    <id>http://corfield.org/blog/2015/02/13/frege-and-clojure</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve often said that I try to follow <a href="https://pragprog.com/the-pragmatic-programmer">The Pragmatic Programmer&rsquo;s</a> advice to learn a new language every year. I don&rsquo;t always achieve it, but I try. As I&rsquo;ve settled into Clojure as my primary language over the last several years, I&rsquo;ve made a fair attempt to learn Python, Ruby, Racket/Scheme, Standard ML and more recently <a href="http://elm-lang.org">Elm</a>. I learned that I like Python, I don&rsquo;t like Ruby, Racket/Scheme is &ldquo;just another Lisp&rdquo; (I already have Clojure) and SML is very interesting but not really widely useful these days (it&rsquo;s a great language for learning Functional Programming concepts tho'!). I also spent some time with Go last year (don&rsquo;t like it).</p>

<p>The Elm language is really nice - and useful for building interactive browser-based applications (and games). I&rsquo;ve been meaning to blog about it for quite a while, and I hope to get around to that in due course. Elm is sort of inspired by Haskell, and that&rsquo;s really what this blog post is about. Sort of.<!-- more --></p>

<p>Haskell and I have a strange relationship. I really liked Haskell when it appeared in the early 90&rsquo;s. I hoped it would finally be the language to help Functional Programming go mainstream (I&rsquo;d been dabbling with FP for about a decade by then). It didn&rsquo;t. Sigh. But I continued to dabble with FP - and Haskell - on and off (mostly off) for another couple of decades. I&rsquo;ve occasionally blogged about Haskell (yes, on my old ColdFusion-focused blog it used to crop up about once a year), and I&rsquo;ve always wanted to be able to <em>use</em> Haskell for something more than just playing around. For a long, long time tho', my programming life has been tied to the JVM, for better or worse, and Haskell&rsquo;s standalone nature has meant that I haven&rsquo;t been able to integrate it into my daily stack.</p>

<p>That tie to the JVM is why I learned Groovy, Scala, Clojure - and took them all to production - but haven&rsquo;t really been able to get deeply into Python (much as I like it)&hellip; or poor old Haskell, despite now decades of toying with it.</p>

<p>Fortunately for me, Ingo Wechsung likes Haskell enough that he created the <a href="http://www.frege-lang.org">Frege programming language</a> which is &ldquo;a <strong>pure</strong> functional programming language for the JVM in the spirit of Haskell&rdquo;. It&rsquo;s sufficiently similar to Haskell - see <a href="https://github.com/Frege/frege/wiki/Differences-between-Frege-and-Haskell">Differences between Frege and Haskell</a> - that many people consider Frege to be &ldquo;Haskell for the JVM&rdquo;. This makes me happy because I can finally start to use Haskell (sort of) as part of my daily stack and therefore <em>really learn it</em>! Finally!</p>

<p>So why is this post titled <strong>Frege (and Clojure)</strong>?</p>

<p>Given that Clojure is my primary language, what I really want is to be able to use Frege alongside Clojure, writing small routines in Frege that I can call from Clojure. That means I need a way to compile and load Frege code via Leiningen, Clojure&rsquo;s build tool. So I created <code>lein-fregec</code>, a <a href="https://github.com/seancorfield/lein-fregec">Frege plugin for Leiningen</a>, that allows you to compile pure Frege projects, as well as compile and run mixed language Frege / Clojure projects.</p>

<p>Today I released version <del>3.22.324</del> <strong>3.22.367-i</strong> (to match the current version of the Frege compiler), along with two example Leiningen projects (in that same repo) to show how to use <code>lein-fregec</code> for pure Frege projects as well as Clojure / Frege projects. Let&rsquo;s take a look at the mixed language one.</p>

<p>Here&rsquo;s the Frege code:</p>

<pre><code>module Fibonacci where

-- lazy infinite sequence of Fibonacci numbers starting with a, b:
fibs a b = a : fibs b (a + b)

-- lazy infinite sequence of Fibonacci numbers (0, 1, 1, 2, 3, ...):
fibonacci = fibs 0 1

-- let Frege infer the types here (it'll be Int -&gt; Int):
fibn n = head $ drop n $ fibonacci

-- Clojure uses Long by default so this is our public API:
fib :: Long -&gt; Long
fib n = Int.long $ fibn (Long.int n)
</code></pre>

<p>This declares a module (class in the Java bytecode) called <code>Fibonacci</code> which contains four functions. Even tho' Frege is a (very) strongly typed language, you can often omit the types as it will infer them for you. Starting at the bottom, we have <code>fib</code> which is declared to take a <code>Long</code> and return a <code>Long</code> - and will be compiled down to a static method on the <code>Fibonacci</code> class and therefore easily callable from Clojure (or Java). It casts its argument <code>n</code> to an integer, calls <code>fibn</code> on it, and then casts the result to a <code>Long</code> to return it to Clojure. <code>f $ g x</code> is shorthand for <code>f (g x)</code> that avoids the parentheses. <code>fibn</code>, in turn starts with the (lazy infinite) sequence of fibonacci numbers and drops the first <code>n</code> of them (the sequence starts with zero, but I&rsquo;m treating one as the &ldquo;first&rdquo; number) and then returns the first of what&rsquo;s left (the <code>head</code>). Again <code>$</code> means we don&rsquo;t have to write <code>head (drop n (fibonnaci))</code>. The <code>fibonacci</code> function takes no arguments and just calls <code>fibs</code> with the seed values of zero and one. <code>fibs</code> takes two arguments and returns a sequence with the first argument followed by the fibonacci sequence that starts with the second argument. Frege, like Haskell, is a non-strict (lazy) language so <code>fibs</code> isn&rsquo;t really a recursive call, even tho' it looks like it ought to blow the stack. Instead, when it is called, it returns a list whose first element is (the value of) <code>a</code> and whose remaining elements will be evaluated as needed - or rather <em>if needed</em>. Technically, it doesn&rsquo;t even evaluate <code>a</code> unless you actually refer to the value.</p>

<p>What that means is that when <code>fib</code> is called, the cast (from <code>Int</code> to <code>Long</code>) forces evaluation of the call to <code>fibn</code>, which in turn asks for the <code>head</code> of &hellip; the sequence we get by dropping the first <code>n</code> elements of &hellip; that lazy infinite sequence. So we construct the first <code>n + 1</code> elements of the list and then we look at the last one of those, which forces the calculation of that value (yes, the additions are deferred until the value is needed!). We write simple, obvious code that looks like it might be very inefficient but Frege ensures that only the values we actually need are ever calculated - and because of the way the sequence is constructed from previous elements, it means that once we&rsquo;ve calculated the <em>nth</em> number, all the previous ones are essentially calculated and cached for us. This is possible because our functions are <strong>pure</strong> (no side effects).</p>

<p>What about the Clojure code? Since Frege compiles modules to classes and certain functions (with basic Java type signatures) to static methods, we simply import the compiled class and call the function we want:</p>

<pre><code>(ns example.core
  (:import Fibonacci))

... (Fibonacci/fib 13) ...
</code></pre>

<p>We can even play with the code from the REPL:</p>

<pre><code>$ lein do fregec, repl
...
example.core=&gt; (Fibonacci/fib 11)
89
example.core=&gt; (Fibonacci/fib 42)
267914296
example.core=&gt; 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Strange Loop 2014]]></title>
    <link href="http://corfield.org/blog/2014/09/25/the-strange-loop-2014/"/>
    <updated>2014-09-25T18:32:18-07:00</updated>
    <id>http://corfield.org/blog/2014/09/25/the-strange-loop-2014</id>
    <content type="html"><![CDATA[<p>Last week I attended <a href="https://thestrangeloop.com/">The Strange Loop</a> in St Louis. I attended in 2011 and was blown away. I missed 2012 but attended again in 2013 and was blown away once more. I already have 2015&rsquo;s dates in my calendar. How was 2014?<!-- more --></p>

<p>Yup, blown away again. Alex Miller and his team have created an iconic event that crosses technology boundaries and bridges between academia and industry, to bring some of the brightest minds together to share their ideas. And for attendees too, the opportunity to meet a huge variety of our peers - from novice to expert - in all different technologies, creates an atmosphere of excitement, wonder, and enjoyment.</p>

<p>All the sessions were recorded and have been posted to YouTube. Link at the bottom of this post!</p>

<p>Here are the sessions I attended with brief notes so you can see why I love this conference:</p>

<ul>
<li>Joe Armstrong - The Mess We&rsquo;re In. The creator of Erlang focused on the overwhelming complexity of the systems we are building today, and how they got that way, with a good dose of humor and some quantum mechanics.</li>
<li>Jessica Kerr - Concurrency Options on the JVM. Jessica took us on a whirlwind tour of Clojure, Scala, Java and what they offer the developer (futures, agents, actors, parallel streams, channels, executors etc), with a whimsical (but consistent) analogy of traffic patterns in JVM-town. A great overview with enough detail to be very useful!</li>
<li>Ambrose Bonnaire-Sargeant - Typed Clojure in Practice. We&rsquo;re using core.typed a little at work so I wanted to hear how others were using it in a production environment. After starting out with a practical example of eliminating bugs through gradual typing, Ambrose walked through a case study of CircleCI which has applied core.typed to a substantial amount of their code. It greatly encouraged me!</li>
<li>Julie Lavoie - Analyzing Rap Lyrics with Python. This sounded so off-the-wall I was intrigued - and I&rsquo;m actually a huge fan of early West Coast rap music (although I find the misogyny very hard to take which, again, was something that intrigued me about the talk). Julie&rsquo;s talk looked at numerous pitfalls in the process end-to-end as well as the difficulties in establishing good metrics of sexism. Musical excerpts, lots of data, lots of questions. A fascinating topic!</li>
<li>Amanda Laucher, Paul Snively - Type Systems: The Good, Bad, and Ugly. Honest, opinionated, and somewhat controversial, Amanda and Paul took us on a tour of type systems available in current and future languages. My takeaway: if you don&rsquo;t like static typing, you have probably only used languages with bad or ugly type systems - but we&rsquo;re not quite there yet in terms of capabilities&hellip;</li>
<li>Brian McKenna - Idris: Practical Dependent Types With Practical Examples. &hellip;which was a nice segue into Brian&rsquo;s talk which showed us some of the things that a truly powerful type system can do for us. Idris isn&rsquo;t production-ready yet but it&rsquo;s an exciting glimpse into a future where type systems are powerful, really useful, and relatively painless to use. I&rsquo;ll need to watch this one a few more times, I think.</li>
<li>Leah Hanson - How Julia Goes Fast. I&rsquo;m currently reading <a href="https://pragprog.com/book/7lang/seven-more-languages-in-seven-weeks">Seven More Languages in Seven Weeks</a> and one of those seven is Julia. I haven&rsquo;t gotten to that chapter yet but I wanted to hear more about how it achieves near-C level performance. Leah took us through various implementation details, showing what Julia was capable of. Her passion for Julia was contagious and I&rsquo;m really looking forward to that chapter now!</li>
<li>Stefanie Schirmer - Dynamic Programming at Ease: with Grammars, Algebras, Products. Stefanie showed us a very powerful set of abstractions that can tame a very difficult type of programming algorithm, with reference to real-world analysis of RNA molecules. Like Brian&rsquo;s talk on Idris, I&rsquo;ll need to watch this a few more times to soak it all in.</li>
<li>Stephen Wolfram - Inside the Wolfram Language. Wolfram is a system that has grown to encompass a huge amount of knowledge across many different disciplines, and Stephen was able to give us a preview of their brand new &ldquo;programming language&rdquo; that can query their (very impressive) knowledge engine. Highly entertaining - make sure you watch the video!</li>
<li>Eleanor McHugh - Fun with Go (Unsession). Several friends have raved about Go so, before the conference, I installed it and worked through the built-in &ldquo;Tour of Go&rdquo; and learned a little of the language. In fifty minutes of fun and increasingly wild and wacky code, Eleanor taught me a lot more of Go than the official tour. I found myself repeatedly thinking &ldquo;Wow! I didn&rsquo;t know Go could do that!&rdquo;.</li>
<li>Nada Amin - Programming Should Eat Itself. Meta-turtles, all the way down. Nada explored reflective metaprogramming. I wasn&rsquo;t sure of the &ldquo;why&rdquo; behind this talk, but she proved that the way to really understand an academic computer science paper is to implement the ideas in it yourself.</li>
<li>Evan Czaplicki - Controlling Space and Time: understanding the many formulations of FRP. Evan created the <a href="http://elm-lang.org">Elm programming language</a> as an embodiment of Functional Reactive Programming &ldquo;done right&rdquo;, so I was very interested to get the &ldquo;big picture&rdquo; on this space. Great background for the different types of FRP out there.</li>
<li>Bodil Stokke - PureScript (Maybe This Time We Get JavaScript Right). Bodil was highly entertaining as always, this time live programming a game in PureScript, a Haskell-like language that compiled down to JavaScript. Although it has many surface similarities to Elm, it is a much more lightweight system, which she needed for her use case. Interestingly, she has built a library in PureScript that provides some of Elm&rsquo;s elegant Signal semantics (which she will hopefully open source soon!).</li>
<li>Rich Hickey - Transducers. Drawing parallels with how we describe processes in the real world - as a series of steps to be performed together - Rich showed how transducers allow us to describe processes in Clojure, without needing to specify the format of inputs, outputs, or intermediate results. Coming soon to a Clojure release near you (it&rsquo;s in 1.7.0-alpha2 already).</li>
<li>Ian Davis - The challenges and benefits of a functional reactive frontend. Ian described Prismatic&rsquo;s experiences with a large-scale interactive web application that is built with ClojureScript and Om on top of Facebook&rsquo;s React.js framework. Real world FRP at scale.</li>
<li>Heather Miller - Function Passing Style: Typed, Distributed Functional Programming. The actor model allows use to perform distributed processing by sending data to nodes and getting results back. Heather talk looked at a different model where the data is distributed (rather than the processing) and you send your functions out to the data instead. Having played with distributed function execution in a cluster of Hazelcast nodes, I was left thinking &ldquo;So?&rdquo; but the emphasis on type systems and immutability means I probably missed something important in her talk so I&rsquo;ll have to watch it again.</li>
<li>Elise Huard - Writing a Game in Haskell. I hadn&rsquo;t considered Haskell as a language for writing games but Elise used it to showcase Functional Reactive Programming as the core of her game&rsquo;s engine. She had embarked on the project for a bit of fun and she shared the whole journey with us, from initial curiosity about games, to design, to multiple implementations and the challenges and paths not taken along the way, to the finished game - and a <a href="https://leanpub.com/gameinhaskell">forthcoming book about her experiences</a>.</li>
<li>Aditya Siram - Shen: A Sufficiently Advanced Lisp. Aditya showed us some of Shen&rsquo;s power - building on traditional Lisp values with a powerful macro system and a powerful type system - producing very elegant solutions.</li>
</ul>


<p>Big trends this year? Functional Reactive Programming (in the real world), and Advanced Type Systems (coming soon?).</p>

<p>One final note on the conference: I picked topics that interested / intrigued me without paying much attention to the speakers (because, with a handful of exceptions, I don&rsquo;t recognize most of the speakers listed anyway!) and now I see that over half of the sessions I attended had women speakers. As I noted last year, Alex Miller and his team did a terrific job of <a href="http://corfield.org/blog/2013/09/22/the-strange-loop-2013/">ensuring a diverse speaker lineup</a> - and did it again this year! I&rsquo;ve been reading some great blog posts from people who attended the conference this year on the <a href="https://thestrangeloop.com/news/doubling-down-on-diversity">diversity scholarships</a> that were set up. It shows that we <em>can</em> change things if we try. We still have a long way to go for equality in tech, but The Strange Loop is a great model for us in that area.</p>

<p>You can watch all of these sessions for free now, on <a href="https://www.youtube.com/channel/UC_QIfHvN9auy2CoOdSfMWDw">The Strange Loop 2014 YouTube channel</a>!</p>
]]></content>
  </entry>
  
</feed>
